<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GGSTU</title>
  
  <subtitle>Good Good Study</subtitle>
  <link href="/wuzhenyong1997/atom.xml" rel="self"/>
  
  <link href="https://www.ggstu.com/"/>
  <updated>2018-08-19T14:25:31.917Z</updated>
  <id>https://www.ggstu.com/</id>
  
  <author>
    <name>Wu Zhenyong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Scala中的继承</title>
    <link href="https://www.ggstu.com/2018/08/19/Scala%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <id>https://www.ggstu.com/2018/08/19/Scala中的继承/</id>
    <published>2018-08-19T11:36:56.000Z</published>
    <updated>2018-08-19T14:25:31.917Z</updated>
    
    <content type="html"><![CDATA[<p><strong>extends关键字实现继承</strong><br>Scala中，与Java一样，也是使用extends关键字让子类继承父类，使用继承可以有效地复用代码。<br>继承表示子类可以继承父类的属性和方法，子类可以在自己内部放入父类所没有而子类特有的属性和方法。<br>子类可以覆盖父类的属性和方法，但是如果父类用final修饰，属性和方法用final修饰，则该类是无法被继承的，即属性和方法是无法被覆盖。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    private var name = &quot;Tom&quot;</span><br><span class="line">    def getName = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    private var score = &quot;A&quot;</span><br><span class="line">    def getScore = score</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student</span><br><span class="line">s: Student = Student@332729ad</span><br><span class="line"></span><br><span class="line">scala&gt; s.getScore</span><br><span class="line">res0: String = A</span><br><span class="line"></span><br><span class="line">scala&gt; s.getName</span><br><span class="line">res1: String = Tom</span><br></pre></td></tr></table></figure></p><p><br><br><strong>在子类中重写父类的方法</strong><br>Scala中，如果子类要覆盖一个父类中的非抽象方法，则必须使用override关键字。<br>在子类覆盖父类方法之后，如果在子类中要调用父类的被覆盖的方法，可以使用super关键字，显式地指定要调用父类的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    private var name = &quot;Tom&quot;</span><br><span class="line">    def getName = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    private var score = &quot;A&quot;</span><br><span class="line">    def getScore = score</span><br><span class="line">    override def getName = &quot;Hello,I&apos;m &quot; + super.getName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student</span><br><span class="line">s: Student = Student@3e74829</span><br><span class="line"></span><br><span class="line">scala&gt; s.getName</span><br><span class="line">res0: String = Hello,I&apos;m Tom</span><br></pre></td></tr></table></figure></p><p>Scala中，子类可以覆盖父类的val属性，而且还可以覆盖父类的val属性的getter方法，只要在子类中使用override关键字即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    val name:String = &quot;Person&quot;</span><br><span class="line">    def age:Int = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    override val name:String = &quot;Tom&quot;</span><br><span class="line">    override val age:Int = 21</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student</span><br><span class="line">s: Student = Student@6853425f</span><br><span class="line"></span><br><span class="line">scala&gt; s.name</span><br><span class="line">res0: String = Tom</span><br><span class="line"></span><br><span class="line">scala&gt; s.age</span><br><span class="line">res1: Int = 21</span><br></pre></td></tr></table></figure></p><p>跟java一样，Scala中同样可以使用protected关键字来修饰属性和方法，这样在子类中就不需要super关键字，直接就可以访问属性和方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    protected var name:String = &quot;Tom&quot;</span><br><span class="line">    protected var age:Int = 21</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    def sayHello = println(&quot;Hello,&quot; + name)</span><br><span class="line">    def ageCompare(s:Student)&#123;</span><br><span class="line">        println(&quot;I&apos;m &quot; + age + &quot; years old,you are &quot; + s.age + &quot;years old.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined class Student</span><br></pre></td></tr></table></figure></p><p>还可以使用protected[this]，表示只能在当前子类对象中访问父类的属性和方法，无法通过其他子类对象访问父类的属性和方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    protected var name:String = &quot;Tom&quot;</span><br><span class="line">    protected[this] var age:Int = 21</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    def sayHello = println(&quot;Hello,&quot; + name)</span><br><span class="line">    def ageCompare(s:Student)&#123;</span><br><span class="line">        println(&quot;I&apos;m &quot; + age + &quot; years old,you are &quot; + s.age + &quot;years old.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">&lt;console&gt;:21: error: value age is not a member of Student</span><br><span class="line">               println(&quot;I&apos;m &quot; + age + &quot; years old,you are &quot; + s.age + &quot;years old.&quot;)</span><br><span class="line">                                                                ^</span><br></pre></td></tr></table></figure></p><p><br><br><strong>匿名子类</strong><br>可以通过包含带有定义或重写的代码块的方式创建一个匿名子类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student(val name:String,val age:Int)&#123;</span><br><span class="line">     |     def sayHello() = &quot;Hello,my name is &quot; + name + &quot;,I&apos;m &quot; + age + &quot; years old.&quot;</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; var s:Student = new Student(&quot;Tom&quot;,21)&#123;</span><br><span class="line">     |     override def sayHello() = &quot;匿名子类中的sayHello方法&quot;</span><br><span class="line">     | &#125;</span><br><span class="line">s: Student = $anon$1@1115ec15</span><br><span class="line"></span><br><span class="line">scala&gt; println(s.sayHello())</span><br><span class="line">匿名子类中的sayHello方法</span><br></pre></td></tr></table></figure></p><p><br><br><strong>抽象类</strong><br>抽象类使用abstract关键字来标记，抽象类是不可以实例化的，只能用来继承。<br>在子类中覆盖抽象类的抽象方法时，不需要使用override关键字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">abstract class Person(val name:String)&#123;</span><br><span class="line">    def sayHello:Unit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student(name:String) extends Person(name)&#123;</span><br><span class="line">    def sayHello:Unit = println(&quot;Hello,my name is &quot; + name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student(&quot;Tom&quot;)</span><br><span class="line">s: Student = Student@571c5681</span><br><span class="line"></span><br><span class="line">scala&gt; s.sayHello</span><br><span class="line">Hello,my name is Tom</span><br></pre></td></tr></table></figure></p><p>object也可以继承抽象类，并覆盖抽象类中的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">abstract class Person(val name:String)&#123;</span><br><span class="line">    def sayHello(name:String):Unit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object Student extends Person(&quot;Tom&quot;)&#123;</span><br><span class="line">    override def sayHello(name:String)=&#123;</span><br><span class="line">        println(&quot;Hello,my name is &quot; + name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined object Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = Student</span><br><span class="line">s: Student.type = Student$@41294f8</span><br></pre></td></tr></table></figure></p><p><br><br><strong>抽象字段</strong><br>如果在父类中，定义了字段，但是没有给出初始值，则此字段为抽象字段。<br>抽象字段意味着，Scala会根据自己的规则，为var或val类型的字段生成对应的getter和setter方法，但是父类中是没有该字段的。<br>子类覆盖抽象字段，不需要使用override关键字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">abstract class Person&#123;</span><br><span class="line">    val name:String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    val name:String = &quot;Tom&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student</span><br><span class="line">s: Student = Student@53251a66</span><br><span class="line"></span><br><span class="line">scala&gt; s.name</span><br><span class="line">res0: String = Tom</span><br></pre></td></tr></table></figure></p><p><br><br><strong>类型判断</strong><br><strong>isInstanceOf和asInstanceOf</strong><br>如果创建了子类的对象，但是又将其赋予了父类类型的变量。则在后续的程序中，要将父类类型的变量转换为子类类型的变量，首先需要使用isInstanceOf判断对象是否是指定类的对象，如果是的话，则可以使用asInstanceOf将对象转换为指定类型。<br>如果对象是null，则isInstanceOf一定返回false，asInstanceOf一定返回null。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">class Student extends Person</span><br><span class="line">val p:Person = new Student</span><br><span class="line">var s:Student = null</span><br><span class="line">if(p.isInstanceOf[Student])  s = p.asInstanceOf[Student]</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined class Student</span><br><span class="line">p: Person = Student@3eb81efb</span><br><span class="line">s: Student = Student@3eb81efb</span><br></pre></td></tr></table></figure></p><p><strong>getClass和classOf</strong><br>isInstanceOf只能判断出对象是否是指定类以及子类的对象，而不能精确判断出对象就是指定类的对象<br>如果要求精确地判断对象就是指定类的对象，就只能使用getClass和classOf<br>对象.getClass可以精确获取对象的类，classOf[类]可以精确获取类，然后使用==操作符即可判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Person</span><br><span class="line">defined class Person</span><br><span class="line"></span><br><span class="line">scala&gt; class Student extends Person</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val p:Person = new Student</span><br><span class="line">p: Person = Student@3c01cfa1</span><br><span class="line"></span><br><span class="line">scala&gt; p.isInstanceOf[Person]</span><br><span class="line">res0: Boolean = true</span><br><span class="line"></span><br><span class="line">scala&gt; p.getClass == classOf[Person]</span><br><span class="line">res1: Boolean = false</span><br><span class="line"></span><br><span class="line">scala&gt; p.getClass == classOf[Student]</span><br><span class="line">res2: Boolean = true</span><br></pre></td></tr></table></figure></p><p><strong>使用模式匹配进行类型判断</strong><br>使用模式匹配，功能性上来说，与instanceOf一样，也是判断对象是否该类以及该类的子类的对象，不是精准判断的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">class Student extends Person</span><br><span class="line">val p:Person = new Student</span><br><span class="line">p match&#123;</span><br><span class="line">    case per:Person =&gt; println(&quot;It is Person&apos;s object.&quot;)</span><br><span class="line">    case _ =&gt; println(&quot;Unknown type.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">It is Person&apos;s object.</span><br><span class="line">defined class Person</span><br><span class="line">defined class Student</span><br><span class="line">p: Person = Student@2f40e5db</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;extends关键字实现继承&lt;/strong&gt;&lt;br&gt;Scala中，与Java一样，也是使用extends关键字让子类继承父类，使用继承可以有效地复用代码。&lt;br&gt;继承表示子类可以继承父类的属性和方法，子类可以在自己内部放入父类所没有而子类特有的属性和方法。&lt;br&gt;子类可以覆盖父类的属性和方法，但是如果父类用final修饰，属性和方法用final修饰，则该类是无法被继承的，即属性和方法是无法被覆盖。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala的apply方法</title>
    <link href="https://www.ggstu.com/2018/08/19/Scala%E7%9A%84apply%E6%96%B9%E6%B3%95/"/>
    <id>https://www.ggstu.com/2018/08/19/Scala的apply方法/</id>
    <published>2018-08-19T06:43:19.000Z</published>
    <updated>2018-08-19T14:19:53.025Z</updated>
    
    <content type="html"><![CDATA[<p>在Scala的object中，可以声明apply方法。<br>而使用”类名()”的形式，其实就是”类名.apply()”的一种缩写。通常使用这种方式来构造类的对象，而不是使用”new 类名()”的方式。<br>例如：”Hello World”(6)实际上就是”Hello World”.apply(6)的缩写。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; &quot;Hello World&quot;(6)</span><br><span class="line">res0: Char = W</span><br><span class="line"></span><br><span class="line">scala&gt; &quot;Hello World&quot;.apply(6)</span><br><span class="line">res1: Char = W</span><br></pre></td></tr></table></figure></p><p>例如：Array(1,2,3,4)，实际上是用Array object的apply()函数来创建Array类的实例，也就是一个数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; Array(1,2,3,4)</span><br><span class="line">res2: Array[Int] = Array(1, 2, 3, 4)</span><br><span class="line"></span><br><span class="line">scala&gt; Array.apply(1,2,3,4)</span><br><span class="line">res3: Array[Int] = Array(1, 2, 3, 4)</span><br></pre></td></tr></table></figure></p><p><br><br>通常在伴生对象中实现apply方法，在其中实现构造伴生类的对象的功能，此时创建对象可以省略new关键字<br>例如：定义自己的伴生类和伴生对象<br>此时创建对象由于省略了new关键字，就会在object中找对应的apply方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Student(val name:String)</span><br><span class="line"></span><br><span class="line">object Student&#123;</span><br><span class="line">    def apply(name:String) = new Student(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Student</span><br><span class="line">defined object Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = Student(&quot;Tom&quot;)</span><br><span class="line">s: Student = Student@7d286fb6</span><br></pre></td></tr></table></figure></p><p>如果没有apply方法，创建对象省略new关键字就会报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student(val name:String)</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student(&quot;Tom&quot;)</span><br><span class="line">s: Student = Student@4032d386</span><br><span class="line"></span><br><span class="line">scala&gt; val s1 = Student(&quot;Bob&quot;)</span><br><span class="line">&lt;console&gt;:11: error: not found: value Student</span><br><span class="line">       val s1 = Student(&quot;Bob&quot;)</span><br><span class="line">                ^</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Scala的object中，可以声明apply方法。&lt;br&gt;而使用”类名()”的形式，其实就是”类名.apply()”的一种缩写。通常使用这种方式来构造类的对象，而不是使用”new 类名()”的方式。&lt;br&gt;例如：”Hello World”(6)实际上就是”Hello World”.apply(6)的缩写。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala的object对象</title>
    <link href="https://www.ggstu.com/2018/08/19/Scala%E7%9A%84object%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.ggstu.com/2018/08/19/Scala的object对象/</id>
    <published>2018-08-19T05:59:59.000Z</published>
    <updated>2018-08-19T14:18:12.522Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Scala中的object对象</strong><br>在Scala中，没有提供静态的修饰符static，但是object对象下的成员都是静态的。<br>第一次调用object的方法时，就会执行object的构造函数，但是object不能定义接收参数的构造函数。<br>object的构造函数只会在其第一次被调用时执行一次，以后再次调用不会再执行构造函数。<br>object通常用于作为单例模式的实现，或者放class的静态成员。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; object Person&#123;</span><br><span class="line">     |     private var handNum = 2</span><br><span class="line">     |     def getHandNum = handNum</span><br><span class="line">     | &#125;</span><br><span class="line">defined object Person</span><br></pre></td></tr></table></figure></p><p><br><br><strong>伴生类和伴生对象</strong><br>如果有一个class，还有一个与class同名的object，那么就称这个object是class的伴生对象，class是object的伴生类。<br>伴生类和伴生对象必须存放在一个.scala文件中。<br>伴生类和伴生对象可以互相访问其私有成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">object Person&#123;</span><br><span class="line">    private val handNum = 2</span><br><span class="line">    def getHandNum = handNum</span><br><span class="line">&#125;</span><br><span class="line">class Person(val name:String,val age:Int)&#123;</span><br><span class="line">    def sayHello = println(&quot;Hello,my name is &quot; + name + &quot;.I&apos;m &quot; + age + &quot; years old and I have &quot; + Person.handNum + &quot; hands.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined object Person</span><br><span class="line">defined class Person</span><br><span class="line"></span><br><span class="line">scala&gt; val p = new Person(&quot;Tom&quot;,21)</span><br><span class="line">p: Person = Person@2df6226d</span><br><span class="line"></span><br><span class="line">scala&gt; p.sayHello</span><br><span class="line">Hello,my name is Tom.I&apos;m 21 years old and I have 2 hands.</span><br></pre></td></tr></table></figure></p><p><br><br><strong>main方法</strong><br>在scala中，如果要运行一个应用程序，那么必须有一个main方法作为入口。<br>scala中的main方法定义为def main(args:Array[String])，而且必须定义在object中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; object HelloWorld&#123;</span><br><span class="line">     |     def main(args:Array[String])&#123;</span><br><span class="line">     |         println(&quot;Hello World!&quot;)</span><br><span class="line">     |     &#125;</span><br><span class="line">     | &#125;</span><br><span class="line">defined object HelloWorld</span><br></pre></td></tr></table></figure></p><p>除了自己实现main方法外，还可以继承App Trait，然后将需要在main方法中运行的代码，直接作为object的构造函数代码，而且可以用args接收传入的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; object HelloWorld extends App&#123;</span><br><span class="line">     |     if(args.length &gt; 0) println(&quot;Hello,&quot; + args(0))</span><br><span class="line">     |     else println(&quot;Hello World!&quot;)</span><br><span class="line">     | &#125;</span><br><span class="line">defined object HelloWorld</span><br></pre></td></tr></table></figure></p><p>App Trait的工作原理：App Trait继承自DelayedInit Trait，scalac命令进行编译时，会把继承App Trait的object的构造函数代码都放到DelayedInit Trait的DelayedInit方法中执行。<br><br><br><strong>用object来实现枚举功能</strong><br>Scala没有类似于Java中的Enum这样的枚举特性，如果要实现枚举，需要使用object继承Enumeration类，并且调用Value方法来初始化枚举值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; object Season extends Enumeration&#123;</span><br><span class="line">     |     val SPRING,SUMMER,AUTUMN,WINTER = Value</span><br><span class="line">     | &#125;</span><br><span class="line">defined object Season</span><br></pre></td></tr></table></figure></p><p>还可以通过Value传入枚举值的id和name，通过id和toString可以获取值，还可以通过id和name来查找枚举值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; object Season extends Enumeration&#123;</span><br><span class="line">     |     val SPRING = Value(0,&quot;spring&quot;)</span><br><span class="line">     |     val SUMMER = Value(1,&quot;summer&quot;)</span><br><span class="line">     |     val AUTUMN = Value(2,&quot;autumn&quot;)</span><br><span class="line">     |     val WINTER = Value(3,&quot;winter&quot;)</span><br><span class="line">     | &#125;</span><br><span class="line">defined object Season</span><br><span class="line"></span><br><span class="line">scala&gt; Season.SPRING.id</span><br><span class="line">res0: Int = 0</span><br><span class="line"></span><br><span class="line">scala&gt; Season.SPRING.toString</span><br><span class="line">res1: String = spring</span><br><span class="line"></span><br><span class="line">scala&gt; Season(0)</span><br><span class="line">res2: Season.Value = spring</span><br><span class="line"></span><br><span class="line">scala&gt; Season.withName(&quot;spring&quot;)</span><br><span class="line">res3: Season.Value = spring</span><br></pre></td></tr></table></figure></p><p>使用枚举object.values可以遍历枚举值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; for(ele &lt;- Season.values) println(ele)</span><br><span class="line">spring</span><br><span class="line">summer</span><br><span class="line">autumn</span><br><span class="line">winter</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Scala中的object对象&lt;/strong&gt;&lt;br&gt;在Scala中，没有提供静态的修饰符static，但是object对象下的成员都是静态的。&lt;br&gt;第一次调用object的方法时，就会执行object的构造函数，但是object不能定义接收参数的构造函数。&lt;br&gt;object的构造函数只会在其第一次被调用时执行一次，以后再次调用不会再执行构造函数。&lt;br&gt;object通常用于作为单例模式的实现，或者放class的静态成员。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>老街</title>
    <link href="https://www.ggstu.com/2018/08/18/%E8%80%81%E8%A1%97/"/>
    <id>https://www.ggstu.com/2018/08/18/老街/</id>
    <published>2018-08-18T14:09:27.000Z</published>
    <updated>2018-08-19T07:20:46.724Z</updated>
    
    <content type="html"><![CDATA[<p><em>一张褪色的照片</em><br><em>好像带给我一点点怀念</em><br><em>巷尾老爷爷卖的热汤面</em><br><em>味道弥漫过旧旧的后院</em><br><em>流浪猫睡熟在摇晃秋千</em><br><a id="more"></a><br><em>夕阳照了一遍他眯着眼</em><br><em>那张同桌寄的明信片</em><br><em>安静的躺在课桌的里面</em><br><em>快要过完的春天</em><br><em>还有雕刻着图案的门帘</em><br><em>窄窄的长长的过道两边</em><br><em>老房子依然升起了炊烟</em><br><em>刚刚下完了小雨的季节</em><br><em>爸妈又一起走过的老街</em><br><em>记不得哪年的哪一天</em><br><em>很漫长又很短暂的岁月</em><br><em>现在已经回不去</em><br><em>早已流逝的光阴</em><br><em>手里的那一张渐渐模糊不清的车票</em><br><em>成了回忆的信号</em><br><em>忘不掉的是什么我也不知道</em><br><em>想不起当年模样</em><br><em>看也看不到</em> <em>去也去不了的地方</em><br><em>也许那老街的腔调是属于我的忧伤</em><br><em>嘴角那点微笑越来越勉强</em></p><p><em>忘不掉的是什么我也不知道</em><br><em>放不下熟悉片段</em><br><em>回头望一眼</em> <em>已经很多年的时间</em><br><em>透过手指间看着天</em><br><em>我又回到那老街</em><br><em>靠在你们身边渐行渐远</em></p><p><em>快要过完的春天</em><br><em>还有雕刻着图案的门帘</em><br><em>窄窄的长长的过道两边</em><br><em>老房子依然升起了炊烟</em><br><em>刚刚下完了小雨的季节</em><br><em>爸妈又一起走过的老街</em><br><em>记不得哪年的哪一天</em><br><em>很漫长又很短暂的岁月</em><br><em>现在已经回不去</em><br><em>早已流逝的光阴</em><br><em>手里的那一张渐渐模糊不清的车票</em><br><em>成了回忆的信号</em><br><em>忘不掉的是什么我也不知道</em><br><em>想不起当年模样</em><br><em>看也看不到</em> <em>去也去不了的地方</em><br><em>也许那老街的腔调是属于我的忧伤</em><br><em>嘴角那点微笑越来越勉强</em><br><em>忘不掉的是什么我也不知道</em><br><em>放不下熟悉片段</em><br><em>回头望一眼</em> <em>已经很多年的时间</em><br><em>透过手指间看着天</em><br><em>我又回到那老街</em><br><em>靠在你们身边渐行渐远</em></p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=133998&auto=1&height=66"></iframe><br><img src="http://pd8lpasbc.bkt.clouddn.com/%E5%A4%AB%E5%AD%90%E5%BA%991.jpg" width="60%" height="60%">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;一张褪色的照片&lt;/em&gt;&lt;br&gt;&lt;em&gt;好像带给我一点点怀念&lt;/em&gt;&lt;br&gt;&lt;em&gt;巷尾老爷爷卖的热汤面&lt;/em&gt;&lt;br&gt;&lt;em&gt;味道弥漫过旧旧的后院&lt;/em&gt;&lt;br&gt;&lt;em&gt;流浪猫睡熟在摇晃秋千&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="随便说说" scheme="https://www.ggstu.com/categories/%E9%9A%8F%E4%BE%BF%E8%AF%B4%E8%AF%B4/"/>
    
    
      <category term="心情" scheme="https://www.ggstu.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>Scala的类和对象</title>
    <link href="https://www.ggstu.com/2018/08/18/Scala%E7%9A%84%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.ggstu.com/2018/08/18/Scala的类和对象/</id>
    <published>2018-08-18T09:33:16.000Z</published>
    <updated>2018-08-19T14:00:40.823Z</updated>
    
    <content type="html"><![CDATA[<p>类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。<br><strong>创建类和对象</strong><br>例如：定义一个类，包含属性和方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Hello&#123;</span><br><span class="line">     |     private var name = &quot;Tom&quot;</span><br><span class="line">     |     def sayHello()&#123;println(&quot;Hello,my name is &quot; + name)&#125;</span><br><span class="line">     |     def getName = name</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Hello</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>创建类的对象，并调用其方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val s = new Hello</span><br><span class="line">s: Hello = Hello@3eb81efb</span><br><span class="line"></span><br><span class="line">scala&gt; s.sayHello()</span><br><span class="line">Hello,my name is Tom</span><br><span class="line"></span><br><span class="line">scala&gt; print(s.getName)</span><br><span class="line">Tom</span><br></pre></td></tr></table></figure></p><p><br><br><strong>属性的getter和setter方法</strong><br>当定义属性是var的时候，scala会自动为其生成对应的getter和setter方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student&#123;</span><br><span class="line">     |     var name = &quot;Tom&quot;</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br></pre></td></tr></table></figure></p><p>调用getter方法：name<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val t = new Student</span><br><span class="line">t: Student = Student@31920ade</span><br><span class="line"></span><br><span class="line">scala&gt; t.name</span><br><span class="line">res0: String = Tom</span><br></pre></td></tr></table></figure></p><p>调用setter方法：name_=<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; t.name = &quot;Bob&quot;</span><br><span class="line">t.name: String = Bob</span><br><span class="line"></span><br><span class="line">scala&gt; t.name</span><br><span class="line">res2: String = Bob</span><br></pre></td></tr></table></figure></p><p><br><br>当定义属性是val的时候，则只会生成getter方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student&#123;</span><br><span class="line">     |     val name = &quot;Tom&quot;</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br></pre></td></tr></table></figure></p><p>调用getter方法：name<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val t = new Student</span><br><span class="line">t: Student = Student@6cdba6dc</span><br><span class="line"></span><br><span class="line">scala&gt; t.name</span><br><span class="line">res0: String = Tom</span><br></pre></td></tr></table></figure></p><p>调用setter方法时出错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; t.name = &quot;Bob&quot;</span><br><span class="line">&lt;console&gt;:13: error: reassignment to val</span><br><span class="line">       t.name = &quot;Bob&quot;</span><br><span class="line">              ^</span><br></pre></td></tr></table></figure></p><p><br><br>当定义的属性是private的时候，则生成的getter和setter方法也是private的，即无法调用getter和setter方法，其只能在类中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student&#123;</span><br><span class="line">     |     private var name = &quot;Tom&quot;</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val t = new Student</span><br><span class="line">t: Student = Student@31920ade</span><br><span class="line"></span><br><span class="line">scala&gt; t.name</span><br><span class="line">&lt;console&gt;:14: error: variable name in class Student cannot be accessed in Student</span><br><span class="line">       t.name</span><br><span class="line">         ^</span><br><span class="line"></span><br><span class="line">scala&gt; t.name = &quot;Bob&quot;</span><br><span class="line">&lt;console&gt;:15: error: variable name in class Student cannot be accessed in Student</span><br><span class="line">val $ires0 = t.name</span><br><span class="line">               ^</span><br><span class="line">&lt;console&gt;:13: error: variable name in class Student cannot be accessed in Student</span><br><span class="line">       t.name = &quot;Bob&quot;</span><br><span class="line">         ^</span><br></pre></td></tr></table></figure></p><p>如果不希望生成getter和setter方法，则将属性声明为private[this]，表示该属性只属于该对象私有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student&#123;</span><br><span class="line">     |     private[this] var name = &quot;Tom&quot;</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val t = new Student</span><br><span class="line">t: Student = Student@1205bd62</span><br><span class="line"></span><br><span class="line">scala&gt; t.name</span><br><span class="line">&lt;console&gt;:14: error: value name is not a member of Student</span><br><span class="line">       t.name</span><br><span class="line">         ^</span><br><span class="line"></span><br><span class="line">scala&gt; t.name = &quot;Bob&quot;</span><br><span class="line">&lt;console&gt;:15: error: value name is not a member of Student</span><br><span class="line">val $ires0 = t.name</span><br><span class="line">               ^</span><br><span class="line">&lt;console&gt;:13: error: value name is not a member of Student</span><br><span class="line">       t.name = &quot;Bob&quot;</span><br><span class="line">         ^</span><br></pre></td></tr></table></figure></p><p><br><br>自定义getter和setter<br>可以根据需求为属性选择合适的修饰符：var、val、private、private[this]，进而来选择getter和setter方法<br>也可以自定义getter与setter方法对其进行控制<br>自定义setter方法的时候一定要注意scala的语法限制，属性_、=、参数间不能有空格<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student&#123;</span><br><span class="line">     |     private var myName = &quot;Tom&quot;</span><br><span class="line">     |     def name = &quot;My name is &quot; + myName</span><br><span class="line">     |     def name_=(newName:String)&#123;</span><br><span class="line">     |         println(&quot;Cannot change your name.&quot;)</span><br><span class="line">     |     &#125;</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val t = new Student</span><br><span class="line">t: Student = Student@5cdec700</span><br><span class="line"></span><br><span class="line">scala&gt; t.name</span><br><span class="line">res0: String = My name is Tom</span><br><span class="line"></span><br><span class="line">scala&gt; t.name = &quot;Bob&quot;</span><br><span class="line">Cannot change your name.</span><br><span class="line">t.name: String = My name is Tom</span><br></pre></td></tr></table></figure></p><p><br><br>设置属性只有getter方法<br>如果不希望属性有setter方法，可以将其定义为val，但是此时再也不能更改属性的值了<br>但是如果希望属性只有一个getter方法，并且能够更改属性的值，那么需要综合使用private以及自定义getter方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student&#123;</span><br><span class="line">     |     private var myName = &quot;Tom&quot;</span><br><span class="line">     |     def updateName(newName:String)&#123;</span><br><span class="line">     |         if(newName == &quot;Bob&quot;) myName = newName</span><br><span class="line">     |         else print(&quot;Cannot change your name.&quot;)</span><br><span class="line">     |     &#125;</span><br><span class="line">     |     def name = &quot;My name is &quot; + myName</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val t = new Student</span><br><span class="line">t: Student = Student@662706a7</span><br><span class="line"></span><br><span class="line">scala&gt; t.name</span><br><span class="line">res0: String = My name is Tom</span><br><span class="line"></span><br><span class="line">scala&gt; t.name = &quot;Bob&quot;</span><br><span class="line">&lt;console&gt;:13: error: value name_= is not a member of Student</span><br><span class="line">       t.name = &quot;Bob&quot;</span><br><span class="line">         ^</span><br><span class="line"></span><br><span class="line">scala&gt; t.updateName(&quot;Bob&quot;)</span><br><span class="line"></span><br><span class="line">scala&gt; t.name</span><br><span class="line">res2: String = My name is Bob</span><br><span class="line"></span><br><span class="line">scala&gt; t.updateName(&quot;Alice&quot;)</span><br><span class="line">Cannot change your name.</span><br></pre></td></tr></table></figure></p><p><br><br><strong>类的构造器</strong><br>类的构造器分为：主构造器、辅助构造器<br>Scala中，主构造器是与类名放在一起的，与java不同，并且只能有一个主构造器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student(val name:String,val age:Int)&#123;</span><br><span class="line">     |     println(&quot;Hello,my name is &quot; + name + &quot;,I&apos;m &quot; + age + &quot; years old.&quot;)</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student(&quot;Bob&quot;,18)</span><br><span class="line">Hello,my name is Bob,I&apos;m 18 years old.</span><br><span class="line">s: Student = Student@7a67e3c6</span><br></pre></td></tr></table></figure></p><p>主构造器还可以使用默认参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student(val name:String = &quot;Tom&quot;,val age:Int = 21)&#123;</span><br><span class="line">     |     println(&quot;Hello,my name is &quot; + name + &quot;,I&apos;m &quot; + age + &quot; years old.&quot;)</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student()</span><br><span class="line">Hello,my name is Tom,I&apos;m 21 years old.</span><br><span class="line">s: Student = Student@421bba99</span><br></pre></td></tr></table></figure></p><p>Scala中，可以给类定义多个辅助构造器，通过关键字this来实现<br>辅助构造器之间可以互相调用，而且必须第一行调用主构造器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Student&#123;</span><br><span class="line">    private var name = &quot;&quot;</span><br><span class="line">    private var age = 0</span><br><span class="line">    def this(name:String)&#123;</span><br><span class="line">        this()</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    def this(name:String,age:Int)&#123;</span><br><span class="line">        this(name)</span><br><span class="line">        this.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Student</span><br></pre></td></tr></table></figure></p><p><br><br><strong>内部类</strong><br>Scala中，同样可以在类中定义内部类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.collection.mutable.ArrayBuffer</span><br><span class="line">import scala.collection.mutable.ArrayBuffer</span><br><span class="line"></span><br><span class="line">scala&gt; class Class&#123;</span><br><span class="line">     |     class Student(val name:String)&#123;&#125;</span><br><span class="line">     |     val students = new ArrayBuffer[Student]</span><br><span class="line">     |     def getStudent(name:String) = &#123;</span><br><span class="line">     |         new Student(name)</span><br><span class="line">     |     &#125;</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Class</span><br><span class="line"></span><br><span class="line">scala&gt; val c = new Class</span><br><span class="line">c: Class = Class@1e287667</span><br><span class="line"></span><br><span class="line">scala&gt; val s = c.getStudent(&quot;Tom&quot;)</span><br><span class="line">s: c.Student = Class$Student@1e34c607</span><br><span class="line"></span><br><span class="line">scala&gt; c.students += s</span><br><span class="line">res0: c.students.type = ArrayBuffer(Class$Student@1e34c607)</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。&lt;br&gt;&lt;strong&gt;创建类和对象&lt;/strong&gt;&lt;br&gt;例如：定义一个类，包含属性和方法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scala&amp;gt; class Hello&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     |     private var name = &amp;quot;Tom&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     |     def sayHello()&amp;#123;println(&amp;quot;Hello,my name is &amp;quot; + name)&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     |     def getName = name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     | &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;defined class Hello&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala中的元祖</title>
    <link href="https://www.ggstu.com/2018/08/18/Scala%E4%B8%AD%E7%9A%84%E5%85%83%E7%A5%96/"/>
    <id>https://www.ggstu.com/2018/08/18/Scala中的元祖/</id>
    <published>2018-08-18T08:47:10.000Z</published>
    <updated>2018-08-18T09:20:16.600Z</updated>
    
    <content type="html"><![CDATA[<p>元祖是不同类型的值的集合<br>元祖的值是通过将单个的值包含在括号中构成的<br><strong>元祖的定义</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val t1 = (&quot;Tom&quot;,21,85.5)</span><br><span class="line">t1: (String, Int, Double) = (Tom,21,85.5)</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>以上的实例在元素中定义了三个元素，类型为Tuple3[java.lang.String,Int,Double]<br>这里Tuple是类型，3表示元祖中有三个元素<br>也可以使用下面的方式来定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val t2 = new Tuple3(&quot;Tom&quot;,21,85.5)</span><br><span class="line">t2: (String, Int, Double) = (Tom,21,85.5)</span><br></pre></td></tr></table></figure></p><p><br><br><strong>元祖的访问</strong><br>使用t._1访问第一个元素,t._2访问第二个元素，访问后面的元素依次类推<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val t3 = new Tuple4(&quot;Tom&quot;,21,85.5,true)</span><br><span class="line">t3: (String, Int, Double, Boolean) = (Tom,21,85.5,true)</span><br><span class="line"></span><br><span class="line">scala&gt; t3._1</span><br><span class="line">res0: String = Tom</span><br><span class="line"></span><br><span class="line">scala&gt; t3._2</span><br><span class="line">res1: Int = 21</span><br><span class="line"></span><br><span class="line">scala&gt; t3._3</span><br><span class="line">res2: Double = 85.5</span><br><span class="line"></span><br><span class="line">scala&gt; t3._4</span><br><span class="line">res3: Boolean = true</span><br></pre></td></tr></table></figure></p><p><br><br><strong>元祖的遍历</strong><br>使用Tuple.productIterator()方法来遍历元组的所有元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val t = (&quot;Tom&quot;,21,85.5)</span><br><span class="line">t: (String, Int, Double) = (Tom,21,85.5)</span><br><span class="line"></span><br><span class="line">scala&gt; t.productIterator.foreach(println)</span><br><span class="line">Tom</span><br><span class="line">21</span><br><span class="line">85.5</span><br></pre></td></tr></table></figure></p><p><font color="#f00">注意：</font>要遍历Tuple中的元素，首先要生成对应的迭代器，不能直接使用for或者foreach。<br><br><br><strong>元组转换成字符串</strong><br>使用Tuple.toString()方法将元组的所有元素组合成一个字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; t.toString</span><br><span class="line">res1: String = (Tom,21,85.5)</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;元祖是不同类型的值的集合&lt;br&gt;元祖的值是通过将单个的值包含在括号中构成的&lt;br&gt;&lt;strong&gt;元祖的定义&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scala&amp;gt; val t1 = (&amp;quot;Tom&amp;quot;,21,85.5)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;t1: (String, Int, Double) = (Tom,21,85.5)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>七夕的南京刮起了台风</title>
    <link href="https://www.ggstu.com/2018/08/17/%E4%B8%83%E5%A4%95%E7%9A%84%E5%8D%97%E4%BA%AC%E5%88%AE%E8%B5%B7%E4%BA%86%E5%8F%B0%E9%A3%8E/"/>
    <id>https://www.ggstu.com/2018/08/17/七夕的南京刮起了台风/</id>
    <published>2018-08-17T05:02:39.000Z</published>
    <updated>2018-08-17T13:48:55.361Z</updated>
    
    <content type="html"><![CDATA[<p>走进这汹涌的台风中<br>带着少年慌乱的脚步<br>带着藏匿在心底的不合时宜<br><a id="more"></a></p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=26508232&auto=1&height=66"></iframe><br><em><br>这次你离开了没有像以前那样说再见，再见也他M的只是再见<br>我们之间从来没有想象的那么接近，只是两棵树的距离<br>你是否还记得山阴路我八楼的房间，房间里唱歌的日日夜夜<br>那么热的夏天你看着外面，看着你在消逝的容颜<br>多么想念你走在我身边的样子，想起来我的爱就不能停止<br>南京的雨不停地下不停地下，就像你沉默的委屈<br>一转眼，我们的城市又到了夏天，对面走来的人都眯着眼<br>人们不敢说话不敢停下脚步，因为心动常常带来危险<br>我多么想念你走在我身边的样子，想起来我的爱就不能停止<br>南京的雨不停地下不停地下，有些人却注定要相遇<br>你是一片光荣的叶子落在我卑贱的心<br>像往常一样我为自己生气并且歌唱<br>那么乏力，爱也吹不动的叶子</em><br><img src="http://pd8lpasbc.bkt.clouddn.com/%E5%8F%B0%E9%A3%8E1.jpg" width="50%" height="50%"><br><img src="http://pd8lpasbc.bkt.clouddn.com/%E5%8F%B0%E9%A3%8E2.jpg" width="50%" height="50%"><br><img src="http://pd8lpasbc.bkt.clouddn.com/%E5%8F%B0%E9%A3%8E3.jpg" width="50%" height="50%"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;走进这汹涌的台风中&lt;br&gt;带着少年慌乱的脚步&lt;br&gt;带着藏匿在心底的不合时宜&lt;br&gt;
    
    </summary>
    
      <category term="随便说说" scheme="https://www.ggstu.com/categories/%E9%9A%8F%E4%BE%BF%E8%AF%B4%E8%AF%B4/"/>
    
    
      <category term="心情" scheme="https://www.ggstu.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>Scala的Map映射</title>
    <link href="https://www.ggstu.com/2018/08/17/Scala%E7%9A%84Map%E6%98%A0%E5%B0%84/"/>
    <id>https://www.ggstu.com/2018/08/17/Scala的Map映射/</id>
    <published>2018-08-17T02:24:20.000Z</published>
    <updated>2018-08-17T03:12:32.840Z</updated>
    
    <content type="html"><![CDATA[<p>Map(映射)是一种可迭代的键值对（key/value）结构，使用操作符”-&gt;”来创建。<br>Map中的键都是唯一的，所有的值都可以通过键来获取。<br>Map有两种类型，可变与不可变，区别在于可变集合的元素可以修改，不可变集合不可以修改。<br>默认情况下 Scala 使用不可变 Map。<br>如果需要使用可变集合，要显式的引入 import scala.collection.mutable.Map 类<br><a id="more"></a><br><strong>创建Map：</strong><br><strong>创建一个不可变的Map</strong><br>不可变的Map中元素不能修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val scores = Map(&quot;Tom&quot; -&gt; 75,&quot;Bob&quot; -&gt; 92,&quot;Alice&quot; -&gt; 85)</span><br><span class="line">scores: scala.collection.immutable.Map[String,Int] = Map(Tom -&gt; 75, Bob -&gt; 92, Alice -&gt; 85)</span><br><span class="line"></span><br><span class="line">scala&gt; scores(&quot;Tom&quot;) = 80</span><br><span class="line">&lt;console&gt;:13: error: value update is not a member of scala.collection.immutable.Map[String,Int]</span><br><span class="line">       scores(&quot;Tom&quot;) = 80</span><br><span class="line">       ^</span><br></pre></td></tr></table></figure></p><p><strong>创建一个可变的Map</strong><br>可变的Map中元素可以修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val scores = scala.collection.mutable.Map(&quot;Tom&quot; -&gt; 75,&quot;Bob&quot; -&gt; 92,&quot;Alice&quot; -&gt; 85)</span><br><span class="line">scores: scala.collection.mutable.Map[String,Int] = Map(Bob -&gt; 92, Tom -&gt; 75, Alice -&gt; 85)</span><br><span class="line"></span><br><span class="line">scala&gt; scores(&quot;Tom&quot;) = 80</span><br><span class="line"></span><br><span class="line">scala&gt; scores</span><br><span class="line">res2: scala.collection.mutable.Map[String,Int] = Map(Bob -&gt; 92, Tom -&gt; 80, Alice -&gt; 85)</span><br></pre></td></tr></table></figure></p><p><strong>使用另外一种方式创建Map</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val scores = Map((&quot;Tom&quot;,75), (&quot;Bob&quot;,92), (&quot;Alice&quot;,85))</span><br><span class="line">scores: scala.collection.immutable.Map[String,Int] = Map(Tom -&gt; 75, Bob -&gt; 92, Alice -&gt; 85)</span><br></pre></td></tr></table></figure></p><p><strong>创建一个空的HashMap</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val scores = new scala.collection.mutable.HashMap[String, Int]</span><br><span class="line">scores: scala.collection.mutable.HashMap[String,Int] = Map()</span><br></pre></td></tr></table></figure></p><p><br><br><strong>访问Map的元素：</strong><br><strong>获取指定key对应的value，如果key不存在，会报错</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val scores = Map(&quot;Tom&quot; -&gt; 75,&quot;Bob&quot; -&gt; 92,&quot;Alice&quot; -&gt; 85)</span><br><span class="line">scores: scala.collection.immutable.Map[String,Int] = Map(Tom -&gt; 75, Bob -&gt; 92, Alice -&gt; 85)</span><br><span class="line"></span><br><span class="line">scala&gt; val score = scores(&quot;Tom&quot;)</span><br><span class="line">score: Int = 75</span><br><span class="line"></span><br><span class="line">scala&gt; val score = scores(&quot;Jack&quot;)</span><br><span class="line">java.util.NoSuchElementException: key not found: Jack</span><br><span class="line">  at scala.collection.MapLike$class.default(MapLike.scala:228)</span><br><span class="line">  at scala.collection.AbstractMap.default(Map.scala:59)</span><br><span class="line">  at scala.collection.MapLike$class.apply(MapLike.scala:141)</span><br><span class="line">  at scala.collection.AbstractMap.apply(Map.scala:59)</span><br><span class="line">  ... 32 elided</span><br></pre></td></tr></table></figure></p><p><strong>使用contains函数检查key是否存在</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val score = if(scores.contains(&quot;Tom&quot;)) scores(&quot;Tom&quot;) else 0</span><br><span class="line">score: Int = 75</span><br><span class="line"></span><br><span class="line">scala&gt; val score = if(scores.contains(&quot;Jack&quot;)) scores(&quot;Jack&quot;) else 0</span><br><span class="line">score: Int = 0</span><br></pre></td></tr></table></figure></p><p><strong>使用getOrElse函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val score = scores.getOrElse(&quot;Tom&quot;, 0)</span><br><span class="line">score: Int = 75</span><br><span class="line"></span><br><span class="line">scala&gt; val score = scores.getOrElse(&quot;Jack&quot;, 0)</span><br><span class="line">score: Int = 0</span><br></pre></td></tr></table></figure></p><p><br><br><strong>修改Map的元素（必须是可变Map）：</strong><br>更新Map的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val scores = scala.collection.mutable.Map(&quot;Tom&quot; -&gt; 75,&quot;Bob&quot; -&gt; 92,&quot;Alice&quot; -&gt; 85)</span><br><span class="line">scores: scala.collection.mutable.Map[String,Int] = Map(Bob -&gt; 92, Tom -&gt; 75, Alice -&gt; 85)</span><br><span class="line"></span><br><span class="line">scala&gt; scores(&quot;Tom&quot;) = 80</span><br><span class="line"></span><br><span class="line">scala&gt; scores</span><br><span class="line">res1: scala.collection.mutable.Map[String,Int] = Map(Bob -&gt; 92, Tom -&gt; 80, Alice -&gt; 85)</span><br></pre></td></tr></table></figure></p><p>增加多个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; scores += (&quot;Jack&quot; -&gt; 100,&quot;Jerry&quot; -&gt; 60)</span><br><span class="line">res2: scores.type = Map(Bob -&gt; 92, Jerry -&gt; 60, Jack -&gt; 100, Tom -&gt; 80, Alice -&gt; 85)</span><br></pre></td></tr></table></figure></p><p>移除元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; scores -= &quot;Bob&quot;</span><br><span class="line">res3: scores.type = Map(Jerry -&gt; 60, Jack -&gt; 100, Tom -&gt; 80, Alice -&gt; 85)</span><br></pre></td></tr></table></figure></p><p>对于不可变的Map，不可以修改它的元素，但是可以将它的元素做改变后赋予其它变量<br>如下所示，将集合scores增加或移除元素后赋予新的集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val scores = Map(&quot;Tom&quot; -&gt; 75,&quot;Bob&quot; -&gt; 92,&quot;Alice&quot; -&gt; 85)</span><br><span class="line">scores: scala.collection.immutable.Map[String,Int] = Map(Tom -&gt; 75, Bob -&gt; 92, Alice -&gt; 85)</span><br><span class="line"></span><br><span class="line">scala&gt; scores += (&quot;Jack&quot; -&gt; 100,&quot;Jerry&quot; -&gt; 60)</span><br><span class="line">&lt;console&gt;:13: error: value += is not a member of scala.collection.immutable.Map[String,Int]</span><br><span class="line">       scores += (&quot;Jack&quot; -&gt; 100,&quot;Jerry&quot; -&gt; 60)</span><br><span class="line">              ^</span><br><span class="line"></span><br><span class="line">scala&gt; val scores2 = scores + (&quot;Jack&quot; -&gt; 100,&quot;Jerry&quot; -&gt; 60)</span><br><span class="line">scores2: scala.collection.immutable.Map[String,Int] = Map(Tom -&gt; 75, Jerry -&gt; 60, Bob -&gt; 92, Jack -&gt; 100, Alice -&gt; 85)</span><br><span class="line"></span><br><span class="line">scala&gt; val score3 = scores - &quot;Bob&quot;</span><br><span class="line">score3: scala.collection.immutable.Map[String,Int] = Map(Tom -&gt; 75, Alice -&gt; 85)</span><br></pre></td></tr></table></figure></p><p><br><br><strong>遍历Map的元素：</strong><br>遍历map的entrySet<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val scores = Map(&quot;Tom&quot; -&gt; 75,&quot;Bob&quot; -&gt; 92,&quot;Alice&quot; -&gt; 85)</span><br><span class="line">scores: scala.collection.immutable.Map[String,Int] = Map(Tom -&gt; 75, Bob -&gt; 92, Alice -&gt; 85)</span><br><span class="line"></span><br><span class="line">scala&gt; for((key,value) &lt;- scores) println(key + &quot;: &quot; + value)</span><br><span class="line">Tom: 75</span><br><span class="line">Bob: 92</span><br><span class="line">Alice: 85</span><br></pre></td></tr></table></figure></p><p>遍历Map：使用for或者foreach<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; for(s &lt;- scores) println(s)</span><br><span class="line">(Tom,75)</span><br><span class="line">(Bob,92)</span><br><span class="line">(Alice,85)</span><br><span class="line"></span><br><span class="line">scala&gt; scores.foreach(println)</span><br><span class="line">(Tom,75)</span><br><span class="line">(Bob,92)</span><br><span class="line">(Alice,85)</span><br></pre></td></tr></table></figure></p><p>遍历map的key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; for(key &lt;- scores.keySet) println(key)</span><br><span class="line">Tom</span><br><span class="line">Bob</span><br><span class="line">Alice</span><br></pre></td></tr></table></figure></p><p>遍历map的value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; for(value &lt;- scores.values) println(value)</span><br><span class="line">75</span><br><span class="line">92</span><br><span class="line">85</span><br></pre></td></tr></table></figure></p><p>生成新map，反转key和value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; for((key,value) &lt;- scores) yield (value,key)</span><br><span class="line">res3: scala.collection.immutable.Map[Int,String] = Map(75 -&gt; Tom, 92 -&gt; Bob, 85 -&gt; Alice)</span><br></pre></td></tr></table></figure></p><p><br><br><strong>SortedMap和LinkedHashMap：</strong><br>SortedMap可以自动对Map的key排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val scores1 = Map(&quot;Tom&quot; -&gt; 75,&quot;Bob&quot; -&gt; 92,&quot;Alice&quot; -&gt; 85)</span><br><span class="line">scores1: scala.collection.immutable.Map[String,Int] = Map(Tom -&gt; 75, Bob -&gt; 92, Alice -&gt; 85)</span><br><span class="line"></span><br><span class="line">scala&gt; val scores2 = scala.collection.immutable.SortedMap(&quot;Tom&quot; -&gt; 75,&quot;Bob&quot; -&gt; 92,&quot;Alice&quot; -&gt; 85)</span><br><span class="line">scores2: scala.collection.immutable.SortedMap[String,Int] = Map(Alice -&gt; 85, Bob -&gt; 92, Tom -&gt; 75)</span><br></pre></td></tr></table></figure></p><p>LinkedHashMap可以记住插入的顺序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val scores = new scala.collection.mutable.LinkedHashMap[String,Int]</span><br><span class="line">scores: scala.collection.mutable.LinkedHashMap[String,Int] = Map()</span><br><span class="line"></span><br><span class="line">scala&gt; scores(&quot;Alice&quot;) = 85</span><br><span class="line"></span><br><span class="line">scala&gt; scores(&quot;Tom&quot;) = 75</span><br><span class="line"></span><br><span class="line">scala&gt; scores(&quot;Bob&quot;) = 92</span><br><span class="line"></span><br><span class="line">scala&gt; scores</span><br><span class="line">res3: scala.collection.mutable.LinkedHashMap[String,Int] = Map(Alice -&gt; 85, Tom -&gt; 75, Bob -&gt; 92)</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Map(映射)是一种可迭代的键值对（key/value）结构，使用操作符”-&amp;gt;”来创建。&lt;br&gt;Map中的键都是唯一的，所有的值都可以通过键来获取。&lt;br&gt;Map有两种类型，可变与不可变，区别在于可变集合的元素可以修改，不可变集合不可以修改。&lt;br&gt;默认情况下 Scala 使用不可变 Map。&lt;br&gt;如果需要使用可变集合，要显式的引入 import scala.collection.mutable.Map 类&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala中的数组</title>
    <link href="https://www.ggstu.com/2018/08/16/Scala%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/"/>
    <id>https://www.ggstu.com/2018/08/16/Scala中的数组/</id>
    <published>2018-08-16T13:57:02.000Z</published>
    <updated>2018-08-18T09:20:22.021Z</updated>
    
    <content type="html"><![CDATA[<p><strong>定长数组：使用关键字Array</strong><br>在Scala中，Array代表的含义与Java中类似，也是长度不可改变的数组。<br>此外，由于Scala和Java都是运行在JVM上，双方可以互相调用，因此Scala数组的底层实际上是Java数组。<br>例如字符串数组在底层就是Java的String[]，整数数组在底层就是Java的Int[]<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a = new Array[Int](5)</span><br><span class="line">a: Array[Int] = Array(0, 0, 0, 0, 0)</span><br><span class="line"></span><br><span class="line">scala&gt; val b = new Array[String](5)</span><br><span class="line">b: Array[String] = Array(null, null, null, null, null)</span><br><span class="line"></span><br><span class="line">scala&gt; val c = Array(&quot;Tom&quot;,&quot;Bob&quot;,&quot;Alice&quot;)</span><br><span class="line">c: Array[String] = Array(Tom, Bob, Alice)</span><br><span class="line"></span><br><span class="line">scala&gt; c(0)</span><br><span class="line">res0: String = Tom</span><br></pre></td></tr></table></figure></p><p><br><br><strong>变长数组：使用关键字ArrayBuffer</strong><br>在Scala中，如果需要类似于Java中的ArrayList这种长度可变的集合类，可以使用ArrayBuffer定义变长数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.collection.mutable.ArrayBuffer</span><br><span class="line">import scala.collection.mutable.ArrayBuffer</span><br><span class="line"></span><br><span class="line">scala&gt; var b = ArrayBuffer[Int]()</span><br><span class="line">b: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer()</span><br></pre></td></tr></table></figure></p><p>使用+=操作符，可以添加一个元素，或者多个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; b += 1</span><br><span class="line">res0: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(1)</span><br><span class="line"></span><br><span class="line">scala&gt; b += (2,3,4,5)</span><br><span class="line">res1: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4, 5)</span><br></pre></td></tr></table></figure></p><p>使用++=操作符，可以添加其他集合中的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; b ++= Array(6,7,8,9,10)</span><br><span class="line">res2: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</span><br></pre></td></tr></table></figure></p><p>使用trimEnd()函数，可以从尾部截断指定个数的元素<br>比如去掉最后五个值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; b.trimEnd(5)</span><br><span class="line"></span><br><span class="line">scala&gt; b</span><br><span class="line">res4: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4, 5)</span><br></pre></td></tr></table></figure></p><p>使用insert()函数可以在指定位置插入元素<br>如在第2个位置插入6<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; b.insert(2,6)</span><br><span class="line"></span><br><span class="line">scala&gt; b</span><br><span class="line">res6: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(1, 2, 6, 3, 4, 5)</span><br></pre></td></tr></table></figure></p><p>在第4个位置插入7,8,9,10<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; b.insert(4,7,8,9,10)</span><br><span class="line"></span><br><span class="line">scala&gt; b</span><br><span class="line">res8: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(1, 2, 6, 3, 7, 8, 9, 10, 4, 5)</span><br></pre></td></tr></table></figure></p><p>使用remove()函数可以移除指定位置的元素<br>如移除第0个位置的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; b.remove(0)</span><br><span class="line">res9: Int = 1</span><br><span class="line"></span><br><span class="line">scala&gt; b</span><br><span class="line">res10: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(2, 6, 3, 7, 8, 9, 10, 4, 5)</span><br></pre></td></tr></table></figure></p><p>移除第2个位置开始后的5个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; b.remove(2,5)</span><br><span class="line"></span><br><span class="line">scala&gt; b</span><br><span class="line">res12: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(2, 6, 4, 5)</span><br></pre></td></tr></table></figure></p><p><br><br><strong>转换数组</strong><br>Array与ArrayBuffer可以互相进行转换：<br>将Array转换成ArrayBuffer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a = new Array[Int](5)</span><br><span class="line">a: Array[Int] = Array(0, 0, 0, 0, 0)</span><br><span class="line"></span><br><span class="line">scala&gt; a.toBuffer</span><br><span class="line">res0: scala.collection.mutable.Buffer[Int] = ArrayBuffer(0, 0, 0, 0, 0)</span><br></pre></td></tr></table></figure></p><p>将ArrayBuffer转换成Array<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.collection.mutable.ArrayBuffer</span><br><span class="line">import scala.collection.mutable.ArrayBuffer</span><br><span class="line"></span><br><span class="line">scala&gt; val b = new ArrayBuffer[Int]()</span><br><span class="line">b: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer()</span><br><span class="line"></span><br><span class="line">scala&gt; b.toArray</span><br><span class="line">res1: Array[Int] = Array()</span><br></pre></td></tr></table></figure></p><p>使用yield转换数组：<br>对Array进行转换，获取的还是Array<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a = Array(1,2,3,4,5)</span><br><span class="line">a: Array[Int] = Array(1, 2, 3, 4, 5)</span><br><span class="line"></span><br><span class="line">scala&gt; for(ele &lt;- a) yield ele*ele</span><br><span class="line">res0: Array[Int] = Array(1, 4, 9, 16, 25)</span><br></pre></td></tr></table></figure></p><p>对ArrayBuffer进行转换，获取的还是ArrayBuffer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.collection.mutable.ArrayBuffer</span><br><span class="line">import scala.collection.mutable.ArrayBuffer</span><br><span class="line"></span><br><span class="line">scala&gt; val b = ArrayBuffer[Int]()</span><br><span class="line">b: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer()</span><br><span class="line"></span><br><span class="line">scala&gt; b += (1,2,3,4,5)</span><br><span class="line">res1: b.type = ArrayBuffer(1, 2, 3, 4, 5)</span><br><span class="line"></span><br><span class="line">scala&gt; for(ele &lt;- b) yield ele*ele</span><br><span class="line">res2: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(1, 4, 9, 16, 25)</span><br></pre></td></tr></table></figure></p><p>结合if守卫，仅转换需要的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a = Array(1,2,3,4,5,6,7,8,9)</span><br><span class="line">a: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9)</span><br><span class="line"></span><br><span class="line">scala&gt; for(ele &lt;- a if ele%2 == 0) yield ele*ele</span><br><span class="line">res0: Array[Int] = Array(4, 16, 36, 64)</span><br></pre></td></tr></table></figure></p><p>使用函数式编程转换数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a = Array(1,2,3,4,5,6,7,8,9)</span><br><span class="line">a: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9)</span><br><span class="line"></span><br><span class="line">scala&gt; a.filter(_%2 == 0).map(_*2)</span><br><span class="line">res0: Array[Int] = Array(4, 8, 12, 16)</span><br><span class="line"></span><br><span class="line">scala&gt; a.filter&#123;_%2 == 0&#125; map &#123;_*2&#125;</span><br><span class="line">res1: Array[Int] = Array(4, 8, 12, 16)</span><br></pre></td></tr></table></figure></p><p><br><br><strong>遍历数组</strong><br>遍历Array和ArrayBuffer<br>使用for循环和until遍历Array/ArrayBuffer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var a = Array(1,2,3,4,5,6,7,8,9)</span><br><span class="line">a: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9)</span><br><span class="line"></span><br><span class="line">scala&gt; for(i &lt;- 0 until a.length)</span><br><span class="line">     |     print(a(i) + &quot; &quot;)</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure></p><p>跳跃遍历Array/ArrayBuffer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; for(i &lt;- 0 until (a.length,2))</span><br><span class="line">     |     print(a(i) + &quot; &quot;)</span><br><span class="line">1 3 5 7 9</span><br></pre></td></tr></table></figure></p><p>从尾部遍历Array/ArrayBuffer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; for(i &lt;- (0 until a.length).reverse)</span><br><span class="line">     |     print(a(i) + &quot; &quot;)</span><br><span class="line">9 8 7 6 5 4 3 2 1</span><br></pre></td></tr></table></figure></p><p>使用”增强for循环”遍历Array/ArrayBuffer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; for(b &lt;- a)</span><br><span class="line">     |     print(b + &quot; &quot;)</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure></p><p><br><br><strong>Scala数组的常用操作</strong><br>数组元素求和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a = Array(1,20,8,4,12)</span><br><span class="line">a: Array[Int] = Array(1, 20, 8, 4, 12)</span><br><span class="line"></span><br><span class="line">scala&gt; a.sum</span><br><span class="line">res0: Int = 45</span><br></pre></td></tr></table></figure></p><p>获取数组最大值和最小值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; a.max</span><br><span class="line">res1: Int = 20</span><br><span class="line"></span><br><span class="line">scala&gt; a.min</span><br><span class="line">res2: Int = 1</span><br></pre></td></tr></table></figure></p><p>对数组进行排序：<br>使用快速排序方法，其会修改数组a的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; a</span><br><span class="line">res3: Array[Int] = Array(1, 20, 8, 4, 12)</span><br><span class="line"></span><br><span class="line">scala&gt; scala.util.Sorting.quickSort(a)</span><br><span class="line"></span><br><span class="line">scala&gt; a</span><br><span class="line">res5: Array[Int] = Array(1, 4, 8, 12, 20)</span><br></pre></td></tr></table></figure></p><p>使用如下方法分别由小到大排序和由大到小排序，不会修改数组a的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a = Array(1,20,8,4,12)</span><br><span class="line">a: Array[Int] = Array(1, 20, 8, 4, 12)</span><br><span class="line"></span><br><span class="line">scala&gt; a.sortWith(_ &lt; _)</span><br><span class="line">res6: Array[Int] = Array(1, 4, 8, 12, 20)</span><br><span class="line"></span><br><span class="line">scala&gt; a.sortWith(_ &gt; _)</span><br><span class="line">res7: Array[Int] = Array(20, 12, 8, 4, 1)</span><br><span class="line"></span><br><span class="line">scala&gt; a</span><br><span class="line">res8: Array[Int] = Array(1, 20, 8, 4, 12)</span><br></pre></td></tr></table></figure></p><p>获取数组中所有元素内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; a</span><br><span class="line">res9: Array[Int] = Array(1, 20, 8, 4, 12)</span><br><span class="line"></span><br><span class="line">scala&gt; a.mkString</span><br><span class="line">res10: String = 1208412</span><br><span class="line"></span><br><span class="line">scala&gt; a.mkString(&quot;,&quot;)</span><br><span class="line">res11: String = 1,20,8,4,12</span><br><span class="line"></span><br><span class="line">scala&gt; a.mkString(&quot;(&quot;, &quot;,&quot;, &quot;)&quot;)</span><br><span class="line">res12: String = (1,20,8,4,12)</span><br></pre></td></tr></table></figure></p><p><br><br><strong>Scala的多维数组</strong><br>Scala的多维数组与Java相同，是通过数组的数组实现的。<br>也可以创建不规则的数组，每一行的长度各不相同。<br>定义一个固定长度的二维数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val matrix = Array.ofDim[Int](4,3)</span><br><span class="line">matrix: Array[Array[Int]] = Array(Array(0, 0, 0), Array(0, 0, 0), Array(0, 0, 0), Array(0, 0, 0))</span><br><span class="line"></span><br><span class="line">scala&gt; matrix(1)(1) = 6</span><br><span class="line"></span><br><span class="line">scala&gt; matrix</span><br><span class="line">res1: Array[Array[Int]] = Array(Array(0, 0, 0), Array(0, 6, 0), Array(0, 0, 0), Array(0, 0, 0))</span><br></pre></td></tr></table></figure></p><p>定义一个二维数组，其中每个元素是一个一维数组，其长度不固定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val triangle = new Array[Array[Int]](10)</span><br><span class="line">triangle: Array[Array[Int]] = Array(null, null, null, null, null, null, null, null, null, null)</span><br><span class="line"></span><br><span class="line">scala&gt; for(i &lt;- 0 until triangle.length)</span><br><span class="line">     |     triangle(i) = new Array[Int](i+1)</span><br><span class="line"></span><br><span class="line">scala&gt; triangle</span><br><span class="line">res3: Array[Array[Int]] = Array(Array(0), Array(0, 0), Array(0, 0, 0), Array(0, 0, 0, 0), Array(0, 0, 0, 0, 0), Array(0, 0, 0, 0, 0, 0), Array(0, 0, 0, 0, 0, 0, 0), Array(0, 0, 0, 0, 0, 0, 0, 0), Array(0, 0, 0, 0, 0, 0, 0, 0, 0), Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0))</span><br></pre></td></tr></table></figure></p><p><br><br><strong>zip操作</strong><br>合并两个有序集合成为一个键值对集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val names = Array(&quot;Tom&quot;,&quot;Bob&quot;,&quot;Alice&quot;)</span><br><span class="line">names: Array[String] = Array(Tom, Bob, Alice)</span><br><span class="line"></span><br><span class="line">scala&gt; val ages = Array(21,18,26)</span><br><span class="line">ages: Array[Int] = Array(21, 18, 26)</span><br><span class="line"></span><br><span class="line">scala&gt; val nameAges = names.zip(ages)</span><br><span class="line">nameAges: Array[(String, Int)] = Array((Tom,21), (Bob,18), (Alice,26))</span><br><span class="line"></span><br><span class="line">scala&gt; for((name,age) &lt;- nameAges) println(name + &quot;: &quot; + age)</span><br><span class="line">Tom: 21</span><br><span class="line">Bob: 18</span><br><span class="line">Alice: 26</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;定长数组：使用关键字Array&lt;/strong&gt;&lt;br&gt;在Scala中，Array代表的含义与Java中类似，也是长度不可改变的数组。&lt;br&gt;此外，由于Scala和Java都是运行在JVM上，双方可以互相调用，因此Scala数组的底层实际上是Java数组。&lt;br&gt;例如字符串数组在底层就是Java的String[]，整数数组在底层就是Java的Int[]&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala的异常处理</title>
    <link href="https://www.ggstu.com/2018/08/16/Scala%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://www.ggstu.com/2018/08/16/Scala的异常处理/</id>
    <published>2018-08-16T13:36:00.000Z</published>
    <updated>2018-08-16T13:54:55.841Z</updated>
    
    <content type="html"><![CDATA[<p>Scala的异常处理类似许多其他语言，如Java。</p><p><strong>抛出异常</strong><br>抛出异常，创建一个异常对象，然后使用throw关键字将其抛出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; throw new Exception(&quot;Some Error Happened!&quot;)</span><br><span class="line">java.lang.Exception: Some Error Happened!</span><br><span class="line">  ... 32 elided</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>如果一个函数的返回类型是Nothing，表示在函数执行的过程中产生异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def func() = throw new IllegalArgumentException(&quot;Some Error Happened!&quot;)</span><br><span class="line">func: ()Nothing</span><br></pre></td></tr></table></figure></p><p><br><br><strong>捕获异常</strong><br>使用try…catch…finally来捕获和处理异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; try&#123;</span><br><span class="line">     |    val s = scala.io.Source.fromFile(&quot;C://Users//asus//Desktop/a.txt&quot;).mkString</span><br><span class="line">     | &#125;catch&#123;</span><br><span class="line">     |     case ex:java.io.FileNotFoundException =&gt; &#123;</span><br><span class="line">     |         println(&quot;File Not Found&quot;)</span><br><span class="line">     |     &#125;</span><br><span class="line">     |     case ex:IllegalArgumentException =&gt; &#123;</span><br><span class="line">     |         println(&quot;Illegal ArgumentException&quot;)</span><br><span class="line">     |     &#125;</span><br><span class="line">     |     case _:Exception =&gt; &#123;</span><br><span class="line">     |         println(&quot;Other Exception&quot;)</span><br><span class="line">     |     &#125;</span><br><span class="line">     | &#125;finally&#123;</span><br><span class="line">     |     println(&quot;*****final*****&quot;)</span><br><span class="line">     | &#125;</span><br><span class="line">File Not Found</span><br><span class="line">*****final*****</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scala的异常处理类似许多其他语言，如Java。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抛出异常&lt;/strong&gt;&lt;br&gt;抛出异常，创建一个异常对象，然后使用throw关键字将其抛出&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scala&amp;gt; throw new Exception(&amp;quot;Some Error Happened!&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;java.lang.Exception: Some Error Happened!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ... 32 elided&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala的输入输出</title>
    <link href="https://www.ggstu.com/2018/08/16/Scala%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>https://www.ggstu.com/2018/08/16/Scala的输入输出/</id>
    <published>2018-08-16T13:02:07.000Z</published>
    <updated>2018-08-16T13:33:55.308Z</updated>
    
    <content type="html"><![CDATA[<p><strong>输入</strong><br>readLine函数：从控制台读取用户输入的一行数据，可以带一个参数作为提示字符串<br>读取数字：readInt,readDouble,readByte,readShort,readLong,readFloat<br>读取Boolean类型的数据：readBoolean<br>读取字符：readChar<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.io.StdIn._</span><br><span class="line">import scala.io.StdIn._</span><br><span class="line"></span><br><span class="line">scala&gt; var name = readLine(&quot;Please input your name:&quot;)</span><br><span class="line">Please input your name:name: String = Tom</span><br><span class="line"></span><br><span class="line">scala&gt; name</span><br><span class="line">res0: String = Tom</span><br><span class="line"></span><br><span class="line">scala&gt; var age = readInt()</span><br><span class="line">age: Int = 21</span><br><span class="line"></span><br><span class="line">scala&gt; age</span><br><span class="line">res1: Int = 21</span><br></pre></td></tr></table></figure></p><p><br><br><strong>输出</strong><br>print函数：输出时不会加换行符<br>println函数：输出时会加一个换行符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; print(&quot;Hello World&quot;)</span><br><span class="line">Hello World</span><br><span class="line">scala&gt; println(&quot;Hello World&quot;)</span><br><span class="line">Hello World</span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure></p><p>printf函数：可以进行格式化输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; printf(&quot;Hello,my name is %s.I&apos;m %d years old.\n&quot;,&quot;Tom&quot;,21)</span><br><span class="line">Hello,my name is Tom.I&apos;m 21 years old.</span><br></pre></td></tr></table></figure></p><p><br><br><strong>输入输出例子</strong><br>判断成绩是否及格<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.io.StdIn._</span><br><span class="line">import scala.io.StdIn._</span><br><span class="line"></span><br><span class="line">scala&gt; val name = readLine(&quot;Please input your name:&quot;)</span><br><span class="line">Please input your name:name: String = Tom</span><br><span class="line"></span><br><span class="line">scala&gt; print(&quot;Thanks.Then please input you score:&quot;)</span><br><span class="line">Thanks.Then please input you score:</span><br><span class="line">scala&gt; val score = readDouble()</span><br><span class="line">score: Double = 85.5</span><br><span class="line"></span><br><span class="line">scala&gt; if(score &gt;= 60)&#123;</span><br><span class="line">     |     printf(&quot;Hello,%s,your score is %f,you passed.&quot;,name,score)</span><br><span class="line">     | &#125;else&#123;</span><br><span class="line">     |     printf(&quot;Sorry,%s,your score is %f,you failed.&quot;,name,score)</span><br><span class="line">     | &#125;</span><br><span class="line">Hello,Tom,your score is 85.500000,you passed.</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;输入&lt;/strong&gt;&lt;br&gt;readLine函数：从控制台读取用户输入的一行数据，可以带一个参数作为提示字符串&lt;br&gt;读取数字：readInt,readDouble,readByte,readShort,readLong,readFloat&lt;br&gt;读取Boolean类型的数据：readBoolean&lt;br&gt;读取字符：readChar&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala的Lazy值</title>
    <link href="https://www.ggstu.com/2018/08/16/Scala%E7%9A%84Lazy%E5%80%BC/"/>
    <id>https://www.ggstu.com/2018/08/16/Scala的Lazy值/</id>
    <published>2018-08-16T09:06:58.000Z</published>
    <updated>2018-08-16T02:55:33.430Z</updated>
    
    <content type="html"><![CDATA[<p>在Scala中，使用关键字<strong>lazy</strong>来定义懒惰变量，实现延迟加载(懒加载)。<br>惰性变量只能是不可变变量，即，使用val声明变量，并且只有在调用惰性变量时，才会去实例化这个变量。<br>这种特性对于特别耗时的的计算操作特别有用，比如打开文件进行IO，进行网络IO等。<br>如下所示：当val被声明为lazy时，它的初始化将被推迟，直到首次对它取值。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val x:Int = 5</span><br><span class="line">x: Int = 5</span><br><span class="line"></span><br><span class="line">scala&gt; lazy val y:Int = 6</span><br><span class="line">y: Int = &lt;lazy&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; y</span><br><span class="line">res0: Int = 6</span><br></pre></td></tr></table></figure></p><p><br><br><strong>使用懒加载读取文件</strong><br><strong>读取一个存在的文件</strong><br>我在桌面创建了一个文件a.txt，文件内容为Hello World<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.io.Source._</span><br><span class="line">import scala.io.Source._</span><br><span class="line"></span><br><span class="line">scala&gt; val a = fromFile(&quot;C://Users//asus//Desktop//a.txt&quot;).mkString</span><br><span class="line">a: String = Hello World</span><br><span class="line"></span><br><span class="line">scala&gt; lazy val b = fromFile(&quot;C://Users//asus/Desktop//a.txt&quot;).mkString</span><br><span class="line">b: String = &lt;lazy&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; b</span><br><span class="line">res0: String = Hello World</span><br></pre></td></tr></table></figure></p><p><strong>读取一个不存在的文件</strong><br>不使用懒加载，文件不存在，报异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.io.Source._</span><br><span class="line">import scala.io.Source._</span><br><span class="line"></span><br><span class="line">scala&gt; val c = fromFile(&quot;C://Users//asus//Desktop//aaaaa.txt&quot;).mkString</span><br><span class="line">java.io.FileNotFoundException: C:\Users\asus\Desktop\aaaaa.txt (系统找不到指定的文件。)</span><br><span class="line">  at java.io.FileInputStream.open0(Native Method)</span><br><span class="line">  at java.io.FileInputStream.open(FileInputStream.java:195)</span><br><span class="line">  at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:138)</span><br><span class="line">  at scala.io.Source$.fromFile(Source.scala:91)</span><br><span class="line">  at scala.io.Source$.fromFile(Source.scala:76)</span><br><span class="line">  at scala.io.Source$.fromFile(Source.scala:54)</span><br><span class="line">  ... 32 elided</span><br></pre></td></tr></table></figure></p><p>使用懒加载，即使文件不存在，也不会报错<br>只有第一次调用的时候，才会对其运算，才会出现Exception<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.io.Source._</span><br><span class="line">import scala.io.Source._</span><br><span class="line"></span><br><span class="line">scala&gt; lazy val d = fromFile(&quot;C://Users//asus//Desktop//aaaaa.txt&quot;).mkString</span><br><span class="line">d: String = &lt;lazy&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; d</span><br><span class="line">java.io.FileNotFoundException: C:\Users\asus\Desktop\aaaaa.txt (系统找不到指定的文件。)</span><br><span class="line">  at java.io.FileInputStream.open0(Native Method)</span><br><span class="line">  at java.io.FileInputStream.open(FileInputStream.java:195)</span><br><span class="line">  at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:138)</span><br><span class="line">  at scala.io.Source$.fromFile(Source.scala:91)</span><br><span class="line">  at scala.io.Source$.fromFile(Source.scala:76)</span><br><span class="line">  at scala.io.Source$.fromFile(Source.scala:54)</span><br><span class="line">  at .d$lzycompute(&lt;console&gt;:14)</span><br><span class="line">  at .d(&lt;console&gt;:14)</span><br><span class="line">  ... 32 elided</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Scala中，使用关键字&lt;strong&gt;lazy&lt;/strong&gt;来定义懒惰变量，实现延迟加载(懒加载)。&lt;br&gt;惰性变量只能是不可变变量，即，使用val声明变量，并且只有在调用惰性变量时，才会去实例化这个变量。&lt;br&gt;这种特性对于特别耗时的的计算操作特别有用，比如打开文件进行IO，进行网络IO等。&lt;br&gt;如下所示：当val被声明为lazy时，它的初始化将被推迟，直到首次对它取值。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala中的函数</title>
    <link href="https://www.ggstu.com/2018/08/16/Scala%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"/>
    <id>https://www.ggstu.com/2018/08/16/Scala中的函数/</id>
    <published>2018-08-16T08:23:09.000Z</published>
    <updated>2018-08-15T09:43:56.656Z</updated>
    
    <content type="html"><![CDATA[<p>在Scala中定义函数时，需要定义函数的函数名、参数、函数体。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sayHello(name:String,age:Int) = &#123;</span><br><span class="line">     |     printf(&quot;Hello,my name is %s.I&apos;m %d years old.\n&quot;,name,age)</span><br><span class="line">     | &#125;</span><br><span class="line">sayHello: (name: String, age: Int)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; sayHello(&quot;Tom&quot;,21)</span><br><span class="line">Hello,my name is Tom.I&apos;m 21 years old.</span><br></pre></td></tr></table></figure></p><a id="more"></a><p><br><br>如果调用的函数不需要传递参数，则可以省略括号<br>例如：”Hello World”.distinct<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; &quot;Hello World&quot;.distinct</span><br><span class="line">res0: String = Helo Wrd</span><br></pre></td></tr></table></figure></p><p><br><br>如果函数体中有多行代码，则可以使用代码块的方式包裹多行代码。<br>代码块最后一行的返回值就是整个函数的返回值。<br>Scala定义函数时必须给出所有参数的类型，但是不一定给出函数返回值的类型。<br>只要右侧的函数体中不包含递归的语句，Scala就可以根据右侧的表达式推断出返回类型。<br>例如：下面函数，实现累加功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sum(n:Int) = &#123;</span><br><span class="line">     |     var res = 0</span><br><span class="line">     |     for(i &lt;- 1 to n) res += i</span><br><span class="line">     |     res</span><br><span class="line">     | &#125;</span><br><span class="line">sum: (n: Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; sum(10)</span><br><span class="line">res1: Int = 55</span><br></pre></td></tr></table></figure></p><p><br><br><strong>递归函数</strong><br>如果在函数体内递归调用函数自身，则必须手动给出函数的返回类型<br>例如：实现斐波那契数列：1,1,2,3,5,8,13,21,34,55,……<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def fab(n:Int):Int = &#123;</span><br><span class="line">     |     if(n &lt;= 2) 1</span><br><span class="line">     |     else fab(n-1) + fab(n-2)</span><br><span class="line">     | &#125;</span><br><span class="line">fab: (n: Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; fab(8)</span><br><span class="line">res0: Int = 21</span><br></pre></td></tr></table></figure></p><p><br><br><strong>Scala函数的参数</strong><br>Scala中有两种函数参数的求值策略：<br>1、Call By Value:对函数实参求值，且仅求一次<br>2、Call By Name:函数实参每次在函数体内被用到时都会求值<br>例如：call by value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def test1(x:Int,y:Int):Int = x + x</span><br><span class="line">test1: (x: Int, y: Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; test1(1+2,8)</span><br><span class="line">res0: Int = 6</span><br></pre></td></tr></table></figure></p><p>调用过程为：<br>test1(1+2,8)<br>1、test1(3,8)<br>2、3+3<br>3、6<br><br><br>例如：call by name<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def test2(x: =&gt; Int,y: =&gt; Int):Int = x + x</span><br><span class="line">test2: (x: =&gt; Int, y: =&gt; Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; test2(1+2,8)</span><br><span class="line">res1: Int = 6</span><br></pre></td></tr></table></figure></p><p>调用过程为：<br>1、(1+2)+(1+2)<br>2、3 + (1+2)<br>3、3 + 3<br>4、6<br><br><br><strong>默认参数</strong><br>Scala中，调用某些函数时，若不希望给出参数的具体值，而使用参数自身默认的值，就可以在定义函数时使用默认参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sayHello(name:String = &quot;Tom&quot;) = &#123;</span><br><span class="line">     |     printf(&quot;Hello,my name is %s.&quot;,name)</span><br><span class="line">     | &#125;</span><br><span class="line">sayHello: (name: String)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; sayHello()</span><br><span class="line">Hello,my name is Tom.</span><br><span class="line">scala&gt; sayHello(&quot;Bob&quot;)</span><br><span class="line">Hello,my name is Bob.</span><br></pre></td></tr></table></figure></p><p><strong>带名参数</strong><br>在调用函数时，也可以不按照函数定义的参数顺序来传递参数，而是使用带名参数的方式来传递。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sayHello(name:String,age:Int) = &#123;</span><br><span class="line">     |     printf(&quot;Hello,my name is %s.I&apos;m %d years old.&quot;,name,age)</span><br><span class="line">     | &#125;</span><br><span class="line">sayHello: (name: String, age: Int)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; sayHello(age=21,name=&quot;Tom&quot;)</span><br><span class="line">Hello,my name is Tom.I&apos;m 21 years old.</span><br></pre></td></tr></table></figure></p><p><strong>变长参数</strong><br>Scala中，若需要将函数定义为参数个数可变的形式，可以使用变长参数定义函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sum(nums:Int*) = &#123;</span><br><span class="line">     |     var res = 0</span><br><span class="line">     |     for(num &lt;- nums) res += num</span><br><span class="line">     |     res</span><br><span class="line">     | &#125;</span><br><span class="line">sum: (nums: Int*)Int</span><br><span class="line"></span><br><span class="line">scala&gt; sum(1,2,3)</span><br><span class="line">res0: Int = 6</span><br><span class="line"></span><br><span class="line">scala&gt; sum(1,2,3,4,5)</span><br><span class="line">res1: Int = 15</span><br></pre></td></tr></table></figure></p><p><strong>使用序列调用变长参数</strong><br>不能将一个已有的序列直接调用变长参数函数，比如val s = sum(1 to 5)<br>需要使用Scala特殊的语法将参数定义为序列，让Scala解释器能够识别。<br>如：val s = sum(1 to 5: _*)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; sum(1 to 5)</span><br><span class="line">&lt;console&gt;:13: error: type mismatch;</span><br><span class="line"> found   : scala.collection.immutable.Range.Inclusive</span><br><span class="line"> required: Int</span><br><span class="line">       sum(1 to 5)</span><br><span class="line">             ^</span><br><span class="line"></span><br><span class="line">scala&gt; sum(1 to 5: _*)</span><br><span class="line">res3: Int = 15</span><br></pre></td></tr></table></figure></p><p>变长参数例子：使用递归函数实现累加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sum(nums:Int*):Int = &#123;</span><br><span class="line">     |     if(nums.length == 0) 0</span><br><span class="line">     |     else nums.head + sum(nums.tail: _*)</span><br><span class="line">     | &#125;</span><br><span class="line">sum: (nums: Int*)Int</span><br><span class="line"></span><br><span class="line">scala&gt; sum(1,2,3)</span><br><span class="line">res0: Int = 6</span><br><span class="line"></span><br><span class="line">scala&gt; sum(1,2,3,4,5)</span><br><span class="line">res1: Int = 15</span><br></pre></td></tr></table></figure></p><p><br><br><strong>Scala的过程</strong><br>在Scala中，定义函数时，如果函数体直接包裹在了花括号里面，并且没有使用=连接，则函数的返回值类型就是Unit。<br>这样的函数就被称之为过程。过程通常用于不需要返回值的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sayHello(name:String)&#123;print(&quot;Hello,my name is &quot;) + name&#125;</span><br><span class="line">sayHello: (name: String)Unit</span><br></pre></td></tr></table></figure></p><p>过程还有一种写法，就是将函数的返回值类型定义为Unit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sayHello(name:String):Unit = &quot;Hello,my name is&quot; + name</span><br><span class="line">sayHello: (name: String)Unit</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Scala中定义函数时，需要定义函数的函数名、参数、函数体。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scala&amp;gt; def sayHello(name:String,age:Int) = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     |     printf(&amp;quot;Hello,my name is %s.I&amp;apos;m %d years old.\n&amp;quot;,name,age)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     | &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayHello: (name: String, age: Int)Unit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scala&amp;gt; sayHello(&amp;quot;Tom&amp;quot;,21)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Hello,my name is Tom.I&amp;apos;m 21 years old.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala的循环</title>
    <link href="https://www.ggstu.com/2018/08/16/Scala%E7%9A%84%E5%BE%AA%E7%8E%AF/"/>
    <id>https://www.ggstu.com/2018/08/16/Scala的循环/</id>
    <published>2018-08-16T01:41:00.000Z</published>
    <updated>2018-08-15T02:27:18.266Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Scala拥有与Java和C++相同的while和do…while循环</strong><br>使用while循环：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var n = 0</span><br><span class="line">n: Int = 0</span><br><span class="line"></span><br><span class="line">scala&gt; while(n &lt; 10)&#123;</span><br><span class="line">     | print(n + &quot; &quot;)</span><br><span class="line">     | n += 1</span><br><span class="line">     | &#125;</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>使用do…while循环：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var n = 0</span><br><span class="line">n: Int = 0</span><br><span class="line"></span><br><span class="line">scala&gt; do&#123;</span><br><span class="line">     | print(n + &quot; &quot;)</span><br><span class="line">     | n += 1</span><br><span class="line">     | &#125;while(n &lt; 10)</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure></p><p><br><br><strong>Scala中可以使用for和foreach进行迭代</strong><br>使用for语句，打印1到10<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var n = 10;for(i &lt;- 1 to n)print(i + &quot; &quot;)</span><br><span class="line">1 2 3 4 5 6 7 8 9 10 n: Int = 10</span><br></pre></td></tr></table></figure></p><p>把to改成until，表示不达到上界限，打印1到9<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var n = 10;for(i &lt;- 1 until n)print(i + &quot; &quot;)</span><br><span class="line">1 2 3 4 5 6 7 8 9 n: Int = 10</span><br></pre></td></tr></table></figure></p><p>for语句也可以对字符串进行遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; for(c &lt;- &quot;Hello World&quot;)print(c)</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure></p><p><br><br><strong>多重for循环</strong><br>例如：九九乘法表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; for(i &lt;- 1 to 9;j &lt;- 1 to 9)&#123;</span><br><span class="line">     | if(j == 9)&#123;</span><br><span class="line">     | println(i*j)</span><br><span class="line">     | &#125;else&#123;</span><br><span class="line">     | print(i*j + &quot; &quot;)</span><br><span class="line">     | &#125;</span><br><span class="line">     | &#125;</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">2 4 6 8 10 12 14 16 18</span><br><span class="line">3 6 9 12 15 18 21 24 27</span><br><span class="line">4 8 12 16 20 24 28 32 36</span><br><span class="line">5 10 15 20 25 30 35 40 45</span><br><span class="line">6 12 18 24 30 36 42 48 54</span><br><span class="line">7 14 21 28 35 42 49 56 63</span><br><span class="line">8 16 24 32 40 48 56 64 72</span><br><span class="line">9 18 27 36 45 54 63 72 81</span><br></pre></td></tr></table></figure></p><p><br><br><strong>for循环的if守卫</strong><br>例如：打印1到20中的所有偶数<br>方式一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; for(i &lt;- 1 to 20 if i%2 == 0)print(i + &quot; &quot;)</span><br><span class="line">2 4 6 8 10 12 14 16 18 20</span><br></pre></td></tr></table></figure></p><p>方式二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; for&#123;</span><br><span class="line">     | i &lt;- 1 to 20</span><br><span class="line">     | if(i%2 == 0)</span><br><span class="line">     | &#125;print(i + &quot; &quot;)</span><br><span class="line">2 4 6 8 10 12 14 16 18 20</span><br></pre></td></tr></table></figure></p><p><br><br><strong>在for循环中，还可以使用yield关键字来产生一个新的集合</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; for(i &lt;- 1 to 10)yield i</span><br><span class="line">res0: scala.collection.immutable.IndexedSeq[Int] = Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</span><br></pre></td></tr></table></figure></p><p><br><br><strong>使用foreach进行迭代</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val list = List(&quot;Tom&quot;,&quot;Bob&quot;,&quot;Alice&quot;)</span><br><span class="line">list: List[String] = List(Tom, Bob, Alice)</span><br><span class="line"></span><br><span class="line">scala&gt; list.foreach(println)</span><br><span class="line">Tom</span><br><span class="line">Bob</span><br><span class="line">Alice</span><br></pre></td></tr></table></figure></p><p><br><br><strong>跳出循环语句</strong><br>scala没有提供类似于java的break语句。<br>但是可以使用boolean类型变量、return或者Breaks的break函数来替代使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.util.control.Breaks._</span><br><span class="line">import scala.util.control.Breaks._</span><br><span class="line"></span><br><span class="line">scala&gt; breakable&#123;</span><br><span class="line">     | var n = 0</span><br><span class="line">     | for(c &lt;- &quot;Hello World&quot;)&#123;</span><br><span class="line">     | if(n == 5) break;</span><br><span class="line">     | print(c)</span><br><span class="line">     | n += 1</span><br><span class="line">     | &#125;</span><br><span class="line">     | &#125;</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Scala拥有与Java和C++相同的while和do…while循环&lt;/strong&gt;&lt;br&gt;使用while循环：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scala&amp;gt; var n = 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n: Int = 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scala&amp;gt; while(n &amp;lt; 10)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     | print(n + &amp;quot; &amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     | n += 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     | &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0 1 2 3 4 5 6 7 8 9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala的条件表达式</title>
    <link href="https://www.ggstu.com/2018/08/16/Scala%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://www.ggstu.com/2018/08/16/Scala的条件表达式/</id>
    <published>2018-08-16T01:05:27.000Z</published>
    <updated>2018-08-15T01:35:46.120Z</updated>
    
    <content type="html"><![CDATA[<p>Scala的if/else语法结构和Java和C++一样。<br>不过，在Scala中，if/else表达式是有值的，这个值就是if或者else中最后一行语句返回的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val age = 21</span><br><span class="line">age: Int = 21</span><br><span class="line"></span><br><span class="line">scala&gt; if(age &gt; 18) 1 else 0</span><br><span class="line">res0: Int = 1</span><br></pre></td></tr></table></figure></p><a id="more"></a><p><br><br>可以将if表达式赋予一个变量<br>方式一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val age = 21</span><br><span class="line">age: Int = 21</span><br><span class="line"></span><br><span class="line">scala&gt; val isAdult = if(age &gt; 18) 1 else 0</span><br><span class="line">isAdult: Int = 1</span><br></pre></td></tr></table></figure></p><p>方式二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val age = 21</span><br><span class="line">age: Int = 21</span><br><span class="line"></span><br><span class="line">scala&gt; var isAdult = -1</span><br><span class="line">isAdult: Int = -1</span><br><span class="line"></span><br><span class="line">scala&gt; if(age &gt; 18) isAdult = 1 else isAdult = 0</span><br><span class="line"></span><br><span class="line">scala&gt; isAdult</span><br><span class="line">res1: Int = 1</span><br></pre></td></tr></table></figure></p><p><br><br>由于if/else表达式是有值的，而if和else子句的值类型可能不同，此时Scala会自动进行判断，取两个类型的公共父类型。<br>例如：if(age &gt; 18) 1 else 0，表达式的类型是Int，因为1和0都是Int。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val age = 21</span><br><span class="line">age: Int = 21</span><br><span class="line"></span><br><span class="line">scala&gt; if(age &gt; 18) 1 else 0</span><br><span class="line">res0: Int = 1</span><br></pre></td></tr></table></figure></p><p>例如：if(age &gt; 18) “adult” else 0，此时if和else的值分别是String和Int，则表达式的值是Any，Any是String和Int的公共父类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val age = 21</span><br><span class="line">age: Int = 21</span><br><span class="line"></span><br><span class="line">scala&gt; if(age &gt; 18) &quot;adult&quot; else 0</span><br><span class="line">res0: Any = adult</span><br></pre></td></tr></table></figure></p><p><br><br>如果if后面没有跟else，则默认else的值是Unit，也用()表示，相当于java中的void。<br>例如：val age = 12;if(age &gt; 18) “adult”。此时就相当于if(age &gt; 18) “adult” else ()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val age = 12</span><br><span class="line">age: Int = 12</span><br><span class="line"></span><br><span class="line">scala&gt; if(age &gt; 18) &quot;adult&quot;</span><br><span class="line">res0: Any = ()</span><br></pre></td></tr></table></figure></p><p><br><br>将if语句放在多行中，默认情况下，REPL只能解释一行语句，但是if表达式通常需要放在多行。<br>可以使用{}的方式，比如以下方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val age = 21</span><br><span class="line">age: Int = 21</span><br><span class="line"></span><br><span class="line">scala&gt; if(age &gt; 18)&#123;&quot;adult&quot;</span><br><span class="line">     | &#125;else if(age &gt; 12)&#123;</span><br><span class="line">     | &quot;teenager&quot;&#125;else</span><br><span class="line">     | &quot;children&quot;</span><br><span class="line">res0: String = adult</span><br></pre></td></tr></table></figure></p><p>或者使用:paste和ctrl+D的方式   :paste进入，ctrl+D退出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">if(age &gt; 18)</span><br><span class="line">&quot;adult&quot; else if(age &gt; 12)</span><br><span class="line">&quot;teenager&quot; else &quot;children&quot;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">res1: String = adult</span><br></pre></td></tr></table></figure></p><p><br><br>默认情况下，Scala不需要分号作为语句的终结，默认将每一行作为一个语句。<br>若一行有多条语句的情况下，要使用分号作为语句的终结。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var a,b,c = 0;if(a &lt; 1) &#123;b = b+1; c = c+1&#125;</span><br><span class="line">a: Int = 0</span><br><span class="line">b: Int = 1</span><br><span class="line">c: Int = 1</span><br></pre></td></tr></table></figure></p><p>通常对于多条语句，使用花括号的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var a,b,c = 0</span><br><span class="line">a: Int = 0</span><br><span class="line">b: Int = 0</span><br><span class="line">c: Int = 0</span><br><span class="line"></span><br><span class="line">scala&gt; if(a &lt; 1)&#123;</span><br><span class="line">     | b = b+1</span><br><span class="line">     | c = c+1</span><br><span class="line">     | &#125;</span><br><span class="line">scala&gt; a</span><br><span class="line">res1: Int = 0</span><br><span class="line"></span><br><span class="line">scala&gt; b</span><br><span class="line">res2: Int = 1</span><br><span class="line"></span><br><span class="line">scala&gt; c</span><br><span class="line">res3: Int = 1</span><br></pre></td></tr></table></figure></p><p>块表达式就是指{}中的值，其中可以包含多条语句，最后一个语句的值就是块表达式的返回值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var a,b,c = 0</span><br><span class="line">a: Int = 0</span><br><span class="line">b: Int = 0</span><br><span class="line">c: Int = 0</span><br><span class="line"></span><br><span class="line">scala&gt; var d = if(a &lt; 1)&#123;b = b+1; c+2&#125;</span><br><span class="line">d: AnyVal = 2</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scala的if/else语法结构和Java和C++一样。&lt;br&gt;不过，在Scala中，if/else表达式是有值的，这个值就是if或者else中最后一行语句返回的值。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scala&amp;gt; val age = 21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;age: Int = 21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scala&amp;gt; if(age &amp;gt; 18) 1 else 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;res0: Int = 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala变量的声明和使用</title>
    <link href="https://www.ggstu.com/2018/08/15/Scala%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.ggstu.com/2018/08/15/Scala变量的声明和使用/</id>
    <published>2018-08-15T14:26:50.000Z</published>
    <updated>2018-08-15T01:33:36.557Z</updated>
    
    <content type="html"><![CDATA[<p><strong>变量：</strong>在程序运行过程中其值可能发生改变的量叫做变量。如：年龄。<br><strong>常量：</strong>在程序运行过程中其值不会发生变化的量叫做常量。如：数字1。<br><br>在Scala中，使用关键词”var”声明变量，使用关键词”val”声明常量。<br><a id="more"></a><br><strong>声明var变量：</strong><br>如果要声明的值可以改变，可以使用var变量<br>例如:var num = 1, num = 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var num = 1</span><br><span class="line">num: Int = 1</span><br><span class="line"></span><br><span class="line">scala&gt; num = 2</span><br><span class="line">num: Int = 2</span><br></pre></td></tr></table></figure></p><p><strong>声明val变量：</strong><br>如果要声明的值不可以改变，可以使用val变量，定义的值实际上是一个常量。<br>例如：val num = 1，后续这些常量可以继续使用，例如：2*num<br>但是常量声明后，是无法改变它的值的，例如：num = 10<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val num = 1</span><br><span class="line">num: Int = 1</span><br><span class="line"></span><br><span class="line">scala&gt; 2 * num</span><br><span class="line">res0: Int = 2</span><br><span class="line"></span><br><span class="line">scala&gt; num = 10</span><br><span class="line">&lt;console&gt;:12: error: reassignment to val</span><br><span class="line">       num = 10</span><br></pre></td></tr></table></figure></p><p>在scala程序中，通常建议使用val，也就是常量，因为比如在spark的大型复杂系统中，需要大量的<br>网络传输数据，如果使用var，数值可能会被错误的更改。  </p><p><font color="#f00">注意：</font>无论是是val变量还是var变量，可以手动指定一个变量的类型，如果不显式指定变量的类型，Scala会进行自动的类型推断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val name1:String = null</span><br><span class="line">name1: String = null</span><br><span class="line"></span><br><span class="line">scala&gt; val name2:Any = &quot;Tom&quot;</span><br><span class="line">name2: Any = Tom</span><br><span class="line"></span><br><span class="line">scala&gt; val name3 = &quot;Tom&quot;</span><br><span class="line">name3: String = Tom</span><br></pre></td></tr></table></figure></p><p><strong>声明多个变量：</strong><br>可以将多个变量放在一起进行声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val num1,num2,num3 = 10</span><br><span class="line">num1: Int = 10</span><br><span class="line">num2: Int = 10</span><br><span class="line">num3: Int = 10</span><br></pre></td></tr></table></figure></p><p>如果方法返回值是元祖，可以使用var或val来声明一个元祖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val person = (&quot;Tom&quot;,21)</span><br><span class="line">person: (String, Int) = (Tom,21)</span><br></pre></td></tr></table></figure></p><p>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;变量：&lt;/strong&gt;在程序运行过程中其值可能发生改变的量叫做变量。如：年龄。&lt;br&gt;&lt;strong&gt;常量：&lt;/strong&gt;在程序运行过程中其值不会发生变化的量叫做常量。如：数字1。&lt;br&gt;&lt;br&gt;在Scala中，使用关键词”var”声明变量，使用关键词”val”声明常量。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala常用的数据类型和操作符</title>
    <link href="https://www.ggstu.com/2018/08/15/Scala%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>https://www.ggstu.com/2018/08/15/Scala常用的数据类型和操作符/</id>
    <published>2018-08-15T13:28:53.000Z</published>
    <updated>2018-08-15T01:33:17.119Z</updated>
    
    <content type="html"><![CDATA[<p><strong>常用的数据类型：</strong><br>（1）数值类型：Byte，Short，Int，Long，Float，Double</p><ul><li>Byte：8位有符号整数，从-128到127</li><li>Short：16位有符号整数，从-32768到32767</li><li>Int：32位有符号整数</li><li>Long： 64位有符号整数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a:Byte = 10</span><br><span class="line">a: Byte = 10</span><br><span class="line"></span><br><span class="line">scala&gt; a + 10</span><br><span class="line">res0: Int = 20</span><br><span class="line"></span><br><span class="line">scala&gt; val b:Short = 20</span><br><span class="line">b: Short = 20</span><br><span class="line"></span><br><span class="line">scala&gt; a + b</span><br><span class="line">res1: Int = 30</span><br></pre></td></tr></table></figure></li></ul><p>（2）字符类型和字符串类型：Char和String<br>对于字符串，在Scala中可以进行插值操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val str = &quot;World&quot;</span><br><span class="line">str: String = World</span><br><span class="line"></span><br><span class="line">scala&gt; &quot;Hello $&#123;str&#125;&quot;</span><br><span class="line">res0: String = Hello $&#123;str&#125;</span><br><span class="line"></span><br><span class="line">scala&gt; s&quot;Hello $&#123;str&#125;&quot;</span><br><span class="line">res1: String = Hello World</span><br></pre></td></tr></table></figure></p><p><font color="#f00">注意：</font>前面有个s，相当于执行：”Hello “ + str<br>（3）Unit类型：相当于Java中的void类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val f = ()</span><br><span class="line">f: Unit = ()</span><br><span class="line"></span><br><span class="line">scala&gt; val f = &#123;&#125;</span><br><span class="line">f: Unit = ()</span><br></pre></td></tr></table></figure></p><p>（4）Nothing类型：Nothing类型在Scala的类层级的最低端，它是任何其他类型的子类型。<br>一般表示在执行过程中，产生了Exception。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def myfunction = throw new Exception(&quot;Error&quot;)</span><br><span class="line">myfunction: Nothing</span><br></pre></td></tr></table></figure></p><p>（5）Any类型：是所有其他类型的父类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val num:Any = 1</span><br><span class="line">num: Any = 1</span><br><span class="line"></span><br><span class="line">scala&gt; val name:Any = &quot;Tom&quot;</span><br><span class="line">name: Any = Tom</span><br></pre></td></tr></table></figure></p><p><font color="#f00">注意：</font>在Scala中，定义变量可以不指定数据类型，因为Scala会自动的进行类型推断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val num = 1</span><br><span class="line">num: Int = 1</span><br><span class="line"></span><br><span class="line">scala&gt; val name = &quot;Tom&quot;</span><br><span class="line">name: String = Tom</span><br></pre></td></tr></table></figure></p><p><strong>基本操作符：</strong><br>scala的算术操作符与java的算术操作符没有什么区别，比如+、-、*、/、%等，以及&amp;、|、^、&gt;&gt;、&lt;&lt;等。<br>但是，在scala中，这些操作符其实是数据类型的函数。<br>例如：1 + 1，可以写成1.+(1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; 1 + 1</span><br><span class="line">res0: Int = 2</span><br><span class="line"></span><br><span class="line">scala&gt; 1.+(1)</span><br><span class="line">res1: Int = 2</span><br></pre></td></tr></table></figure></p><p>例如：1.to(10)，可以写成1 to 10<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; 1.to(10)</span><br><span class="line">res0: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</span><br><span class="line"></span><br><span class="line">scala&gt; 1 to 10</span><br><span class="line">res1: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</span><br></pre></td></tr></table></figure></p><p>scala中没有提供++、–操作符，只能使用+=和-=。<br>例如：var count = 1，count++是错误的，必须写成count+=1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var count = 1</span><br><span class="line">count: Int = 1</span><br><span class="line"></span><br><span class="line">scala&gt; count += 1</span><br><span class="line"></span><br><span class="line">scala&gt; count</span><br><span class="line">res0: Int = 2</span><br><span class="line"></span><br><span class="line">scala&gt; count ++</span><br><span class="line">&lt;console&gt;:13: error: value ++ is not a member of Int</span><br><span class="line">       count ++</span><br><span class="line">             ^</span><br></pre></td></tr></table></figure></p><p>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;常用的数据类型：&lt;/strong&gt;&lt;br&gt;（1）数值类型：Byte，Short，Int，Long，Float，Double&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Byte：8位有符号整数，从-128到127&lt;/li&gt;
&lt;li&gt;Short：16位有符号整数，从-32768
      
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala解释器的使用</title>
    <link href="https://www.ggstu.com/2018/08/15/Scala%E8%A7%A3%E9%87%8A%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.ggstu.com/2018/08/15/Scala解释器的使用/</id>
    <published>2018-08-15T12:52:08.000Z</published>
    <updated>2018-08-15T01:33:05.994Z</updated>
    
    <content type="html"><![CDATA[<p>Scala解释器也被称为<strong>REPL</strong>。REPL：Read(取值)-&gt;Evaluation(求值)-&gt;Pring(打印)-&gt;Loop(循环)。会快速编译scala代码为字节码，然后交给JVM来执行。<br>运行cmd，输入scala可以进入scala的解释器<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\asus&gt;scala</span><br><span class="line">Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_131).</span><br><span class="line">Type in expressions for evaluation. Or try :help.</span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure></p><p>在scala&gt;命令行内，键入scala代码，解释器会直接返回结果。如果没有指定变量来存放这个值，<br>那么默认的名称为res，而且会显示结果的数据类型，比如int、Double、String等等，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; 1 + 1</span><br><span class="line">res0: Int = 2</span><br><span class="line"></span><br><span class="line">scala&gt; 1.0 + 2.0</span><br><span class="line">res1: Double = 3.0</span><br><span class="line"></span><br><span class="line">scala&gt; &quot;Hello&quot; + &quot; World&quot;</span><br><span class="line">res2: String = HelloWorld</span><br></pre></td></tr></table></figure></p><p>在后面可以继续使用res这个变量存放的值，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; 1 + 1</span><br><span class="line">res0: Int = 2</span><br><span class="line"></span><br><span class="line">scala&gt; 2.0 * res0</span><br><span class="line">res1: Double = 4.0</span><br><span class="line"></span><br><span class="line">scala&gt; &quot;Hello &quot; + res0</span><br><span class="line">res2: String = Hello 2</span><br></pre></td></tr></table></figure></p><p>在scala&gt;命令行内，可以使用Tab键进行自动补全<br>例如：输入res0.to，敲击Tab键，解释器会显示出以下选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; &quot;Hello&quot;</span><br><span class="line">res0: String = Hello</span><br><span class="line"></span><br><span class="line">scala&gt; res0.to</span><br><span class="line">to          toCharArray    toIterable    toMap      toString</span><br><span class="line">toArray     toDouble       toIterator    toSeq      toTraversable</span><br><span class="line">toBoolean   toFloat        toList        toSet      toUpperCase</span><br><span class="line">toBuffer    toIndexedSeq   toLong        toShort    toVector</span><br><span class="line">toByte      toInt          toLowerCase   toStream</span><br></pre></td></tr></table></figure></p><p>因为此时无法判定你需要补全的是哪一个，因此会提供给你所有的选项<br>例如：输入res0.toU，敲击Tab键，直接会给你补全为res0.toUpperCase<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; res0.toUpperCase</span><br><span class="line">res1: String = HELLO</span><br></pre></td></tr></table></figure></p><p><font color="#f00">注意：</font>在Scala中任何数据都是对象，例如：整数1也是对象，所以有其对应的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; 1</span><br><span class="line">res0: Int = 1</span><br><span class="line"></span><br><span class="line">scala&gt; 1.to</span><br><span class="line">to               toChar      toFloat       toLong          toShort</span><br><span class="line">toBinaryString   toDegrees   toHexString   toOctalString   toString</span><br><span class="line">toByte           toDouble    toInt         toRadians</span><br></pre></td></tr></table></figure></p><p>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scala解释器也被称为&lt;strong&gt;REPL&lt;/strong&gt;。REPL：Read(取值)-&amp;gt;Evaluation(求值)-&amp;gt;Pring(打印)-&amp;gt;Loop(循环)。会快速编译scala代码为字节码，然后交给JVM来执行。&lt;br&gt;运行cmd，输入scala可以进入scala的解释器&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala在Windows上的安装及环境配置</title>
    <link href="https://www.ggstu.com/2018/08/15/Scala%E5%9C%A8Windows%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.ggstu.com/2018/08/15/Scala在Windows上的安装及环境配置/</id>
    <published>2018-08-15T11:50:02.000Z</published>
    <updated>2018-08-15T01:32:57.938Z</updated>
    
    <content type="html"><![CDATA[<p>Scala是一种多范式的编程语言，其设计的初衷是要集成面向对象编程和函数式编程的各种特性。<br>Scala运行于Java平台（Java虚拟机），并兼容现有的Java程序。<br>由于Scala运行在JVM上，所以应该首先配置好JDK环境，点击如下链接查看如何在Windows上配置JDK<br><a href="https://www.ggstu.com/2018/08/14/Windows%E4%B8%8B%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AEJDK1-8/">在Windows上配置JDK1.8</a><br><a id="more"></a><br><strong>接着开始配置Scala环境：</strong>  </p><p><strong>1、官网下载Scala</strong><br><a href="https://www.scala-lang.org/download/" target="_blank" rel="noopener">https://www.scala-lang.org/download/</a><br>找到如下图所示的zip包进行下载<br><img src="http://pd8lpasbc.bkt.clouddn.com/4-1.png" alt=""><br><strong>2、解压缩</strong><br>将下载好的zip解压，我将它解压到了C盘上  </p><p><strong>3、配置环境变量</strong><br>右击我的电脑-&gt;属性<br><img src="http://pd8lpasbc.bkt.clouddn.com/4-2.png" alt=""><br>选择高级系统设置-&gt;环境变量<br><img src="http://pd8lpasbc.bkt.clouddn.com/4-3.png" width="60%" height="60%"><br>新建系统变量：<br>变量名（N）：SCALA_HOME<br>变量值（V）：C:\scala-2.12.6<br><img src="http://pd8lpasbc.bkt.clouddn.com/4-4.png" width="60%" height="60%"><br>添加修改系统变量：<br>变量名（N）：Path<br>变量值（V）：;%SCALA_HOME%\bin;<br><img src="http://pd8lpasbc.bkt.clouddn.com/4-5.png" width="60%" height="60%"><br><strong>4、验证是否成功</strong><br>运行cmd，输入命令scala -version，出现如下内容，说明安装配置成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\asus&gt;scala -version</span><br><span class="line">Scala code runner version 2.12.6 -- Copyright 2002-2018, LAMP/EPFL and Lightbend, Inc.</span><br></pre></td></tr></table></figure></p><p>输入scala可以进入scala的命令行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\asus&gt;scala</span><br><span class="line">Welcome to Scala 2.12.6 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_181)</span><br><span class="line">Type in expressions for evaluation. Or try :help.</span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure></p><p>如果安装过程中遇到什么问题，欢迎评论。<br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scala是一种多范式的编程语言，其设计的初衷是要集成面向对象编程和函数式编程的各种特性。&lt;br&gt;Scala运行于Java平台（Java虚拟机），并兼容现有的Java程序。&lt;br&gt;由于Scala运行在JVM上，所以应该首先配置好JDK环境，点击如下链接查看如何在Windows上配置JDK&lt;br&gt;&lt;a href=&quot;https://www.ggstu.com/2018/08/14/Windows%E4%B8%8B%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AEJDK1-8/&quot;&gt;在Windows上配置JDK1.8&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>想不到不去健身房的理由</title>
    <link href="https://www.ggstu.com/2018/08/14/%E6%83%B3%E4%B8%8D%E5%88%B0%E4%B8%8D%E5%8E%BB%E5%81%A5%E8%BA%AB%E6%88%BF%E7%9A%84%E7%90%86%E7%94%B1/"/>
    <id>https://www.ggstu.com/2018/08/14/想不到不去健身房的理由/</id>
    <published>2018-08-14T15:16:59.000Z</published>
    <updated>2018-08-14T12:13:56.333Z</updated>
    
    <content type="html"><![CDATA[<p>下图圈出的位置—-健身房，一个一年365天我能去近300天的地方。<br>我确实想不到不去健身房的理由，感觉不去健身房动动，反而更累。<br>这就是习惯了吧，对我来说，哑铃、杠铃更像是玩具。<br>我现在更多的是以养生的心态来健身，所以不管练多练少，健身房还是每天都要去的。<br><a id="more"></a><br><img src="http://pd8lpasbc.bkt.clouddn.com/%E5%81%A5%E8%BA%AB1.jpg" width="60%" height="60%"><br>No pains,no gains.<br><img src="http://pd8lpasbc.bkt.clouddn.com/%E5%81%A5%E8%BA%AB2.jpg" width="60%" height="60%">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下图圈出的位置—-健身房，一个一年365天我能去近300天的地方。&lt;br&gt;我确实想不到不去健身房的理由，感觉不去健身房动动，反而更累。&lt;br&gt;这就是习惯了吧，对我来说，哑铃、杠铃更像是玩具。&lt;br&gt;我现在更多的是以养生的心态来健身，所以不管练多练少，健身房还是每天都要去的。&lt;br&gt;
    
    </summary>
    
      <category term="随便说说" scheme="https://www.ggstu.com/categories/%E9%9A%8F%E4%BE%BF%E8%AF%B4%E8%AF%B4/"/>
    
    
      <category term="健身" scheme="https://www.ggstu.com/tags/%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
</feed>
