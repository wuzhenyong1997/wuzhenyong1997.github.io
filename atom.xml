<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GGSTU</title>
  
  <subtitle>Good Good Study</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.ggstu.com/"/>
  <updated>2018-08-25T11:18:37.947Z</updated>
  <id>https://www.ggstu.com/</id>
  
  <author>
    <name>Wu Zhenyong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Scala泛型类型的视图界定和上下文界定</title>
    <link href="https://www.ggstu.com/2018/08/25/Scala%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A7%86%E5%9B%BE%E7%95%8C%E5%AE%9A%E5%92%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%95%8C%E5%AE%9A/"/>
    <id>https://www.ggstu.com/2018/08/25/Scala泛型类型的视图界定和上下文界定/</id>
    <published>2018-08-25T08:34:29.000Z</published>
    <updated>2018-08-25T11:18:37.947Z</updated>
    
    <content type="html"><![CDATA[<p><strong>视图界定View Bounds</strong><br>视图界定比上界&nbsp;&lt;:&nbsp;适用的范围更广，除了所有的子类型，还允许隐式转换过去的类型。用&nbsp;&lt;%&nbsp;表示。<br>例如：拼接字符串。这里由于T的上界是String，当参数传入整数100和200时，就会出现类型不匹配。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def addString[T&lt;:String](x:T,y:T) = println(x+&quot; &quot;+y)</span><br><span class="line">addString: [T &lt;: String](x: T, y: T)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; addString(&quot;Hello&quot;,&quot;World&quot;)</span><br><span class="line">Hello World</span><br><span class="line"></span><br><span class="line">scala&gt; addString(100,200)</span><br><span class="line">&lt;console&gt;:13: error: inferred type arguments [Int] do not conform to method addString&apos;s type parameter bounds [T &lt;: String]</span><br><span class="line">       addString(100,200)</span><br><span class="line">       ^</span><br><span class="line">&lt;console&gt;:13: error: type mismatch;</span><br><span class="line"> found   : Int(100)</span><br><span class="line"> required: T</span><br><span class="line">       addString(100,200)</span><br><span class="line">                 ^</span><br><span class="line">&lt;console&gt;:13: error: type mismatch;</span><br><span class="line"> found   : Int(200)</span><br><span class="line"> required: T</span><br><span class="line">       addString(100,200)</span><br><span class="line">                     ^</span><br></pre></td></tr></table></figure></p><p>但是整型数字是可以转换成字符串的，所以可以使用视图界定让addString方法接收更广泛的数据类型。<br>即：1、字符串及其子类；2、可以转换成字符串的类型。</p><p><font color="#f00">注意：</font>使用的是&nbsp;<font color="#f00">&lt;%</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def addString[T&lt;%String](x:T,y:T) = println(x+&quot; &quot;+y)</span><br><span class="line">addString: [T](x: T, y: T)(implicit evidence$1: T =&gt; String)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; addString(&quot;Hello&quot;,&quot;World&quot;)</span><br><span class="line">Hello World</span><br><span class="line"></span><br><span class="line">scala&gt; addString(100,200)</span><br><span class="line">&lt;console&gt;:13: error: No implicit view available from Int =&gt; String.</span><br><span class="line">       addString(100,200)</span><br><span class="line">                ^</span><br></pre></td></tr></table></figure></p><p>实际运行时发生了错误：<font color="#f00">No implicit view available from Int =&gt; String.</font><br>这是因为Scala并没有定义如何将Int转换成String的规则，所以要使用视图界定，就必须手动创建转换规则。<br>如下所示，创建了转换规则后，运行成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; implicit def int2String(n:Int):String = n.toString</span><br><span class="line">warning: there was one feature warning; re-run with -feature for details</span><br><span class="line">int2String: (n: Int)String</span><br><span class="line"></span><br><span class="line">scala&gt; addString(100,200)</span><br><span class="line">100 200</span><br></pre></td></tr></table></figure></p><p><br><br><strong>上下文界定Context Bounds</strong><br>上下文界定的类型参数形式为T:M的形式，其中M是一个泛型，这种形式要求存在一个M[T]类型的隐式值。<br>例如：使用Scala内置的比较器比较大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Calculator[T:Ordering](val number1:T,val number2:T)&#123;</span><br><span class="line">     |     def max(implicit order:Ordering[T]) = if(order.compare(number1,number2) &gt; 0) number1 else number2</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Calculator</span><br><span class="line"></span><br><span class="line">scala&gt; val cal = new Calculator(3,6)</span><br><span class="line">cal: Calculator[Int] = Calculator@3700ec9c</span><br><span class="line"></span><br><span class="line">scala&gt; cal.max</span><br><span class="line">res0: Int = 6</span><br></pre></td></tr></table></figure></p><p><br><br><strong>Manifest Context Bounds</strong><br>在Scala中，数组必须是有类型的，如果直接是泛型的话会报错，这时就必须使用Manifest上下文界定。<br>也就是说，如果数组元素类型为T的话，要实例化Array[T]这种泛型数组，需要为类或者函数定义[T:Manifest]泛型类型。<br>案例：将大人分成一组，将小孩分成一组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Child(val name:String)</span><br><span class="line"></span><br><span class="line">scala&gt; class Adult(val name:String)</span><br><span class="line"></span><br><span class="line">scala&gt; def toGroup[T:Manifest](p:T*) = &#123;</span><br><span class="line">     |     val group = new Array[T](p.length)</span><br><span class="line">     |     for(i &lt;- 0 until p.length) group(i) = p(i)</span><br><span class="line">     |     group</span><br><span class="line">     | &#125;</span><br><span class="line">toGroup: [T](p: T*)(implicit evidence$1: Manifest[T])Array[T]</span><br><span class="line"></span><br><span class="line">scala&gt; val child1 = new Child(&quot;Tom&quot;)</span><br><span class="line"></span><br><span class="line">scala&gt; val child2 = new Child(&quot;Bob&quot;)</span><br><span class="line"></span><br><span class="line">scala&gt; val child3 = new Child(&quot;Alice&quot;)</span><br><span class="line"></span><br><span class="line">scala&gt; val childGroup = toGroup(child1,child2,child3)</span><br><span class="line">childGroup: Array[Child] = Array(Child@7b22ec89, Child@4a1e3ac1, Child@4f449e8f)</span><br><span class="line"></span><br><span class="line">scala&gt; val adult1 = new Adult(&quot;Jack&quot;)</span><br><span class="line"></span><br><span class="line">scala&gt; val adult2 = new Adult(&quot;Jerry&quot;)</span><br><span class="line"></span><br><span class="line">scala&gt; val adult3 = new Adult(&quot;Peter&quot;)</span><br><span class="line"></span><br><span class="line">scala&gt; val adultGroup = toGroup(adult1,adult2,adult3)</span><br><span class="line">adultGroup: Array[Adult] = Array(Adult@1816e24a, Adult@4fad6218, Adult@112d1c8e)</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;视图界定View Bounds&lt;/strong&gt;&lt;br&gt;视图界定比上界&amp;nbsp;&amp;lt;:&amp;nbsp;适用的范围更广，除了所有的子类型，还允许隐式转换过去的类型。用&amp;nbsp;&amp;lt;%&amp;nbsp;表示。&lt;br&gt;例如：拼接字符串。这里由于T的上界是String，当参数传入整数100和200时，就会出现类型不匹配。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala泛型类型的上界(Upper Bounds)和下界(Lower Bounds)</title>
    <link href="https://www.ggstu.com/2018/08/25/Scala%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%8A%E7%95%8C-Upper-Bounds-%E5%92%8C%E4%B8%8B%E7%95%8C-Lower-Bounds/"/>
    <id>https://www.ggstu.com/2018/08/25/Scala泛型类型的上界-Upper-Bounds-和下界-Lower-Bounds/</id>
    <published>2018-08-25T07:18:08.000Z</published>
    <updated>2018-08-25T08:21:53.868Z</updated>
    
    <content type="html"><![CDATA[<p>在指定泛型类型的时候，有时需要对泛型类型的范围进行界定，而不是可以是任意的类型。<br>比如，要求某个泛型类型，它必须是某个类的子类，这样在程序中就可以放心的调用满足泛型条件的方法，程序才能正常的使用和运行。<br>Scala的上下边界特性允许泛型类型必须是某个类的子类，或者必须是某个类的父类。<br><a id="more"></a><br><strong>上界Upper Bounds</strong><br>定义：S&lt;:T，也就是类型S必须是类型T的子类（或本身，自己也可以是自己的子类。）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Vehicle&#123;</span><br><span class="line">    def drive() = println(&quot;Driving&quot;)</span><br><span class="line">&#125;</span><br><span class="line">class Car extends Vehicle&#123;</span><br><span class="line">    override def drive() = println(&quot;Car driving&quot;)</span><br><span class="line">&#125;</span><br><span class="line">class Person&#123;</span><br><span class="line">    def drive() = println(&quot;I&apos;m driving the car.&quot;)</span><br><span class="line">&#125;</span><br><span class="line">def takeVehicle[T &lt;: Vehicle](v:T) = v.drive()</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">scala&gt; val v:Vehicle = new Vehicle</span><br><span class="line">scala&gt; takeVehicle(v)</span><br><span class="line">Driving</span><br><span class="line"></span><br><span class="line">scala&gt; val c:Car = new Car</span><br><span class="line">scala&gt; takeVehicle(c)</span><br><span class="line">Car driving</span><br><span class="line"></span><br><span class="line">scala&gt; val p = new Person</span><br><span class="line">scala&gt; takeVehicle(p)</span><br><span class="line">&lt;console&gt;:16: error: inferred type arguments [Person] do not conform to method takeVehicle&apos;s type parameter bounds [T &lt;: Vehicle]</span><br><span class="line">       takeVehicle(p)</span><br><span class="line">       ^</span><br><span class="line">&lt;console&gt;:16: error: type mismatch;</span><br><span class="line"> found   : Person</span><br><span class="line"> required: T</span><br><span class="line">       takeVehicle(p)</span><br><span class="line">                   ^</span><br></pre></td></tr></table></figure></p><p><br><br><strong>下界Lower Bounds</strong><br>定义：U&gt;:T，也就是类型U必须是类型T的父类（或本身，自己也可以是自己的父类。）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Father</span><br><span class="line">defined class Father</span><br><span class="line"></span><br><span class="line">scala&gt; class Child extends Father</span><br><span class="line">defined class Child</span><br><span class="line"></span><br><span class="line">scala&gt; class Teacher</span><br><span class="line">defined class Teacher</span><br><span class="line"></span><br><span class="line">scala&gt; def getName[T &gt;: Child](person:T)&#123;</span><br><span class="line">     |     if(person.getClass == classOf[Child]) println(&quot;I&apos;m child.&quot;)</span><br><span class="line">     |     else if(person.getClass == classOf[Father]) println(&quot;I&apos;m father.&quot;)</span><br><span class="line">     |     else println(&quot;Sorry,don&apos;t know who you are.&quot;)</span><br><span class="line">     | &#125;</span><br><span class="line">getName: [T &gt;: Child](person: T)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; val p1 = new Father</span><br><span class="line">p1: Father = Father@3688eb5b</span><br><span class="line"></span><br><span class="line">scala&gt; getName(p1)</span><br><span class="line">I&apos;m father.</span><br><span class="line"></span><br><span class="line">scala&gt; val p2 = new Child</span><br><span class="line">p2: Child = Child@7f0d96f2</span><br><span class="line"></span><br><span class="line">scala&gt; getName(p2)</span><br><span class="line">I&apos;m child.</span><br><span class="line"></span><br><span class="line">scala&gt; val p3 = new Teacher</span><br><span class="line">p3: Teacher = Teacher@5143c662</span><br><span class="line"></span><br><span class="line">scala&gt; getName(p3)</span><br><span class="line">Sorry,don&apos;t know who you are.</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在指定泛型类型的时候，有时需要对泛型类型的范围进行界定，而不是可以是任意的类型。&lt;br&gt;比如，要求某个泛型类型，它必须是某个类的子类，这样在程序中就可以放心的调用满足泛型条件的方法，程序才能正常的使用和运行。&lt;br&gt;Scala的上下边界特性允许泛型类型必须是某个类的子类，或者必须是某个类的父类。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala的泛型类和泛型函数</title>
    <link href="https://www.ggstu.com/2018/08/25/Scala%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%92%8C%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0/"/>
    <id>https://www.ggstu.com/2018/08/25/Scala的泛型类和泛型函数/</id>
    <published>2018-08-25T06:25:35.000Z</published>
    <updated>2018-08-25T07:06:36.829Z</updated>
    
    <content type="html"><![CDATA[<p>在Scala中可以使用类型参数来实现类和函数，这样的类和函数可以用于多种类型。比如Array[T]可以存放任意指定类型T的数据。</p><p><strong>泛型类</strong>就是在类的声明中，定义一些泛型类型，然后在类内部，就可以使用这些泛型类型。直接给使用了泛型类型的字段赋值时，Scala会自动进行类型推断。使用泛型类，通常是需要对类中的某些成员，比如某些字段和方法中的参数或变量进行统一的类型限制，这样可以保证程序的健壮性和稳定性。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student[T](val name:T)&#123;</span><br><span class="line">     |     def getAge(age:T) = name + &quot;:&quot; + age + &quot; years old&quot;</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student(&quot;Tom&quot;)</span><br><span class="line">s: Student[String] = Student@366ac49b</span><br><span class="line"></span><br><span class="line">scala&gt; s.getAge(&quot;21&quot;)</span><br><span class="line">res0: String = Tom:21 years old</span><br><span class="line"></span><br><span class="line">scala&gt; s.getAge(21)</span><br><span class="line">&lt;console&gt;:14: error: type mismatch;</span><br><span class="line"> found   : Int(21)</span><br><span class="line"> required: String</span><br><span class="line">       s.getAge(21)</span><br><span class="line">                ^</span><br></pre></td></tr></table></figure><p><br><br><strong>泛型函数</strong>，与泛型类类似，可以给某个函数在声明时指定泛型类型。<br>与泛型类一样，可以通过给使用了泛型类型的变量传递值来让Scala自动推断泛型的实际类型，也可以在调用函数时，手动指定泛型类型。<br>例如：创建一个函数，既能创建Int类型的数据，也能创建String类型的数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.reflect.ClassTag</span><br><span class="line">import scala.reflect.ClassTag</span><br><span class="line"></span><br><span class="line">scala&gt; def mkArray[T:ClassTag](elems:T*) = Array[T](elems:_*)</span><br><span class="line">mkArray: [T](elems: T*)(implicit evidence$1: scala.reflect.ClassTag[T])Array[T]</span><br><span class="line"></span><br><span class="line">scala&gt; mkArray(1,2,3,4,5)</span><br><span class="line">res0: Array[Int] = Array(1, 2, 3, 4, 5)</span><br><span class="line"></span><br><span class="line">scala&gt; mkArray(&quot;Tom&quot;,&quot;Bob&quot;,&quot;Alice&quot;)</span><br><span class="line">res1: Array[String] = Array(Tom, Bob, Alice)</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Scala中可以使用类型参数来实现类和函数，这样的类和函数可以用于多种类型。比如Array[T]可以存放任意指定类型T的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;泛型类&lt;/strong&gt;就是在类的声明中，定义一些泛型类型，然后在类内部，就可以使用这些泛型类型。直接给使用了泛型类型的字段赋值时，Scala会自动进行类型推断。使用泛型类，通常是需要对类中的某些成员，比如某些字段和方法中的参数或变量进行统一的类型限制，这样可以保证程序的健壮性和稳定性。&lt;/p&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala的模式匹配</title>
    <link href="https://www.ggstu.com/2018/08/25/Scala%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <id>https://www.ggstu.com/2018/08/25/Scala的模式匹配/</id>
    <published>2018-08-24T23:41:08.000Z</published>
    <updated>2018-08-25T01:42:59.352Z</updated>
    
    <content type="html"><![CDATA[<p>Scala的模式匹配，即match case语法，类似于Java中的switch case语法，即对一个值进行条件判断，然后针对不同的条件，进行不同的处理。<br>Java的switch case语法只能对值进行匹配。但是Scala的模式匹配除了可以对值进行匹配之外，还可以对类型进行匹配、对Array和List的元素情况进行匹配、对case class进行匹配、甚至对有值或没值(Option)进行匹配。<br><a id="more"></a><br>match case中，只要一个case分支满足条件，就不会继续判断下一个case分支了。与Java不同，java的switch case需要用break停止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">def judgeGrade(grade:String)&#123;</span><br><span class="line">    grade match&#123;</span><br><span class="line">        case &quot;A&quot; =&gt; println(&quot;Excellent&quot;)</span><br><span class="line">        case &quot;B&quot; =&gt; println(&quot;Good&quot;)</span><br><span class="line">        case &quot;C&quot; =&gt; println(&quot;Not bad&quot;)</span><br><span class="line">        case _ =&gt; println(&quot;Work harder&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">judgeGrade: (grade: String)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; judgeGrade(&quot;A&quot;)</span><br><span class="line">Excellent</span><br><span class="line"></span><br><span class="line">scala&gt; judgeGrade(&quot;D&quot;)</span><br><span class="line">Work harder</span><br></pre></td></tr></table></figure></p><p><br><br><strong>在模式匹配中使用if守卫</strong><br>Scala的模式匹配case后的条件判断中，不仅仅可以只提供一个值，而是可以在值后面再加一个if守卫，进行双重过滤。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">def judgeGrade(name:String,grade:String)&#123;</span><br><span class="line">    grade match&#123;</span><br><span class="line">        case &quot;A&quot; =&gt; println(name + &quot;,excellent.&quot;)</span><br><span class="line">        case &quot;B&quot; =&gt; println(name + &quot;,good.&quot;)</span><br><span class="line">        case &quot;C&quot; =&gt; println(name + &quot;,not bad.&quot;)</span><br><span class="line">        case _ if name==&quot;Tom&quot; =&gt; println(&quot;Come on Tom,you need to work harder.&quot;)</span><br><span class="line">        case _ =&gt; println(name + &quot;,work harder.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">judgeGrade: (name: String, grade: String)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; judgeGrade(&quot;Tom&quot;,&quot;B&quot;)</span><br><span class="line">Tom,good.</span><br><span class="line"></span><br><span class="line">scala&gt; judgeGrade(&quot;Tom&quot;,&quot;E&quot;)</span><br><span class="line">Come on Tom,you need to work harder.</span><br><span class="line"></span><br><span class="line">scala&gt; judgeGrade(&quot;Bob&quot;,&quot;E&quot;)</span><br><span class="line">Bob,work harder.</span><br></pre></td></tr></table></figure></p><p><br><br><strong>模式匹配中的变量</strong><br>Scala的模式匹配可以将模式匹配的默认情况，下划线，替换为一个变量名，此时模式匹配语法就会将要匹配的值赋值给这个变量，从而可以在后面的处理语句中使用这个变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">def judgeGrade(grade:String)&#123;</span><br><span class="line">    grade match&#123;</span><br><span class="line">        case &quot;A&quot; =&gt; println(&quot;Excellent&quot;)</span><br><span class="line">        case &quot;B&quot; =&gt; println(&quot;Good&quot;)</span><br><span class="line">        case &quot;C&quot; =&gt; println(&quot;Not bad&quot;)</span><br><span class="line">        case lowGrade =&gt; println(&quot;Your grade is &quot; + lowGrade + &quot;,work harder.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">judgeGrade: (grade: String)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; judgeGrade(&quot;D&quot;)</span><br><span class="line">Your grade is D,work harder.</span><br></pre></td></tr></table></figure></p><p><br><br><strong>对类型进行模式匹配</strong><br>Scala的模式匹配可以直接匹配类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val v:Any = 100</span><br><span class="line">v: Any = 100</span><br><span class="line"></span><br><span class="line">scala&gt; v match&#123;</span><br><span class="line">     |     case x:Int =&gt; println(&quot;Integer: &quot; + x)</span><br><span class="line">     |     case s:String =&gt; println(&quot;String: &quot; + s)</span><br><span class="line">     |     case _ =&gt; println(&quot;Other type.&quot;)</span><br><span class="line">     | &#125;</span><br><span class="line">Integer: 100</span><br></pre></td></tr></table></figure></p><p><br><br><strong>对Array和List进行模式匹配</strong><br>对Array进行模式匹配，可以匹配带有指定元素的数组、带有指定个数元素的数组、以某元素打头的数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a = Array(1,2,3)</span><br><span class="line">a: Array[Int] = Array(1, 2, 3)</span><br><span class="line"></span><br><span class="line">scala&gt; a match&#123;</span><br><span class="line">     |     case Array(0) =&gt; println(&quot;0&quot;)</span><br><span class="line">     |     case Array(x,y) =&gt; println(&quot;This array contains two elements,the sum is &quot; + (x+y))</span><br><span class="line">     |     case Array(x,y,z) =&gt; println(&quot;This array contains three elements,the product is &quot; + (x*y*z))</span><br><span class="line">     |     case Array(x,_*) =&gt; println(&quot;This is an array.&quot;)</span><br><span class="line">     | &#125;</span><br><span class="line">This array contains three elements,the product is 6</span><br></pre></td></tr></table></figure></p><p>对List进行模式匹配，与Array类似，但是需要使用List特有的::操作符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val list = List(1,2,3)</span><br><span class="line">list: List[Int] = List(1, 2, 3)</span><br><span class="line"></span><br><span class="line">scala&gt; list match&#123;</span><br><span class="line">     |     case 1::Nil =&gt; println(&quot;This is List(1)&quot;)</span><br><span class="line">     |     case 1::2::Nil =&gt; println(&quot;This is List(1,2)&quot;)</span><br><span class="line">     |     case 1::tail =&gt; println(&quot;This is List:&quot; + list)</span><br><span class="line">     |     case _ =&gt; println(&quot;Other list.&quot;)</span><br><span class="line">     | &#125;</span><br><span class="line">This is List:List(1, 2, 3)</span><br></pre></td></tr></table></figure></p><p><br><br><strong>样本类case class与模式匹配</strong><br>Scala中提供了样本类，用case class进行声明。<br>case class的主构造函数接收的参数通常不需要使用var或val修饰，Scala自动就会使用val修饰。<br>Scala自动为case class定义了伴生对象，也就是object，并且定义了apply()方法，该方法接收主构造函数中相同的参数，并返回case class对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Vehicle</span><br><span class="line">case class Car(name:String) extends Vehicle</span><br><span class="line">case class Bicycle(name:String) extends Vehicle</span><br><span class="line"></span><br><span class="line">def judgeVehicle(v:Vehicle)&#123;</span><br><span class="line">    v match&#123;</span><br><span class="line">        case Car(name) =&gt; println(&quot;I&apos;m a car.I&apos;m &quot; + name)</span><br><span class="line">        case Bicycle(name) =&gt; println(&quot;I&apos;m a bicycle.I&apos;m &quot; + name)</span><br><span class="line">        case _ =&gt; println(&quot;Other vehicle.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Vehicle</span><br><span class="line">defined class Car</span><br><span class="line">defined class Bicycle</span><br><span class="line">judgeVehicle: (v: Vehicle)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; val aCar:Vehicle = new Car(&quot;Rolls-Royce&quot;)</span><br><span class="line">aCar: Vehicle = Car(Rolls-Royce)</span><br><span class="line"></span><br><span class="line">scala&gt; judgeVehicle(aCar)</span><br><span class="line">I&apos;m a car.I&apos;m Rolls-Royce</span><br></pre></td></tr></table></figure></p><p><br><br><strong>Option与模式匹配</strong><br>Scala有一种特殊的类型，叫做Option。Option有两种值，一种是Some，表示有值，一种是None，表示没有值。<br>Option通常会用于模式匹配中，用于判断某个变量是有值还是没有值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val grades = Map(&quot;Tom&quot;-&gt;&quot;A&quot;,&quot;Bob&quot;-&gt;&quot;B&quot;,&quot;Alice&quot;-&gt;&quot;C&quot;)</span><br><span class="line">grades: scala.collection.immutable.Map[String,String] = Map(Tom -&gt; A, Bob -&gt; B, Alice -&gt; C)</span><br><span class="line"></span><br><span class="line">scala&gt; def getGrade(name:String)&#123;</span><br><span class="line">     |     val grade = grades.get(name)</span><br><span class="line">     |     grade match&#123;</span><br><span class="line">     |         case Some(grade) =&gt; println(&quot;Your grade is &quot; + grade)</span><br><span class="line">     |         case None =&gt; println(&quot;Sorry,your grade information is not in the system.&quot;)</span><br><span class="line">     |     &#125;</span><br><span class="line">     | &#125;</span><br><span class="line">getGrade: (name: String)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; getGrade(&quot;Tom&quot;)</span><br><span class="line">Your grade is A</span><br><span class="line"></span><br><span class="line">scala&gt; getGrade(&quot;Jerry&quot;)</span><br><span class="line">Sorry,your grade information is not in the system.</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scala的模式匹配，即match case语法，类似于Java中的switch case语法，即对一个值进行条件判断，然后针对不同的条件，进行不同的处理。&lt;br&gt;Java的switch case语法只能对值进行匹配。但是Scala的模式匹配除了可以对值进行匹配之外，还可以对类型进行匹配、对Array和List的元素情况进行匹配、对case class进行匹配、甚至对有值或没值(Option)进行匹配。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala集合中的List和Set</title>
    <link href="https://www.ggstu.com/2018/08/24/Scala%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84List%E5%92%8CSet/"/>
    <id>https://www.ggstu.com/2018/08/24/Scala集合中的List和Set/</id>
    <published>2018-08-24T09:25:44.000Z</published>
    <updated>2018-08-24T13:02:27.026Z</updated>
    
    <content type="html"><![CDATA[<p>Scala的集合体系主要包括：Iterable、Seq、Set、Map。其中Iterable是所有集合trait的根trait。<br>Scala的集合分成可变和不可变两类集合，可变集合指集合的元素可以动态修改，不可变集合指集合的元素在初始化之后不能修改。分别对应scala.collection.mutable和scala.collection.immutable两个包。<br>Seq下包含了Range、ArrayBuffer、List等子trait。其中Range就代表了一个序列，通常可以使用”1 to 10”这种语法来产生一个Range。ArrayBuffer就类似于Java中的ArrayList。<br><a id="more"></a><br>下面这张图就是Scala的集合结构<br><img src="http://pd8lpasbc.bkt.clouddn.com/26-1.jpg" alt="Scala的集合结构"><br><br><br>下面就来介绍一下常用的List集合和Set集合<br><br><br><strong>不可变列表List</strong><br>List代表一个不可变的列表。<br>List的创建：<br>字符串列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val nameList = List(&quot;Tom&quot;,&quot;Bob&quot;,&quot;Alice&quot;)</span><br><span class="line">nameList: List[String] = List(Tom, Bob, Alice)</span><br></pre></td></tr></table></figure></p><p>整数列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val intList = List(1,2,3,4,5)</span><br><span class="line">intList: List[Int] = List(1, 2, 3, 4, 5)</span><br></pre></td></tr></table></figure></p><p>空列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val nullList = List()</span><br><span class="line">nullList: List[Nothing] = List()</span><br></pre></td></tr></table></figure></p><p>二维列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val dim:List[List[Int]] = List(List(1,2,3),List(4,5,6))</span><br><span class="line">dim: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6))</span><br></pre></td></tr></table></figure></p><p>不可变列表中的元素不可改变，如果修改其中的元素，会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val list = List(1,2,3,4)</span><br><span class="line">list: List[Int] = List(1, 2, 3, 4)</span><br><span class="line"></span><br><span class="line">scala&gt; list += 5</span><br><span class="line">&lt;console&gt;:13: error: value += is not a member of List[Int]</span><br><span class="line">       list += 5</span><br><span class="line">            ^</span><br></pre></td></tr></table></figure></p><p>List有head和tail，head表示List的第一个元素，tail表示除了第一个元素之后的所有元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val intList = List(1,2,3,4,5)</span><br><span class="line">intList: List[Int] = List(1, 2, 3, 4, 5)</span><br><span class="line"></span><br><span class="line">scala&gt; intList.head</span><br><span class="line">res0: Int = 1</span><br><span class="line"></span><br><span class="line">scala&gt; intList.tail</span><br><span class="line">res1: List[Int] = List(2, 3, 4, 5)</span><br></pre></td></tr></table></figure></p><p>List有特殊的::操作符，可以用于将head和tail合并成一个List。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val list1 = List(2,3,4,5)</span><br><span class="line">list1: List[Int] = List(2, 3, 4, 5)</span><br><span class="line"></span><br><span class="line">scala&gt; val list2 = 1::list1</span><br><span class="line">list2: List[Int] = List(1, 2, 3, 4, 5)</span><br></pre></td></tr></table></figure></p><p>使用List的例子：用递归函数给List中每个元素都加上指定前缀<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">def addPrefix(t:List[Int],prefix:String)&#123;</span><br><span class="line">    if(t != Nil)&#123;</span><br><span class="line">        println(prefix + t.head)</span><br><span class="line">        addPrefix(t.tail,prefix)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">addPrefix: (t: List[Int], prefix: String)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; addPrefix(List(1,2,3,4,5),&quot;*&quot;)</span><br><span class="line">*1</span><br><span class="line">*2</span><br><span class="line">*3</span><br><span class="line">*4</span><br><span class="line">*5</span><br></pre></td></tr></table></figure></p><p><br><br><strong>可变列表LinkedList(MutableList)</strong><br>LinkedList代表一个可变的列表，需要导入scala.collection.mutable._<br>elem表示LinkedList的第一个元素，next表示除了第一个元素之后的所有元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val t = scala.collection.mutable.LinkedList(1,2,3,4,5)</span><br><span class="line">warning: there was one deprecation warning; re-run with -deprecation for details</span><br><span class="line">t: scala.collection.mutable.LinkedList[Int] = LinkedList(1, 2, 3, 4, 5)</span><br><span class="line"></span><br><span class="line">scala&gt; t.elem</span><br><span class="line">res0: Int = 1</span><br><span class="line"></span><br><span class="line">scala&gt; t.next</span><br><span class="line">res1: scala.collection.mutable.LinkedList[Int] = LinkedList(2, 3, 4, 5)</span><br></pre></td></tr></table></figure></p><p>这里看到一条警告：<font color="#f00">warning: there was one deprecation warning;</font>因为LinkedList在Scala 2.11已被弃用。<br>官方文档给出的做法是使用MutableList代替LinkedList。<br>head表示MutableList的第一个元素，tail表示除了第一个元素之后的所有元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val t = scala.collection.mutable.MutableList(1,2,3,4,5)</span><br><span class="line">t: scala.collection.mutable.MutableList[Int] = MutableList(1, 2, 3, 4, 5)</span><br><span class="line"></span><br><span class="line">scala&gt; t.head</span><br><span class="line">res0: Int = 1</span><br><span class="line"></span><br><span class="line">scala&gt; t.tail</span><br><span class="line">res1: scala.collection.mutable.MutableList[Int] = MutableList(2, 3, 4, 5)</span><br></pre></td></tr></table></figure></p><p>例如：向MutableList列表中添加元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.collection.mutable._</span><br><span class="line">import scala.collection.mutable._</span><br><span class="line"></span><br><span class="line">scala&gt; val t = MutableList(1,2,3,4)</span><br><span class="line">t: scala.collection.mutable.MutableList[Int] = MutableList(1, 2, 3, 4)</span><br><span class="line"></span><br><span class="line">scala&gt; t += 5</span><br><span class="line">res0: t.type = MutableList(1, 2, 3, 4, 5)</span><br></pre></td></tr></table></figure></p><p><br><br><strong>Set集合</strong><br>Set是一个没有重复元素的集合，将重复元素加入Set是没有用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val s = Set(1,2,3)</span><br><span class="line">s: scala.collection.immutable.Set[Int] = Set(1, 2, 3)</span><br><span class="line"></span><br><span class="line">scala&gt; s + 1</span><br><span class="line">res0: scala.collection.immutable.Set[Int] = Set(1, 2, 3)</span><br><span class="line"></span><br><span class="line">scala&gt; s + 4</span><br><span class="line">res1: scala.collection.immutable.Set[Int] = Set(1, 2, 3, 4)</span><br></pre></td></tr></table></figure></p><p>与列表不同，Set不保证元素插入的顺序，即Set中的元素是乱序的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val s = new scala.collection.mutable.HashSet[Int]()</span><br><span class="line">s: scala.collection.mutable.HashSet[Int] = Set()</span><br><span class="line"></span><br><span class="line">scala&gt; s += 1</span><br><span class="line">res0: s.type = Set(1)</span><br><span class="line"></span><br><span class="line">scala&gt; s += 2</span><br><span class="line">res1: s.type = Set(1, 2)</span><br><span class="line"></span><br><span class="line">scala&gt; s += 5</span><br><span class="line">res2: s.type = Set(1, 5, 2)</span><br></pre></td></tr></table></figure></p><p><br><br><strong>LinkedHashSet</strong><br>LinkedHashSet会用一个链表维护插入顺序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val s = new scala.collection.mutable.LinkedHashSet[Int]()</span><br><span class="line">s: scala.collection.mutable.LinkedHashSet[Int] = Set()</span><br><span class="line"></span><br><span class="line">scala&gt; s += 1</span><br><span class="line">res0: s.type = Set(1)</span><br><span class="line"></span><br><span class="line">scala&gt; s += 2</span><br><span class="line">res1: s.type = Set(1, 2)</span><br><span class="line"></span><br><span class="line">scala&gt; s += 5</span><br><span class="line">res2: s.type = Set(1, 2, 5)</span><br></pre></td></tr></table></figure></p><p><br><br><strong>SortedSet</strong><br>SortedSet会对元素进行排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val s = scala.collection.mutable.SortedSet(1,5,3,6,2)</span><br><span class="line">s: scala.collection.mutable.SortedSet[Int] = TreeSet(1, 2, 3, 5, 6)</span><br></pre></td></tr></table></figure></p><p><br><br><strong>Set的操作</strong><br>1、添加元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val s = scala.collection.mutable.HashSet(1,2,3,4)</span><br><span class="line">s: scala.collection.mutable.HashSet[Int] = Set(1, 2, 3, 4)</span><br><span class="line"></span><br><span class="line">scala&gt; s += 5</span><br><span class="line">res0: s.type = Set(1, 5, 2, 3, 4)</span><br></pre></td></tr></table></figure></p><p>2、判断元素是否存在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; s contains(5)</span><br><span class="line">res1: Boolean = true</span><br><span class="line"></span><br><span class="line">scala&gt; s contains(6)</span><br><span class="line">res2: Boolean = false</span><br></pre></td></tr></table></figure></p><p>3、判断一个Set是否是另外一个Set的子集<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; Set(1,2,3) subsetOf(s)</span><br><span class="line">res3: Boolean = true</span><br><span class="line"></span><br><span class="line">scala&gt; Set(5,6,7) subsetOf(s)</span><br><span class="line">res4: Boolean = false</span><br></pre></td></tr></table></figure></p><p>4、并集运算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var set1 = Set(1,2,3,4,5)</span><br><span class="line">set1: scala.collection.immutable.Set[Int] = Set(5, 1, 2, 3, 4)</span><br><span class="line"></span><br><span class="line">scala&gt; var set2 = Set(3,4,5,6,7)</span><br><span class="line">set2: scala.collection.immutable.Set[Int] = Set(5, 6, 7, 3, 4)</span><br><span class="line"></span><br><span class="line">scala&gt; set1 union set2</span><br><span class="line">res5: scala.collection.immutable.Set[Int] = Set(5, 1, 6, 2, 7, 3, 4)</span><br></pre></td></tr></table></figure></p><p>5、交集运算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; set1 intersect set2</span><br><span class="line">res6: scala.collection.immutable.Set[Int] = Set(5, 3, 4)</span><br></pre></td></tr></table></figure></p><p>6、差集运算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; set1 diff set2</span><br><span class="line">res7: scala.collection.immutable.Set[Int] = Set(1, 2)</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scala的集合体系主要包括：Iterable、Seq、Set、Map。其中Iterable是所有集合trait的根trait。&lt;br&gt;Scala的集合分成可变和不可变两类集合，可变集合指集合的元素可以动态修改，不可变集合指集合的元素在初始化之后不能修改。分别对应scala.collection.mutable和scala.collection.immutable两个包。&lt;br&gt;Seq下包含了Range、ArrayBuffer、List等子trait。其中Range就代表了一个序列，通常可以使用”1 to 10”这种语法来产生一个Range。ArrayBuffer就类似于Java中的ArrayList。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala语言的函数式编程</title>
    <link href="https://www.ggstu.com/2018/08/23/Scala%E8%AF%AD%E8%A8%80%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.ggstu.com/2018/08/23/Scala语言的函数式编程/</id>
    <published>2018-08-23T06:54:36.000Z</published>
    <updated>2018-08-24T13:45:55.667Z</updated>
    
    <content type="html"><![CDATA[<p>Java是完全面向对象的编程语言，所以类和对象是“一等公民”，Java中的方法不能脱离类和对象独立存在。<br>Scala是一门既面向对象，又面向过程的语言。在Scala中，函数与类、对象等一样，都是“一等公民”。Scala中的函数可以独立存在，不需要依赖任何类和对象。<br>Scala的函数式编程，就是Scala面向过程的体现。正是因为函数式编程，才让Scala具备了Java所不具备的更强大的功能和特性。<br><a id="more"></a><br><strong>将函数赋值给变量</strong><br>Scala中的函数是“一等公民”，可以独立定义，独立存在，而且可以直接将函数作为值赋给变量。<br>Scala的语法规定，将函数赋值给变量时，必须在函数名后加上空格和下划线。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sayHello(name:String)&#123;</span><br><span class="line">     |     println(&quot;Hello,&quot; + name)</span><br><span class="line">     | &#125;</span><br><span class="line">sayHello: (name: String)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; val s = sayHello _</span><br><span class="line">s: String =&gt; Unit = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; s(&quot;Tom&quot;)</span><br><span class="line">Hello,Tom</span><br></pre></td></tr></table></figure></p><p><br><br><strong>匿名函数</strong><br>Scala中，函数也可以不需要命名，此时函数被称为匿名函数。<br>定义函数之后，可以将定义的匿名函数传入其它函数之中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; (x:Int) =&gt; x*3</span><br><span class="line">res0: Int =&gt; Int = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; Array(1,2,3,4,5).map((x:Int) =&gt; x*3)</span><br><span class="line">res1: Array[Int] = Array(3, 6, 9, 12, 15)</span><br></pre></td></tr></table></figure></p><p><br><br><strong>高阶函数</strong><br>高阶函数就是将某个函数作为其它函数的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val sayHello = (name:String) =&gt; println(&quot;Hello,&quot; + name)</span><br><span class="line">sayHello: String =&gt; Unit = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; def person(func:(String) =&gt; Unit,name:String)&#123;</span><br><span class="line">     |     func(name)</span><br><span class="line">     | &#125;</span><br><span class="line">person: (func: String =&gt; Unit, name: String)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; person(sayHello,&quot;Tom&quot;)</span><br><span class="line">Hello,Tom</span><br></pre></td></tr></table></figure></p><p>高阶函数的另外一个功能是将函数作为返回值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sayHello(message:String) = (name:String) =&gt; println(message + &quot;,&quot; + name)</span><br><span class="line">sayHello: (message: String)String =&gt; Unit</span><br><span class="line"></span><br><span class="line">scala&gt; val person = sayHello(&quot;Hello&quot;)</span><br><span class="line">person: String =&gt; Unit = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; person(&quot;Tom&quot;)</span><br><span class="line">Hello,Tom</span><br></pre></td></tr></table></figure></p><p>高阶函数可以自动推断出参数类型，而不需要写明类型。对于只有一个参数的函数，还可以省去其小括号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sayHello(func:(String) =&gt; Unit,name:String)&#123;func(name)&#125;</span><br><span class="line">sayHello: (func: String =&gt; Unit, name: String)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; sayHello((name:String) =&gt; println(&quot;Hello,&quot; + name),&quot;Tom&quot;)</span><br><span class="line">Hello,Tom</span><br><span class="line"></span><br><span class="line">scala&gt; sayHello((name) =&gt; println(&quot;Hello,&quot; + name),&quot;Tom&quot;)</span><br><span class="line">Hello,Tom</span><br><span class="line"></span><br><span class="line">scala&gt; sayHello(name =&gt; println(&quot;Hello,&quot; + name),&quot;Tom&quot;)</span><br><span class="line">Hello,Tom</span><br></pre></td></tr></table></figure></p><p>如果仅有的一个参数在右侧的函数体内只使用一次，还可以将接收参数省略，并且将参数用_来替代。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def triple(func:(Int) =&gt; Int) = &#123;func(3)&#125;</span><br><span class="line">triple: (func: Int =&gt; Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; triple(3*_)</span><br><span class="line">res0: Int = 9</span><br></pre></td></tr></table></figure></p><p><br><br><strong>Scala常用的高阶函数</strong><br>1、map：在列表中的每个元素上计算一个函数，并且返回一个包含相同数目元素的列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val numbers = List(1,2,3,4,5)</span><br><span class="line">numbers: List[Int] = List(1, 2, 3, 4, 5)</span><br><span class="line"></span><br><span class="line">scala&gt; numbers.map((i:Int) =&gt; i*2)</span><br><span class="line">res0: List[Int] = List(2, 4, 6, 8, 10)</span><br></pre></td></tr></table></figure></p><p>2、foreach：对传入的每个元素都进行处理，和map相似，但是没有返回值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; numbers.foreach((i:Int) =&gt; i*2)</span><br><span class="line"></span><br><span class="line">scala&gt; numbers</span><br><span class="line">res2: List[Int] = List(1, 2, 3, 4, 5)</span><br></pre></td></tr></table></figure></p><p>3、filter：对传入的每个元素都进行条件判断，如果对元素返回true，则保留该元素，否则过滤掉该元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; (1 to 10).filter(_%2 == 0)</span><br><span class="line">res3: scala.collection.immutable.IndexedSeq[Int] = Vector(2, 4, 6, 8, 10)</span><br></pre></td></tr></table></figure></p><p>4、zip：把两个列表的元素合成一个由元素对组成的列表里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; List(&quot;Tom&quot;,&quot;Bob&quot;,&quot;Alice&quot;).zip(List(21,18,25))</span><br><span class="line">res4: List[(String, Int)] = List((Tom,21), (Bob,18), (Alice,25))</span><br></pre></td></tr></table></figure></p><p>5、reduceLeft：从左侧元素开始，进行reduce操作，即先对元素1和元素2进行处理，然后将结果与元素3处理，再将结果与元素4处理，依次类推。<br>下面这个操作就相当于1*2*3*4*5*6*7*8*9*10=3628800<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; (1 to 10).reduceLeft(_*_)</span><br><span class="line">res5: Int = 3628800</span><br></pre></td></tr></table></figure></p><p>6、sortWith：对元素进行两两比较，进行排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; Array(3,7,15,9,5).sortWith(_&lt;_)</span><br><span class="line">res6: Array[Int] = Array(3, 5, 7, 9, 15)</span><br><span class="line"></span><br><span class="line">scala&gt; Array(3,7,15,9,5).sortWith(_&gt;_)</span><br><span class="line">res7: Array[Int] = Array(15, 9, 7, 5, 3)</span><br></pre></td></tr></table></figure></p><p>7、partition：对传入的每个元素都进行条件判断，根据返回值的不同进行拆分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val numbers = List(1,2,3,4,5)</span><br><span class="line">numbers: List[Int] = List(1, 2, 3, 4, 5)</span><br><span class="line"></span><br><span class="line">scala&gt; numbers.partition((i:Int) =&gt; i%2 == 0)</span><br><span class="line">res8: (List[Int], List[Int]) = (List(2, 4),List(1, 3, 5))</span><br></pre></td></tr></table></figure></p><p>8、find：返回集合里第一个匹配断言函数的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; numbers.find(_%3 == 0)</span><br><span class="line">res9: Option[Int] = Some(3)</span><br></pre></td></tr></table></figure></p><p>9、flatten：可以把嵌套的结构展开。<br>如：将(1,2,3)和(4,5,6)这两个集合合并成一个集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; List(List(1,2,3),List(4,5,6)).flatten</span><br><span class="line">res10: List[Int] = List(1, 2, 3, 4, 5, 6)</span><br></pre></td></tr></table></figure></p><p>10、flatMap：结合了map和flatten的功能。<br>如：将(1,2,3)和(4,5,6)这两个集合合并成一个集合，再对集合中的每个元素乘以2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val newList = List(List(1,2,3),List(4,5,6))</span><br><span class="line">newList: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6))</span><br><span class="line"></span><br><span class="line">scala&gt; newList.flatMap(x =&gt; x.map(_ * 2))</span><br><span class="line">res11: List[Int] = List(2, 4, 6, 8, 10, 12)</span><br></pre></td></tr></table></figure></p><p>例子：统计多个文本内的单词总数<br>我在桌面创建了两个文件test1.txt和test2.txt。<br>test1.txt中的内容是Hello World!<br>test2.txt中的内容是This is the second file.<br>一共7个单词，最后的输出为7<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val lines1 = scala.io.Source.fromFile(&quot;C://Users//asus//Desktop//test1.txt&quot;).mkString</span><br><span class="line">lines1: String = Hello World!</span><br><span class="line"></span><br><span class="line">scala&gt; val lines2 = scala.io.Source.fromFile(&quot;C://Users//asus//Desktop//test2.txt&quot;).mkString</span><br><span class="line">lines2: String = This is the second file.</span><br><span class="line"></span><br><span class="line">scala&gt; val lines = List(lines1,lines2)</span><br><span class="line">lines: List[String] = List(Hello World!, This is the second file.)</span><br><span class="line"></span><br><span class="line">scala&gt; lines.flatMap(_.split(&quot; &quot;)).map((_,1)).map(_._2).reduceLeft(_+_)</span><br><span class="line">res0: Int = 7</span><br></pre></td></tr></table></figure></p><p><br><br><strong>闭包</strong><br>闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。<br>闭包通常来讲可以简单的认为是可以访问一个函数里面局部变量的另外一个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def person(message:String)=(name:String) =&gt; println(message + &quot;,&quot; + name)</span><br><span class="line">person: (message: String)String =&gt; Unit</span><br><span class="line"></span><br><span class="line">scala&gt; val sayHello = person(&quot;Hello&quot;)</span><br><span class="line">sayHello: String =&gt; Unit = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; val sayHi = person(&quot;Hi&quot;)</span><br><span class="line">sayHi: String =&gt; Unit = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; sayHello(&quot;Tom&quot;)</span><br><span class="line">Hello,Tom</span><br><span class="line"></span><br><span class="line">scala&gt; sayHi(&quot;Tom&quot;)</span><br><span class="line">Hi,Tom</span><br></pre></td></tr></table></figure></p><p><br><br><strong>Scala函数柯里化(Currying)</strong><br>柯里化函数是把具有多个参数的函数转换为一条函数链，每个节点上是单一参数。<br>例如：以下几个函数是等价的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sum1(a:Int,b:Int) = a + b</span><br><span class="line">sum1: (a: Int, b: Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; def sum2(a:Int) = (b:Int) =&gt; a + b</span><br><span class="line">sum2: (a: Int)Int =&gt; Int</span><br><span class="line"></span><br><span class="line">scala&gt; def sum3(a:Int)(b:Int) = a + b</span><br><span class="line">sum3: (a: Int)(b: Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; sum1(1,1)</span><br><span class="line">res0: Int = 2</span><br><span class="line"></span><br><span class="line">scala&gt; sum2(1)(1)</span><br><span class="line">res1: Int = 2</span><br><span class="line"></span><br><span class="line">scala&gt; sum3(1)(1)</span><br><span class="line">res2: Int = 2</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java是完全面向对象的编程语言，所以类和对象是“一等公民”，Java中的方法不能脱离类和对象独立存在。&lt;br&gt;Scala是一门既面向对象，又面向过程的语言。在Scala中，函数与类、对象等一样，都是“一等公民”。Scala中的函数可以独立存在，不需要依赖任何类和对象。&lt;br&gt;Scala的函数式编程，就是Scala面向过程的体现。正是因为函数式编程，才让Scala具备了Java所不具备的更强大的功能和特性。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala中的trait(特质)</title>
    <link href="https://www.ggstu.com/2018/08/21/Scala%E4%B8%AD%E7%9A%84trait-%E7%89%B9%E8%B4%A8/"/>
    <id>https://www.ggstu.com/2018/08/21/Scala中的trait-特质/</id>
    <published>2018-08-21T02:17:47.000Z</published>
    <updated>2018-08-21T06:12:23.704Z</updated>
    
    <content type="html"><![CDATA[<p><strong>将trait作为接口使用</strong><br>Scala中可以将trait作为接口来使用，此时的trait就与Java中的接口非常类似,但实际上它比接口功能更强大。<br>在trait中可以定义抽象方法，就与抽象类中的抽象方法一样，只要不给出方法的具体实现即可。<br>在Scala中没有implement的概念，无论继承类还是trait，统一都是extends。<br>类继承trait后，必须实现其中的抽象方法，实现时不需要使用override关键字。<br>Scala不支持对类进行多继承，但是支持多重继承trait，使用with关键字即可。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">trait PersonTrait&#123;</span><br><span class="line">    def sayHello(name:String)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait MakeFriendsTrait&#123;</span><br><span class="line">    def makeFriends(s:Student)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student(val name:String) extends PersonTrait with MakeFriendsTrait&#123;</span><br><span class="line">    def sayHello(name:String) = println(&quot;Hello,&quot; + name)</span><br><span class="line">    def makeFriends(s:Student) = println(&quot;Hello,my name is &quot; + name + &quot;,your name is &quot; + s.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined trait PersonTrait</span><br><span class="line">defined trait MakeFriendsTrait</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s1 = new Student(&quot;Tom&quot;)</span><br><span class="line">s1: Student = Student@5b67bb7e</span><br><span class="line"></span><br><span class="line">scala&gt; val s2 = new Student(&quot;Bob&quot;)</span><br><span class="line">s2: Student = Student@35645047</span><br><span class="line"></span><br><span class="line">scala&gt; s1.sayHello(&quot;Alice&quot;)</span><br><span class="line">Hello,Alice</span><br><span class="line"></span><br><span class="line">scala&gt; s1.makeFriends(s2)</span><br><span class="line">Hello,my name is Tom,your name is Bob</span><br></pre></td></tr></table></figure></p><p><br><br><strong>在trait中覆盖抽象方法</strong><br>子trait可以覆盖父trait的抽象方法。但是覆盖时，如果使用了super.方法，则无法通过编译。因为super.方法会去调用父trait的抽象方法，此时子trait的该方法还是会被认为是抽象的。<br>如果要通过编译，就得给子trait的方法加上abstract override修饰。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">trait Logger&#123;</span><br><span class="line">    def log(message:String)</span><br><span class="line">&#125;</span><br><span class="line">trait MyLogger extends Logger&#123;</span><br><span class="line">    abstract override def log(message:String)&#123;super.log(message)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined trait Logger</span><br><span class="line">defined trait MyLogger</span><br></pre></td></tr></table></figure></p><p><br><br><strong>在trait中定义具体方法</strong><br>Scala中的trait不仅仅可以定义抽象方法，还可以定义具体方法。<br>trait中可以包含一些很多类都通用的方法。<br>例如，打印日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">trait Logger&#123;</span><br><span class="line">    def log(message:String) = println(&quot;Log: &quot; + message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person(val name:String) extends Logger&#123;</span><br><span class="line">    def sayHello&#123;</span><br><span class="line">        println(&quot;Hello,I&apos;m &quot; + name)</span><br><span class="line">        log(&quot;sayHello method is invoked&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined trait Logger</span><br><span class="line">defined class Person</span><br><span class="line"></span><br><span class="line">scala&gt; val p = new Person(&quot;Tom&quot;)</span><br><span class="line">p: Person = Person@63611043</span><br><span class="line"></span><br><span class="line">scala&gt; p.sayHello</span><br><span class="line">Hello,I&apos;m Tom</span><br><span class="line">Log: sayHello method is invoked</span><br></pre></td></tr></table></figure></p><p><br><br><strong>混合使用trait的抽象方法和具体方法</strong><br>在trait中，可以混合使用抽象方法和具体方法，让具体方法依赖于抽象方法，而抽象方法则放到继承trait的类中去实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">trait Valid&#123;</span><br><span class="line">    def getName:String</span><br><span class="line">    def isTom:Boolean = &#123;</span><br><span class="line">        getName == &quot;Tom&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person(val name:String) extends Valid&#123;</span><br><span class="line">    println(isTom)</span><br><span class="line">    def getName = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined trait Valid</span><br><span class="line">defined class Person</span><br><span class="line"></span><br><span class="line">scala&gt; val p1 = new Person(&quot;Tom&quot;)</span><br><span class="line">true</span><br><span class="line">p: Person = Person@36060e</span><br><span class="line"></span><br><span class="line">scala&gt; val p2 = new Person(&quot;Bob&quot;)</span><br><span class="line">false</span><br><span class="line">p2: Person = Person@60129b9a</span><br></pre></td></tr></table></figure></p><p><br><br><strong>在trait中定义抽象字段</strong><br>Scala中的trait可以定义抽象字段，并且trait中的具体方法可以使用抽象字段。<br>继承trait的类，必须覆盖抽象字段，提供具体的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">trait SayHello&#123;</span><br><span class="line">    val message:String</span><br><span class="line">    def sayHello(name:String) = println(message + &quot;,&quot; + name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person(val name:String) extends SayHello&#123;</span><br><span class="line">    val message:String = &quot;Hello&quot;</span><br><span class="line">    def makeFriends(p:Person)&#123;</span><br><span class="line">        sayHello(p.name)</span><br><span class="line">        println(&quot;My name is &quot; + name + &quot;,your name is &quot; + p.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined trait SayHello</span><br><span class="line">defined class Person</span><br><span class="line"></span><br><span class="line">scala&gt; val p1 = new Person(&quot;Tom&quot;)</span><br><span class="line">p1: Person = Person@7daa0fbd</span><br><span class="line"></span><br><span class="line">scala&gt; val p2 = new Person(&quot;Bob&quot;)</span><br><span class="line">p2: Person = Person@51fadaff</span><br><span class="line"></span><br><span class="line">scala&gt; p1.makeFriends(p2)</span><br><span class="line">Hello,Bob</span><br><span class="line">My name is Tom,your name is Bob</span><br></pre></td></tr></table></figure></p><p><br><br><strong>在trait中定义具体字段</strong><br>Scala中的trait可以定义具体字段，此时继承trait的类会获得trait中定义的字段.<br>这种获取字段的方式与继承类是不同的，继承类获取的字段是定义在父类中的，而继承trait获取的字段会被添加到类中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">trait Person&#123;</span><br><span class="line">    val handNum:Int = 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student(val name:String) extends Person&#123;</span><br><span class="line">    def sayHello = println(&quot;Hello,I&apos;m &quot; + name + &quot;,I have &quot; + handNum + &quot; hands.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined trait Person</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student(&quot;Tom&quot;)</span><br><span class="line">s: Student = Student@babafc2</span><br><span class="line"></span><br><span class="line">scala&gt; s.sayHello</span><br><span class="line">Hello,I&apos;m Tom,I have 2 hands.</span><br></pre></td></tr></table></figure></p><p><br><br><strong>为实例对象混入trait</strong><br>在创建类的对象时，可以指定该对象混入某个trait，使用关键字with。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">trait Logger&#123;</span><br><span class="line">    def log(message:String)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait MyLogger extends Logger&#123;</span><br><span class="line">    override def log(message:String)&#123;</span><br><span class="line">        println(&quot;Log: &quot; + message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person(val name:String) extends Logger&#123;</span><br><span class="line">    def sayHello&#123;</span><br><span class="line">        println(&quot;Hello,I&apos;m &quot; + name)</span><br><span class="line">        log(&quot;sayHello method is invoked&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined trait Logger</span><br><span class="line">defined trait MyLogger</span><br><span class="line">defined class Person</span><br><span class="line"></span><br><span class="line">scala&gt; val p1 = new Person(&quot;Tom&quot;)</span><br><span class="line">p1: Person = Person@51549490</span><br><span class="line"></span><br><span class="line">scala&gt; p1.sayHello</span><br><span class="line">Hello,I&apos;m Tom</span><br><span class="line"></span><br><span class="line">scala&gt; val p2 = new Person(&quot;Bob&quot;) with MyLogger</span><br><span class="line">p2: Person with MyLogger = $anon$1@22f31dec</span><br><span class="line"></span><br><span class="line">scala&gt; p2.sayHello</span><br><span class="line">Hello,I&apos;m Bob</span><br><span class="line">Log: sayHello method is invoked</span><br></pre></td></tr></table></figure></p><p><br><br><strong>trait调用链</strong><br>Scala中支持让类继承多个trait后，依次调用多个trait中的同一个方法，只要在多个trait的同一个方法最后都执行super方法即可。<br>类中调用多个trait中都有的这个方法时，会从最右边的trait的方法开始执行，然后依次往左执行，形成一个调用链。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">trait A&#123;</span><br><span class="line">    def showData(data:String)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">trait B extends A&#123;</span><br><span class="line">    override def showData(data:String)&#123;</span><br><span class="line">        println(&quot;B: &quot; + data)</span><br><span class="line">        super.showData(data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">trait C extends A&#123;</span><br><span class="line">    override def showData(data:String)&#123;</span><br><span class="line">        println(&quot;C: &quot; + data)</span><br><span class="line">        super.showData(data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person(val name:String) extends C with B&#123;</span><br><span class="line">    def sayHello = &#123;</span><br><span class="line">        println(&quot;Hello,&quot; + name)</span><br><span class="line">        showData(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined trait A</span><br><span class="line">defined trait B</span><br><span class="line">defined trait C</span><br><span class="line">defined class Person</span><br><span class="line"></span><br><span class="line">scala&gt; val p = new Person(&quot;Tom&quot;)</span><br><span class="line">p: Person = Person@2c78d320</span><br><span class="line"></span><br><span class="line">scala&gt; p.sayHello</span><br><span class="line">Hello,Tom</span><br><span class="line">B: Tom</span><br><span class="line">C: Tom</span><br></pre></td></tr></table></figure></p><p><br><br><strong>trait的构造机制</strong><br>在Scala中，trait也是有构造代码的。<br>继承了trait的类的构造机制如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;1、父类的构造函数执行；<br>&nbsp;&nbsp;&nbsp;&nbsp;2、trait的构造代码执行，多个trait从左到右依次执行；<br>&nbsp;&nbsp;&nbsp;&nbsp;3、构造trait时会先构造父trait，如果多个trait继承同一个父trait，则父trait只会构造一个；<br>&nbsp;&nbsp;&nbsp;&nbsp;4、所有trait构造完毕之后，子类的构造函数执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Person&#123;println(&quot;Person&apos;s constructor.&quot;)&#125;</span><br><span class="line">trait A&#123;println(&quot;A&apos;s constructor.&quot;)&#125;</span><br><span class="line">trait B extends A&#123;println(&quot;B&apos;s constructor.&quot;)&#125;</span><br><span class="line">trait C extends A&#123;println(&quot;C&apos;s constructor.&quot;)&#125;</span><br><span class="line">class Student extends Person with B with C&#123;</span><br><span class="line">    println(&quot;Student&apos;s constructor.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined trait A</span><br><span class="line">defined trait B</span><br><span class="line">defined trait C</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student</span><br><span class="line">Person&apos;s constructor.</span><br><span class="line">A&apos;s constructor.</span><br><span class="line">B&apos;s constructor.</span><br><span class="line">C&apos;s constructor.</span><br><span class="line">Student&apos;s constructor.</span><br><span class="line">s: Student = Student@37e4d7bb</span><br></pre></td></tr></table></figure></p><p><br><br><strong>trait字段的初始化</strong><br>Scala中，trait没有接收参数的构造函数，这也是trait与class的区别。<br>如果要让trait能够对字段进行初始化，只能使用提前定义的方式。<br>方式一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">trait SayHello&#123;</span><br><span class="line">    val message:String</span><br><span class="line">    println(message.toString)</span><br><span class="line">&#125;</span><br><span class="line">class Person</span><br><span class="line">val p = new&#123;</span><br><span class="line">    val message:String = &quot;hello&quot;</span><br><span class="line">&#125;with Person with SayHello</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">hello</span><br><span class="line">defined trait SayHello</span><br><span class="line">defined class Person</span><br><span class="line">p: Person with SayHello = $anon$1@2d6c53fc</span><br></pre></td></tr></table></figure></p><p>方式二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">trait SayHello&#123;</span><br><span class="line">    val message:String</span><br><span class="line">    println(message.toString)</span><br><span class="line">&#125;</span><br><span class="line">class Person extends&#123;</span><br><span class="line">    val message:String = &quot;hello&quot;</span><br><span class="line">&#125;with SayHello&#123;&#125;</span><br><span class="line">val p = new Person</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">hello</span><br><span class="line">defined trait SayHello</span><br><span class="line">defined class Person</span><br><span class="line">p: Person = Person@5b6ec132</span><br></pre></td></tr></table></figure></p><p>方式三：使用lazy value(懒加载)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">trait SayHello&#123;</span><br><span class="line">    lazy val message:String = null</span><br><span class="line">    println(message.toString)</span><br><span class="line">&#125;</span><br><span class="line">class Person extends SayHello&#123;</span><br><span class="line">    override lazy val message:String = &quot;hello&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined trait SayHello</span><br><span class="line">defined class Person</span><br><span class="line"></span><br><span class="line">scala&gt; val p = new Person</span><br><span class="line">hello</span><br><span class="line">p: Person = Person@3c7c886c</span><br></pre></td></tr></table></figure></p><p><br><br><strong>trait继承类</strong><br>trait也可以继承类，此时这个类就会成为所有继承该trait的类的父类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    def printMessage(message:String) = println(message)</span><br><span class="line">&#125;</span><br><span class="line">trait Logger extends Person&#123;</span><br><span class="line">    def log(message:String) = printMessage(&quot;Log: &quot; + message)</span><br><span class="line">&#125;</span><br><span class="line">class Student(val name:String) extends Logger&#123;</span><br><span class="line">    def sayHello&#123;</span><br><span class="line">        log(&quot;Hello,I&apos;m &quot; + name)</span><br><span class="line">        printMessage(&quot;Hello,I&apos;m &quot; + name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined trait Logger</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student(&quot;Tom&quot;)</span><br><span class="line">s: Student = Student@36a5cabc</span><br><span class="line"></span><br><span class="line">scala&gt; s.sayHello</span><br><span class="line">Log: Hello,I&apos;m Tom</span><br><span class="line">Hello,I&apos;m Tom</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;将trait作为接口使用&lt;/strong&gt;&lt;br&gt;Scala中可以将trait作为接口来使用，此时的trait就与Java中的接口非常类似,但实际上它比接口功能更强大。&lt;br&gt;在trait中可以定义抽象方法，就与抽象类中的抽象方法一样，只要不给出方法的具体实现即可。&lt;br&gt;在Scala中没有implement的概念，无论继承类还是trait，统一都是extends。&lt;br&gt;类继承trait后，必须实现其中的抽象方法，实现时不需要使用override关键字。&lt;br&gt;Scala不支持对类进行多继承，但是支持多重继承trait，使用with关键字即可。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala中的继承</title>
    <link href="https://www.ggstu.com/2018/08/19/Scala%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <id>https://www.ggstu.com/2018/08/19/Scala中的继承/</id>
    <published>2018-08-19T11:36:56.000Z</published>
    <updated>2018-08-19T14:25:31.917Z</updated>
    
    <content type="html"><![CDATA[<p><strong>extends关键字实现继承</strong><br>Scala中，与Java一样，也是使用extends关键字让子类继承父类，使用继承可以有效地复用代码。<br>继承表示子类可以继承父类的属性和方法，子类可以在自己内部放入父类所没有而子类特有的属性和方法。<br>子类可以覆盖父类的属性和方法，但是如果父类用final修饰，属性和方法用final修饰，则该类是无法被继承的，即属性和方法是无法被覆盖。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    private var name = &quot;Tom&quot;</span><br><span class="line">    def getName = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    private var score = &quot;A&quot;</span><br><span class="line">    def getScore = score</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student</span><br><span class="line">s: Student = Student@332729ad</span><br><span class="line"></span><br><span class="line">scala&gt; s.getScore</span><br><span class="line">res0: String = A</span><br><span class="line"></span><br><span class="line">scala&gt; s.getName</span><br><span class="line">res1: String = Tom</span><br></pre></td></tr></table></figure></p><p><br><br><strong>在子类中重写父类的方法</strong><br>Scala中，如果子类要覆盖一个父类中的非抽象方法，则必须使用override关键字。<br>在子类覆盖父类方法之后，如果在子类中要调用父类的被覆盖的方法，可以使用super关键字，显式地指定要调用父类的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    private var name = &quot;Tom&quot;</span><br><span class="line">    def getName = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    private var score = &quot;A&quot;</span><br><span class="line">    def getScore = score</span><br><span class="line">    override def getName = &quot;Hello,I&apos;m &quot; + super.getName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student</span><br><span class="line">s: Student = Student@3e74829</span><br><span class="line"></span><br><span class="line">scala&gt; s.getName</span><br><span class="line">res0: String = Hello,I&apos;m Tom</span><br></pre></td></tr></table></figure></p><p>Scala中，子类可以覆盖父类的val属性，而且还可以覆盖父类的val属性的getter方法，只要在子类中使用override关键字即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    val name:String = &quot;Person&quot;</span><br><span class="line">    def age:Int = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    override val name:String = &quot;Tom&quot;</span><br><span class="line">    override val age:Int = 21</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student</span><br><span class="line">s: Student = Student@6853425f</span><br><span class="line"></span><br><span class="line">scala&gt; s.name</span><br><span class="line">res0: String = Tom</span><br><span class="line"></span><br><span class="line">scala&gt; s.age</span><br><span class="line">res1: Int = 21</span><br></pre></td></tr></table></figure></p><p>跟java一样，Scala中同样可以使用protected关键字来修饰属性和方法，这样在子类中就不需要super关键字，直接就可以访问属性和方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    protected var name:String = &quot;Tom&quot;</span><br><span class="line">    protected var age:Int = 21</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    def sayHello = println(&quot;Hello,&quot; + name)</span><br><span class="line">    def ageCompare(s:Student)&#123;</span><br><span class="line">        println(&quot;I&apos;m &quot; + age + &quot; years old,you are &quot; + s.age + &quot;years old.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined class Student</span><br></pre></td></tr></table></figure></p><p>还可以使用protected[this]，表示只能在当前子类对象中访问父类的属性和方法，无法通过其他子类对象访问父类的属性和方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    protected var name:String = &quot;Tom&quot;</span><br><span class="line">    protected[this] var age:Int = 21</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    def sayHello = println(&quot;Hello,&quot; + name)</span><br><span class="line">    def ageCompare(s:Student)&#123;</span><br><span class="line">        println(&quot;I&apos;m &quot; + age + &quot; years old,you are &quot; + s.age + &quot;years old.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">&lt;console&gt;:21: error: value age is not a member of Student</span><br><span class="line">               println(&quot;I&apos;m &quot; + age + &quot; years old,you are &quot; + s.age + &quot;years old.&quot;)</span><br><span class="line">                                                                ^</span><br></pre></td></tr></table></figure></p><p><br><br><strong>匿名子类</strong><br>可以通过包含带有定义或重写的代码块的方式创建一个匿名子类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student(val name:String,val age:Int)&#123;</span><br><span class="line">     |     def sayHello() = &quot;Hello,my name is &quot; + name + &quot;,I&apos;m &quot; + age + &quot; years old.&quot;</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; var s:Student = new Student(&quot;Tom&quot;,21)&#123;</span><br><span class="line">     |     override def sayHello() = &quot;匿名子类中的sayHello方法&quot;</span><br><span class="line">     | &#125;</span><br><span class="line">s: Student = $anon$1@1115ec15</span><br><span class="line"></span><br><span class="line">scala&gt; println(s.sayHello())</span><br><span class="line">匿名子类中的sayHello方法</span><br></pre></td></tr></table></figure></p><p><br><br><strong>抽象类</strong><br>抽象类使用abstract关键字来标记，抽象类是不可以实例化的，只能用来继承。<br>在子类中覆盖抽象类的抽象方法时，不需要使用override关键字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">abstract class Person(val name:String)&#123;</span><br><span class="line">    def sayHello:Unit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student(name:String) extends Person(name)&#123;</span><br><span class="line">    def sayHello:Unit = println(&quot;Hello,my name is &quot; + name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student(&quot;Tom&quot;)</span><br><span class="line">s: Student = Student@571c5681</span><br><span class="line"></span><br><span class="line">scala&gt; s.sayHello</span><br><span class="line">Hello,my name is Tom</span><br></pre></td></tr></table></figure></p><p>object也可以继承抽象类，并覆盖抽象类中的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">abstract class Person(val name:String)&#123;</span><br><span class="line">    def sayHello(name:String):Unit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object Student extends Person(&quot;Tom&quot;)&#123;</span><br><span class="line">    override def sayHello(name:String)=&#123;</span><br><span class="line">        println(&quot;Hello,my name is &quot; + name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined object Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = Student</span><br><span class="line">s: Student.type = Student$@41294f8</span><br></pre></td></tr></table></figure></p><p><br><br><strong>抽象字段</strong><br>如果在父类中，定义了字段，但是没有给出初始值，则此字段为抽象字段。<br>抽象字段意味着，Scala会根据自己的规则，为var或val类型的字段生成对应的getter和setter方法，但是父类中是没有该字段的。<br>子类覆盖抽象字段，不需要使用override关键字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">abstract class Person&#123;</span><br><span class="line">    val name:String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    val name:String = &quot;Tom&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student</span><br><span class="line">s: Student = Student@53251a66</span><br><span class="line"></span><br><span class="line">scala&gt; s.name</span><br><span class="line">res0: String = Tom</span><br></pre></td></tr></table></figure></p><p><br><br><strong>类型判断</strong><br><strong>isInstanceOf和asInstanceOf</strong><br>如果创建了子类的对象，但是又将其赋予了父类类型的变量。则在后续的程序中，要将父类类型的变量转换为子类类型的变量，首先需要使用isInstanceOf判断对象是否是指定类的对象，如果是的话，则可以使用asInstanceOf将对象转换为指定类型。<br>如果对象是null，则isInstanceOf一定返回false，asInstanceOf一定返回null。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">class Student extends Person</span><br><span class="line">val p:Person = new Student</span><br><span class="line">var s:Student = null</span><br><span class="line">if(p.isInstanceOf[Student])  s = p.asInstanceOf[Student]</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined class Student</span><br><span class="line">p: Person = Student@3eb81efb</span><br><span class="line">s: Student = Student@3eb81efb</span><br></pre></td></tr></table></figure></p><p><strong>getClass和classOf</strong><br>isInstanceOf只能判断出对象是否是指定类以及子类的对象，而不能精确判断出对象就是指定类的对象<br>如果要求精确地判断对象就是指定类的对象，就只能使用getClass和classOf<br>对象.getClass可以精确获取对象的类，classOf[类]可以精确获取类，然后使用==操作符即可判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Person</span><br><span class="line">defined class Person</span><br><span class="line"></span><br><span class="line">scala&gt; class Student extends Person</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val p:Person = new Student</span><br><span class="line">p: Person = Student@3c01cfa1</span><br><span class="line"></span><br><span class="line">scala&gt; p.isInstanceOf[Person]</span><br><span class="line">res0: Boolean = true</span><br><span class="line"></span><br><span class="line">scala&gt; p.getClass == classOf[Person]</span><br><span class="line">res1: Boolean = false</span><br><span class="line"></span><br><span class="line">scala&gt; p.getClass == classOf[Student]</span><br><span class="line">res2: Boolean = true</span><br></pre></td></tr></table></figure></p><p><strong>使用模式匹配进行类型判断</strong><br>使用模式匹配，功能性上来说，与instanceOf一样，也是判断对象是否该类以及该类的子类的对象，不是精准判断的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">class Student extends Person</span><br><span class="line">val p:Person = new Student</span><br><span class="line">p match&#123;</span><br><span class="line">    case per:Person =&gt; println(&quot;It is Person&apos;s object.&quot;)</span><br><span class="line">    case _ =&gt; println(&quot;Unknown type.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">It is Person&apos;s object.</span><br><span class="line">defined class Person</span><br><span class="line">defined class Student</span><br><span class="line">p: Person = Student@2f40e5db</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;extends关键字实现继承&lt;/strong&gt;&lt;br&gt;Scala中，与Java一样，也是使用extends关键字让子类继承父类，使用继承可以有效地复用代码。&lt;br&gt;继承表示子类可以继承父类的属性和方法，子类可以在自己内部放入父类所没有而子类特有的属性和方法。&lt;br&gt;子类可以覆盖父类的属性和方法，但是如果父类用final修饰，属性和方法用final修饰，则该类是无法被继承的，即属性和方法是无法被覆盖。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala的apply方法</title>
    <link href="https://www.ggstu.com/2018/08/19/Scala%E7%9A%84apply%E6%96%B9%E6%B3%95/"/>
    <id>https://www.ggstu.com/2018/08/19/Scala的apply方法/</id>
    <published>2018-08-19T06:43:19.000Z</published>
    <updated>2018-08-19T14:19:53.025Z</updated>
    
    <content type="html"><![CDATA[<p>在Scala的object中，可以声明apply方法。<br>而使用”类名()”的形式，其实就是”类名.apply()”的一种缩写。通常使用这种方式来构造类的对象，而不是使用”new 类名()”的方式。<br>例如：”Hello World”(6)实际上就是”Hello World”.apply(6)的缩写。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; &quot;Hello World&quot;(6)</span><br><span class="line">res0: Char = W</span><br><span class="line"></span><br><span class="line">scala&gt; &quot;Hello World&quot;.apply(6)</span><br><span class="line">res1: Char = W</span><br></pre></td></tr></table></figure></p><p>例如：Array(1,2,3,4)，实际上是用Array object的apply()函数来创建Array类的实例，也就是一个数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; Array(1,2,3,4)</span><br><span class="line">res2: Array[Int] = Array(1, 2, 3, 4)</span><br><span class="line"></span><br><span class="line">scala&gt; Array.apply(1,2,3,4)</span><br><span class="line">res3: Array[Int] = Array(1, 2, 3, 4)</span><br></pre></td></tr></table></figure></p><p><br><br>通常在伴生对象中实现apply方法，在其中实现构造伴生类的对象的功能，此时创建对象可以省略new关键字<br>例如：定义自己的伴生类和伴生对象<br>此时创建对象由于省略了new关键字，就会在object中找对应的apply方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Student(val name:String)</span><br><span class="line"></span><br><span class="line">object Student&#123;</span><br><span class="line">    def apply(name:String) = new Student(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Student</span><br><span class="line">defined object Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = Student(&quot;Tom&quot;)</span><br><span class="line">s: Student = Student@7d286fb6</span><br></pre></td></tr></table></figure></p><p>如果没有apply方法，创建对象省略new关键字就会报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student(val name:String)</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student(&quot;Tom&quot;)</span><br><span class="line">s: Student = Student@4032d386</span><br><span class="line"></span><br><span class="line">scala&gt; val s1 = Student(&quot;Bob&quot;)</span><br><span class="line">&lt;console&gt;:11: error: not found: value Student</span><br><span class="line">       val s1 = Student(&quot;Bob&quot;)</span><br><span class="line">                ^</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Scala的object中，可以声明apply方法。&lt;br&gt;而使用”类名()”的形式，其实就是”类名.apply()”的一种缩写。通常使用这种方式来构造类的对象，而不是使用”new 类名()”的方式。&lt;br&gt;例如：”Hello World”(6)实际上就是”Hello World”.apply(6)的缩写。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala的object对象</title>
    <link href="https://www.ggstu.com/2018/08/19/Scala%E7%9A%84object%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.ggstu.com/2018/08/19/Scala的object对象/</id>
    <published>2018-08-19T05:59:59.000Z</published>
    <updated>2018-08-19T14:18:12.522Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Scala中的object对象</strong><br>在Scala中，没有提供静态的修饰符static，但是object对象下的成员都是静态的。<br>第一次调用object的方法时，就会执行object的构造函数，但是object不能定义接收参数的构造函数。<br>object的构造函数只会在其第一次被调用时执行一次，以后再次调用不会再执行构造函数。<br>object通常用于作为单例模式的实现，或者放class的静态成员。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; object Person&#123;</span><br><span class="line">     |     private var handNum = 2</span><br><span class="line">     |     def getHandNum = handNum</span><br><span class="line">     | &#125;</span><br><span class="line">defined object Person</span><br></pre></td></tr></table></figure></p><p><br><br><strong>伴生类和伴生对象</strong><br>如果有一个class，还有一个与class同名的object，那么就称这个object是class的伴生对象，class是object的伴生类。<br>伴生类和伴生对象必须存放在一个.scala文件中。<br>伴生类和伴生对象可以互相访问其私有成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">object Person&#123;</span><br><span class="line">    private val handNum = 2</span><br><span class="line">    def getHandNum = handNum</span><br><span class="line">&#125;</span><br><span class="line">class Person(val name:String,val age:Int)&#123;</span><br><span class="line">    def sayHello = println(&quot;Hello,my name is &quot; + name + &quot;.I&apos;m &quot; + age + &quot; years old and I have &quot; + Person.handNum + &quot; hands.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined object Person</span><br><span class="line">defined class Person</span><br><span class="line"></span><br><span class="line">scala&gt; val p = new Person(&quot;Tom&quot;,21)</span><br><span class="line">p: Person = Person@2df6226d</span><br><span class="line"></span><br><span class="line">scala&gt; p.sayHello</span><br><span class="line">Hello,my name is Tom.I&apos;m 21 years old and I have 2 hands.</span><br></pre></td></tr></table></figure></p><p><br><br><strong>main方法</strong><br>在scala中，如果要运行一个应用程序，那么必须有一个main方法作为入口。<br>scala中的main方法定义为def main(args:Array[String])，而且必须定义在object中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; object HelloWorld&#123;</span><br><span class="line">     |     def main(args:Array[String])&#123;</span><br><span class="line">     |         println(&quot;Hello World!&quot;)</span><br><span class="line">     |     &#125;</span><br><span class="line">     | &#125;</span><br><span class="line">defined object HelloWorld</span><br></pre></td></tr></table></figure></p><p>除了自己实现main方法外，还可以继承App Trait，然后将需要在main方法中运行的代码，直接作为object的构造函数代码，而且可以用args接收传入的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; object HelloWorld extends App&#123;</span><br><span class="line">     |     if(args.length &gt; 0) println(&quot;Hello,&quot; + args(0))</span><br><span class="line">     |     else println(&quot;Hello World!&quot;)</span><br><span class="line">     | &#125;</span><br><span class="line">defined object HelloWorld</span><br></pre></td></tr></table></figure></p><p>App Trait的工作原理：App Trait继承自DelayedInit Trait，scalac命令进行编译时，会把继承App Trait的object的构造函数代码都放到DelayedInit Trait的DelayedInit方法中执行。<br><br><br><strong>用object来实现枚举功能</strong><br>Scala没有类似于Java中的Enum这样的枚举特性，如果要实现枚举，需要使用object继承Enumeration类，并且调用Value方法来初始化枚举值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; object Season extends Enumeration&#123;</span><br><span class="line">     |     val SPRING,SUMMER,AUTUMN,WINTER = Value</span><br><span class="line">     | &#125;</span><br><span class="line">defined object Season</span><br></pre></td></tr></table></figure></p><p>还可以通过Value传入枚举值的id和name，通过id和toString可以获取值，还可以通过id和name来查找枚举值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; object Season extends Enumeration&#123;</span><br><span class="line">     |     val SPRING = Value(0,&quot;spring&quot;)</span><br><span class="line">     |     val SUMMER = Value(1,&quot;summer&quot;)</span><br><span class="line">     |     val AUTUMN = Value(2,&quot;autumn&quot;)</span><br><span class="line">     |     val WINTER = Value(3,&quot;winter&quot;)</span><br><span class="line">     | &#125;</span><br><span class="line">defined object Season</span><br><span class="line"></span><br><span class="line">scala&gt; Season.SPRING.id</span><br><span class="line">res0: Int = 0</span><br><span class="line"></span><br><span class="line">scala&gt; Season.SPRING.toString</span><br><span class="line">res1: String = spring</span><br><span class="line"></span><br><span class="line">scala&gt; Season(0)</span><br><span class="line">res2: Season.Value = spring</span><br><span class="line"></span><br><span class="line">scala&gt; Season.withName(&quot;spring&quot;)</span><br><span class="line">res3: Season.Value = spring</span><br></pre></td></tr></table></figure></p><p>使用枚举object.values可以遍历枚举值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; for(ele &lt;- Season.values) println(ele)</span><br><span class="line">spring</span><br><span class="line">summer</span><br><span class="line">autumn</span><br><span class="line">winter</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Scala中的object对象&lt;/strong&gt;&lt;br&gt;在Scala中，没有提供静态的修饰符static，但是object对象下的成员都是静态的。&lt;br&gt;第一次调用object的方法时，就会执行object的构造函数，但是object不能定义接收参数的构造函数。&lt;br&gt;object的构造函数只会在其第一次被调用时执行一次，以后再次调用不会再执行构造函数。&lt;br&gt;object通常用于作为单例模式的实现，或者放class的静态成员。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>老街</title>
    <link href="https://www.ggstu.com/2018/08/18/%E8%80%81%E8%A1%97/"/>
    <id>https://www.ggstu.com/2018/08/18/老街/</id>
    <published>2018-08-18T14:09:27.000Z</published>
    <updated>2018-08-19T07:20:46.724Z</updated>
    
    <content type="html"><![CDATA[<p><em>一张褪色的照片</em><br><em>好像带给我一点点怀念</em><br><em>巷尾老爷爷卖的热汤面</em><br><em>味道弥漫过旧旧的后院</em><br><em>流浪猫睡熟在摇晃秋千</em><br><a id="more"></a><br><em>夕阳照了一遍他眯着眼</em><br><em>那张同桌寄的明信片</em><br><em>安静的躺在课桌的里面</em><br><em>快要过完的春天</em><br><em>还有雕刻着图案的门帘</em><br><em>窄窄的长长的过道两边</em><br><em>老房子依然升起了炊烟</em><br><em>刚刚下完了小雨的季节</em><br><em>爸妈又一起走过的老街</em><br><em>记不得哪年的哪一天</em><br><em>很漫长又很短暂的岁月</em><br><em>现在已经回不去</em><br><em>早已流逝的光阴</em><br><em>手里的那一张渐渐模糊不清的车票</em><br><em>成了回忆的信号</em><br><em>忘不掉的是什么我也不知道</em><br><em>想不起当年模样</em><br><em>看也看不到</em> <em>去也去不了的地方</em><br><em>也许那老街的腔调是属于我的忧伤</em><br><em>嘴角那点微笑越来越勉强</em></p><p><em>忘不掉的是什么我也不知道</em><br><em>放不下熟悉片段</em><br><em>回头望一眼</em> <em>已经很多年的时间</em><br><em>透过手指间看着天</em><br><em>我又回到那老街</em><br><em>靠在你们身边渐行渐远</em></p><p><em>快要过完的春天</em><br><em>还有雕刻着图案的门帘</em><br><em>窄窄的长长的过道两边</em><br><em>老房子依然升起了炊烟</em><br><em>刚刚下完了小雨的季节</em><br><em>爸妈又一起走过的老街</em><br><em>记不得哪年的哪一天</em><br><em>很漫长又很短暂的岁月</em><br><em>现在已经回不去</em><br><em>早已流逝的光阴</em><br><em>手里的那一张渐渐模糊不清的车票</em><br><em>成了回忆的信号</em><br><em>忘不掉的是什么我也不知道</em><br><em>想不起当年模样</em><br><em>看也看不到</em> <em>去也去不了的地方</em><br><em>也许那老街的腔调是属于我的忧伤</em><br><em>嘴角那点微笑越来越勉强</em><br><em>忘不掉的是什么我也不知道</em><br><em>放不下熟悉片段</em><br><em>回头望一眼</em> <em>已经很多年的时间</em><br><em>透过手指间看着天</em><br><em>我又回到那老街</em><br><em>靠在你们身边渐行渐远</em></p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=133998&auto=1&height=66"></iframe><br><img src="http://pd8lpasbc.bkt.clouddn.com/%E5%A4%AB%E5%AD%90%E5%BA%991.jpg" width="60%" height="60%">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;一张褪色的照片&lt;/em&gt;&lt;br&gt;&lt;em&gt;好像带给我一点点怀念&lt;/em&gt;&lt;br&gt;&lt;em&gt;巷尾老爷爷卖的热汤面&lt;/em&gt;&lt;br&gt;&lt;em&gt;味道弥漫过旧旧的后院&lt;/em&gt;&lt;br&gt;&lt;em&gt;流浪猫睡熟在摇晃秋千&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="随便说说" scheme="https://www.ggstu.com/categories/%E9%9A%8F%E4%BE%BF%E8%AF%B4%E8%AF%B4/"/>
    
    
      <category term="心情" scheme="https://www.ggstu.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>Scala的类和对象</title>
    <link href="https://www.ggstu.com/2018/08/18/Scala%E7%9A%84%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.ggstu.com/2018/08/18/Scala的类和对象/</id>
    <published>2018-08-18T09:33:16.000Z</published>
    <updated>2018-08-19T14:00:40.823Z</updated>
    
    <content type="html"><![CDATA[<p>类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。<br><strong>创建类和对象</strong><br>例如：定义一个类，包含属性和方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Hello&#123;</span><br><span class="line">     |     private var name = &quot;Tom&quot;</span><br><span class="line">     |     def sayHello()&#123;println(&quot;Hello,my name is &quot; + name)&#125;</span><br><span class="line">     |     def getName = name</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Hello</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>创建类的对象，并调用其方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val s = new Hello</span><br><span class="line">s: Hello = Hello@3eb81efb</span><br><span class="line"></span><br><span class="line">scala&gt; s.sayHello()</span><br><span class="line">Hello,my name is Tom</span><br><span class="line"></span><br><span class="line">scala&gt; print(s.getName)</span><br><span class="line">Tom</span><br></pre></td></tr></table></figure></p><p><br><br><strong>属性的getter和setter方法</strong><br>当定义属性是var的时候，scala会自动为其生成对应的getter和setter方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student&#123;</span><br><span class="line">     |     var name = &quot;Tom&quot;</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br></pre></td></tr></table></figure></p><p>调用getter方法：name<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val t = new Student</span><br><span class="line">t: Student = Student@31920ade</span><br><span class="line"></span><br><span class="line">scala&gt; t.name</span><br><span class="line">res0: String = Tom</span><br></pre></td></tr></table></figure></p><p>调用setter方法：name_=<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; t.name = &quot;Bob&quot;</span><br><span class="line">t.name: String = Bob</span><br><span class="line"></span><br><span class="line">scala&gt; t.name</span><br><span class="line">res2: String = Bob</span><br></pre></td></tr></table></figure></p><p><br><br>当定义属性是val的时候，则只会生成getter方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student&#123;</span><br><span class="line">     |     val name = &quot;Tom&quot;</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br></pre></td></tr></table></figure></p><p>调用getter方法：name<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val t = new Student</span><br><span class="line">t: Student = Student@6cdba6dc</span><br><span class="line"></span><br><span class="line">scala&gt; t.name</span><br><span class="line">res0: String = Tom</span><br></pre></td></tr></table></figure></p><p>调用setter方法时出错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; t.name = &quot;Bob&quot;</span><br><span class="line">&lt;console&gt;:13: error: reassignment to val</span><br><span class="line">       t.name = &quot;Bob&quot;</span><br><span class="line">              ^</span><br></pre></td></tr></table></figure></p><p><br><br>当定义的属性是private的时候，则生成的getter和setter方法也是private的，即无法调用getter和setter方法，其只能在类中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student&#123;</span><br><span class="line">     |     private var name = &quot;Tom&quot;</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val t = new Student</span><br><span class="line">t: Student = Student@31920ade</span><br><span class="line"></span><br><span class="line">scala&gt; t.name</span><br><span class="line">&lt;console&gt;:14: error: variable name in class Student cannot be accessed in Student</span><br><span class="line">       t.name</span><br><span class="line">         ^</span><br><span class="line"></span><br><span class="line">scala&gt; t.name = &quot;Bob&quot;</span><br><span class="line">&lt;console&gt;:15: error: variable name in class Student cannot be accessed in Student</span><br><span class="line">val $ires0 = t.name</span><br><span class="line">               ^</span><br><span class="line">&lt;console&gt;:13: error: variable name in class Student cannot be accessed in Student</span><br><span class="line">       t.name = &quot;Bob&quot;</span><br><span class="line">         ^</span><br></pre></td></tr></table></figure></p><p>如果不希望生成getter和setter方法，则将属性声明为private[this]，表示该属性只属于该对象私有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student&#123;</span><br><span class="line">     |     private[this] var name = &quot;Tom&quot;</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val t = new Student</span><br><span class="line">t: Student = Student@1205bd62</span><br><span class="line"></span><br><span class="line">scala&gt; t.name</span><br><span class="line">&lt;console&gt;:14: error: value name is not a member of Student</span><br><span class="line">       t.name</span><br><span class="line">         ^</span><br><span class="line"></span><br><span class="line">scala&gt; t.name = &quot;Bob&quot;</span><br><span class="line">&lt;console&gt;:15: error: value name is not a member of Student</span><br><span class="line">val $ires0 = t.name</span><br><span class="line">               ^</span><br><span class="line">&lt;console&gt;:13: error: value name is not a member of Student</span><br><span class="line">       t.name = &quot;Bob&quot;</span><br><span class="line">         ^</span><br></pre></td></tr></table></figure></p><p><br><br>自定义getter和setter<br>可以根据需求为属性选择合适的修饰符：var、val、private、private[this]，进而来选择getter和setter方法<br>也可以自定义getter与setter方法对其进行控制<br>自定义setter方法的时候一定要注意scala的语法限制，属性_、=、参数间不能有空格<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student&#123;</span><br><span class="line">     |     private var myName = &quot;Tom&quot;</span><br><span class="line">     |     def name = &quot;My name is &quot; + myName</span><br><span class="line">     |     def name_=(newName:String)&#123;</span><br><span class="line">     |         println(&quot;Cannot change your name.&quot;)</span><br><span class="line">     |     &#125;</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val t = new Student</span><br><span class="line">t: Student = Student@5cdec700</span><br><span class="line"></span><br><span class="line">scala&gt; t.name</span><br><span class="line">res0: String = My name is Tom</span><br><span class="line"></span><br><span class="line">scala&gt; t.name = &quot;Bob&quot;</span><br><span class="line">Cannot change your name.</span><br><span class="line">t.name: String = My name is Tom</span><br></pre></td></tr></table></figure></p><p><br><br>设置属性只有getter方法<br>如果不希望属性有setter方法，可以将其定义为val，但是此时再也不能更改属性的值了<br>但是如果希望属性只有一个getter方法，并且能够更改属性的值，那么需要综合使用private以及自定义getter方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student&#123;</span><br><span class="line">     |     private var myName = &quot;Tom&quot;</span><br><span class="line">     |     def updateName(newName:String)&#123;</span><br><span class="line">     |         if(newName == &quot;Bob&quot;) myName = newName</span><br><span class="line">     |         else print(&quot;Cannot change your name.&quot;)</span><br><span class="line">     |     &#125;</span><br><span class="line">     |     def name = &quot;My name is &quot; + myName</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val t = new Student</span><br><span class="line">t: Student = Student@662706a7</span><br><span class="line"></span><br><span class="line">scala&gt; t.name</span><br><span class="line">res0: String = My name is Tom</span><br><span class="line"></span><br><span class="line">scala&gt; t.name = &quot;Bob&quot;</span><br><span class="line">&lt;console&gt;:13: error: value name_= is not a member of Student</span><br><span class="line">       t.name = &quot;Bob&quot;</span><br><span class="line">         ^</span><br><span class="line"></span><br><span class="line">scala&gt; t.updateName(&quot;Bob&quot;)</span><br><span class="line"></span><br><span class="line">scala&gt; t.name</span><br><span class="line">res2: String = My name is Bob</span><br><span class="line"></span><br><span class="line">scala&gt; t.updateName(&quot;Alice&quot;)</span><br><span class="line">Cannot change your name.</span><br></pre></td></tr></table></figure></p><p><br><br><strong>类的构造器</strong><br>类的构造器分为：主构造器、辅助构造器<br>Scala中，主构造器是与类名放在一起的，与java不同，并且只能有一个主构造器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student(val name:String,val age:Int)&#123;</span><br><span class="line">     |     println(&quot;Hello,my name is &quot; + name + &quot;,I&apos;m &quot; + age + &quot; years old.&quot;)</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student(&quot;Bob&quot;,18)</span><br><span class="line">Hello,my name is Bob,I&apos;m 18 years old.</span><br><span class="line">s: Student = Student@7a67e3c6</span><br></pre></td></tr></table></figure></p><p>主构造器还可以使用默认参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student(val name:String = &quot;Tom&quot;,val age:Int = 21)&#123;</span><br><span class="line">     |     println(&quot;Hello,my name is &quot; + name + &quot;,I&apos;m &quot; + age + &quot; years old.&quot;)</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student()</span><br><span class="line">Hello,my name is Tom,I&apos;m 21 years old.</span><br><span class="line">s: Student = Student@421bba99</span><br></pre></td></tr></table></figure></p><p>Scala中，可以给类定义多个辅助构造器，通过关键字this来实现<br>辅助构造器之间可以互相调用，而且必须第一行调用主构造器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Student&#123;</span><br><span class="line">    private var name = &quot;&quot;</span><br><span class="line">    private var age = 0</span><br><span class="line">    def this(name:String)&#123;</span><br><span class="line">        this()</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    def this(name:String,age:Int)&#123;</span><br><span class="line">        this(name)</span><br><span class="line">        this.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Student</span><br></pre></td></tr></table></figure></p><p><br><br><strong>内部类</strong><br>Scala中，同样可以在类中定义内部类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.collection.mutable.ArrayBuffer</span><br><span class="line">import scala.collection.mutable.ArrayBuffer</span><br><span class="line"></span><br><span class="line">scala&gt; class Class&#123;</span><br><span class="line">     |     class Student(val name:String)&#123;&#125;</span><br><span class="line">     |     val students = new ArrayBuffer[Student]</span><br><span class="line">     |     def getStudent(name:String) = &#123;</span><br><span class="line">     |         new Student(name)</span><br><span class="line">     |     &#125;</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Class</span><br><span class="line"></span><br><span class="line">scala&gt; val c = new Class</span><br><span class="line">c: Class = Class@1e287667</span><br><span class="line"></span><br><span class="line">scala&gt; val s = c.getStudent(&quot;Tom&quot;)</span><br><span class="line">s: c.Student = Class$Student@1e34c607</span><br><span class="line"></span><br><span class="line">scala&gt; c.students += s</span><br><span class="line">res0: c.students.type = ArrayBuffer(Class$Student@1e34c607)</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。&lt;br&gt;&lt;strong&gt;创建类和对象&lt;/strong&gt;&lt;br&gt;例如：定义一个类，包含属性和方法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scala&amp;gt; class Hello&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     |     private var name = &amp;quot;Tom&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     |     def sayHello()&amp;#123;println(&amp;quot;Hello,my name is &amp;quot; + name)&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     |     def getName = name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     | &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;defined class Hello&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala中的元祖</title>
    <link href="https://www.ggstu.com/2018/08/18/Scala%E4%B8%AD%E7%9A%84%E5%85%83%E7%A5%96/"/>
    <id>https://www.ggstu.com/2018/08/18/Scala中的元祖/</id>
    <published>2018-08-18T08:47:10.000Z</published>
    <updated>2018-08-18T09:20:16.600Z</updated>
    
    <content type="html"><![CDATA[<p>元祖是不同类型的值的集合<br>元祖的值是通过将单个的值包含在括号中构成的<br><strong>元祖的定义</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val t1 = (&quot;Tom&quot;,21,85.5)</span><br><span class="line">t1: (String, Int, Double) = (Tom,21,85.5)</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>以上的实例在元素中定义了三个元素，类型为Tuple3[java.lang.String,Int,Double]<br>这里Tuple是类型，3表示元祖中有三个元素<br>也可以使用下面的方式来定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val t2 = new Tuple3(&quot;Tom&quot;,21,85.5)</span><br><span class="line">t2: (String, Int, Double) = (Tom,21,85.5)</span><br></pre></td></tr></table></figure></p><p><br><br><strong>元祖的访问</strong><br>使用t._1访问第一个元素,t._2访问第二个元素，访问后面的元素依次类推<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val t3 = new Tuple4(&quot;Tom&quot;,21,85.5,true)</span><br><span class="line">t3: (String, Int, Double, Boolean) = (Tom,21,85.5,true)</span><br><span class="line"></span><br><span class="line">scala&gt; t3._1</span><br><span class="line">res0: String = Tom</span><br><span class="line"></span><br><span class="line">scala&gt; t3._2</span><br><span class="line">res1: Int = 21</span><br><span class="line"></span><br><span class="line">scala&gt; t3._3</span><br><span class="line">res2: Double = 85.5</span><br><span class="line"></span><br><span class="line">scala&gt; t3._4</span><br><span class="line">res3: Boolean = true</span><br></pre></td></tr></table></figure></p><p><br><br><strong>元祖的遍历</strong><br>使用Tuple.productIterator()方法来遍历元组的所有元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val t = (&quot;Tom&quot;,21,85.5)</span><br><span class="line">t: (String, Int, Double) = (Tom,21,85.5)</span><br><span class="line"></span><br><span class="line">scala&gt; t.productIterator.foreach(println)</span><br><span class="line">Tom</span><br><span class="line">21</span><br><span class="line">85.5</span><br></pre></td></tr></table></figure></p><p><font color="#f00">注意：</font>要遍历Tuple中的元素，首先要生成对应的迭代器，不能直接使用for或者foreach。<br><br><br><strong>元组转换成字符串</strong><br>使用Tuple.toString()方法将元组的所有元素组合成一个字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; t.toString</span><br><span class="line">res1: String = (Tom,21,85.5)</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;元祖是不同类型的值的集合&lt;br&gt;元祖的值是通过将单个的值包含在括号中构成的&lt;br&gt;&lt;strong&gt;元祖的定义&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scala&amp;gt; val t1 = (&amp;quot;Tom&amp;quot;,21,85.5)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;t1: (String, Int, Double) = (Tom,21,85.5)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>七夕的南京刮起了台风</title>
    <link href="https://www.ggstu.com/2018/08/17/%E4%B8%83%E5%A4%95%E7%9A%84%E5%8D%97%E4%BA%AC%E5%88%AE%E8%B5%B7%E4%BA%86%E5%8F%B0%E9%A3%8E/"/>
    <id>https://www.ggstu.com/2018/08/17/七夕的南京刮起了台风/</id>
    <published>2018-08-17T05:02:39.000Z</published>
    <updated>2018-08-17T13:48:55.361Z</updated>
    
    <content type="html"><![CDATA[<p>走进这汹涌的台风中<br>带着少年慌乱的脚步<br>带着藏匿在心底的不合时宜<br><a id="more"></a></p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=26508232&auto=1&height=66"></iframe><br><em><br>这次你离开了没有像以前那样说再见，再见也他M的只是再见<br>我们之间从来没有想象的那么接近，只是两棵树的距离<br>你是否还记得山阴路我八楼的房间，房间里唱歌的日日夜夜<br>那么热的夏天你看着外面，看着你在消逝的容颜<br>多么想念你走在我身边的样子，想起来我的爱就不能停止<br>南京的雨不停地下不停地下，就像你沉默的委屈<br>一转眼，我们的城市又到了夏天，对面走来的人都眯着眼<br>人们不敢说话不敢停下脚步，因为心动常常带来危险<br>我多么想念你走在我身边的样子，想起来我的爱就不能停止<br>南京的雨不停地下不停地下，有些人却注定要相遇<br>你是一片光荣的叶子落在我卑贱的心<br>像往常一样我为自己生气并且歌唱<br>那么乏力，爱也吹不动的叶子</em><br><img src="http://pd8lpasbc.bkt.clouddn.com/%E5%8F%B0%E9%A3%8E1.jpg" width="50%" height="50%"><br><img src="http://pd8lpasbc.bkt.clouddn.com/%E5%8F%B0%E9%A3%8E2.jpg" width="50%" height="50%"><br><img src="http://pd8lpasbc.bkt.clouddn.com/%E5%8F%B0%E9%A3%8E3.jpg" width="50%" height="50%"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;走进这汹涌的台风中&lt;br&gt;带着少年慌乱的脚步&lt;br&gt;带着藏匿在心底的不合时宜&lt;br&gt;
    
    </summary>
    
      <category term="随便说说" scheme="https://www.ggstu.com/categories/%E9%9A%8F%E4%BE%BF%E8%AF%B4%E8%AF%B4/"/>
    
    
      <category term="心情" scheme="https://www.ggstu.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>Scala的Map映射</title>
    <link href="https://www.ggstu.com/2018/08/17/Scala%E7%9A%84Map%E6%98%A0%E5%B0%84/"/>
    <id>https://www.ggstu.com/2018/08/17/Scala的Map映射/</id>
    <published>2018-08-17T02:24:20.000Z</published>
    <updated>2018-08-17T03:12:32.840Z</updated>
    
    <content type="html"><![CDATA[<p>Map(映射)是一种可迭代的键值对（key/value）结构，使用操作符”-&gt;”来创建。<br>Map中的键都是唯一的，所有的值都可以通过键来获取。<br>Map有两种类型，可变与不可变，区别在于可变集合的元素可以修改，不可变集合不可以修改。<br>默认情况下 Scala 使用不可变 Map。<br>如果需要使用可变集合，要显式的引入 import scala.collection.mutable.Map 类<br><a id="more"></a><br><strong>创建Map：</strong><br><strong>创建一个不可变的Map</strong><br>不可变的Map中元素不能修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val scores = Map(&quot;Tom&quot; -&gt; 75,&quot;Bob&quot; -&gt; 92,&quot;Alice&quot; -&gt; 85)</span><br><span class="line">scores: scala.collection.immutable.Map[String,Int] = Map(Tom -&gt; 75, Bob -&gt; 92, Alice -&gt; 85)</span><br><span class="line"></span><br><span class="line">scala&gt; scores(&quot;Tom&quot;) = 80</span><br><span class="line">&lt;console&gt;:13: error: value update is not a member of scala.collection.immutable.Map[String,Int]</span><br><span class="line">       scores(&quot;Tom&quot;) = 80</span><br><span class="line">       ^</span><br></pre></td></tr></table></figure></p><p><strong>创建一个可变的Map</strong><br>可变的Map中元素可以修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val scores = scala.collection.mutable.Map(&quot;Tom&quot; -&gt; 75,&quot;Bob&quot; -&gt; 92,&quot;Alice&quot; -&gt; 85)</span><br><span class="line">scores: scala.collection.mutable.Map[String,Int] = Map(Bob -&gt; 92, Tom -&gt; 75, Alice -&gt; 85)</span><br><span class="line"></span><br><span class="line">scala&gt; scores(&quot;Tom&quot;) = 80</span><br><span class="line"></span><br><span class="line">scala&gt; scores</span><br><span class="line">res2: scala.collection.mutable.Map[String,Int] = Map(Bob -&gt; 92, Tom -&gt; 80, Alice -&gt; 85)</span><br></pre></td></tr></table></figure></p><p><strong>使用另外一种方式创建Map</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val scores = Map((&quot;Tom&quot;,75), (&quot;Bob&quot;,92), (&quot;Alice&quot;,85))</span><br><span class="line">scores: scala.collection.immutable.Map[String,Int] = Map(Tom -&gt; 75, Bob -&gt; 92, Alice -&gt; 85)</span><br></pre></td></tr></table></figure></p><p><strong>创建一个空的HashMap</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val scores = new scala.collection.mutable.HashMap[String, Int]</span><br><span class="line">scores: scala.collection.mutable.HashMap[String,Int] = Map()</span><br></pre></td></tr></table></figure></p><p><br><br><strong>访问Map的元素：</strong><br><strong>获取指定key对应的value，如果key不存在，会报错</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val scores = Map(&quot;Tom&quot; -&gt; 75,&quot;Bob&quot; -&gt; 92,&quot;Alice&quot; -&gt; 85)</span><br><span class="line">scores: scala.collection.immutable.Map[String,Int] = Map(Tom -&gt; 75, Bob -&gt; 92, Alice -&gt; 85)</span><br><span class="line"></span><br><span class="line">scala&gt; val score = scores(&quot;Tom&quot;)</span><br><span class="line">score: Int = 75</span><br><span class="line"></span><br><span class="line">scala&gt; val score = scores(&quot;Jack&quot;)</span><br><span class="line">java.util.NoSuchElementException: key not found: Jack</span><br><span class="line">  at scala.collection.MapLike$class.default(MapLike.scala:228)</span><br><span class="line">  at scala.collection.AbstractMap.default(Map.scala:59)</span><br><span class="line">  at scala.collection.MapLike$class.apply(MapLike.scala:141)</span><br><span class="line">  at scala.collection.AbstractMap.apply(Map.scala:59)</span><br><span class="line">  ... 32 elided</span><br></pre></td></tr></table></figure></p><p><strong>使用contains函数检查key是否存在</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val score = if(scores.contains(&quot;Tom&quot;)) scores(&quot;Tom&quot;) else 0</span><br><span class="line">score: Int = 75</span><br><span class="line"></span><br><span class="line">scala&gt; val score = if(scores.contains(&quot;Jack&quot;)) scores(&quot;Jack&quot;) else 0</span><br><span class="line">score: Int = 0</span><br></pre></td></tr></table></figure></p><p><strong>使用getOrElse函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val score = scores.getOrElse(&quot;Tom&quot;, 0)</span><br><span class="line">score: Int = 75</span><br><span class="line"></span><br><span class="line">scala&gt; val score = scores.getOrElse(&quot;Jack&quot;, 0)</span><br><span class="line">score: Int = 0</span><br></pre></td></tr></table></figure></p><p><br><br><strong>修改Map的元素（必须是可变Map）：</strong><br>更新Map的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val scores = scala.collection.mutable.Map(&quot;Tom&quot; -&gt; 75,&quot;Bob&quot; -&gt; 92,&quot;Alice&quot; -&gt; 85)</span><br><span class="line">scores: scala.collection.mutable.Map[String,Int] = Map(Bob -&gt; 92, Tom -&gt; 75, Alice -&gt; 85)</span><br><span class="line"></span><br><span class="line">scala&gt; scores(&quot;Tom&quot;) = 80</span><br><span class="line"></span><br><span class="line">scala&gt; scores</span><br><span class="line">res1: scala.collection.mutable.Map[String,Int] = Map(Bob -&gt; 92, Tom -&gt; 80, Alice -&gt; 85)</span><br></pre></td></tr></table></figure></p><p>增加多个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; scores += (&quot;Jack&quot; -&gt; 100,&quot;Jerry&quot; -&gt; 60)</span><br><span class="line">res2: scores.type = Map(Bob -&gt; 92, Jerry -&gt; 60, Jack -&gt; 100, Tom -&gt; 80, Alice -&gt; 85)</span><br></pre></td></tr></table></figure></p><p>移除元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; scores -= &quot;Bob&quot;</span><br><span class="line">res3: scores.type = Map(Jerry -&gt; 60, Jack -&gt; 100, Tom -&gt; 80, Alice -&gt; 85)</span><br></pre></td></tr></table></figure></p><p>对于不可变的Map，不可以修改它的元素，但是可以将它的元素做改变后赋予其它变量<br>如下所示，将集合scores增加或移除元素后赋予新的集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val scores = Map(&quot;Tom&quot; -&gt; 75,&quot;Bob&quot; -&gt; 92,&quot;Alice&quot; -&gt; 85)</span><br><span class="line">scores: scala.collection.immutable.Map[String,Int] = Map(Tom -&gt; 75, Bob -&gt; 92, Alice -&gt; 85)</span><br><span class="line"></span><br><span class="line">scala&gt; scores += (&quot;Jack&quot; -&gt; 100,&quot;Jerry&quot; -&gt; 60)</span><br><span class="line">&lt;console&gt;:13: error: value += is not a member of scala.collection.immutable.Map[String,Int]</span><br><span class="line">       scores += (&quot;Jack&quot; -&gt; 100,&quot;Jerry&quot; -&gt; 60)</span><br><span class="line">              ^</span><br><span class="line"></span><br><span class="line">scala&gt; val scores2 = scores + (&quot;Jack&quot; -&gt; 100,&quot;Jerry&quot; -&gt; 60)</span><br><span class="line">scores2: scala.collection.immutable.Map[String,Int] = Map(Tom -&gt; 75, Jerry -&gt; 60, Bob -&gt; 92, Jack -&gt; 100, Alice -&gt; 85)</span><br><span class="line"></span><br><span class="line">scala&gt; val score3 = scores - &quot;Bob&quot;</span><br><span class="line">score3: scala.collection.immutable.Map[String,Int] = Map(Tom -&gt; 75, Alice -&gt; 85)</span><br></pre></td></tr></table></figure></p><p><br><br><strong>遍历Map的元素：</strong><br>遍历map的entrySet<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val scores = Map(&quot;Tom&quot; -&gt; 75,&quot;Bob&quot; -&gt; 92,&quot;Alice&quot; -&gt; 85)</span><br><span class="line">scores: scala.collection.immutable.Map[String,Int] = Map(Tom -&gt; 75, Bob -&gt; 92, Alice -&gt; 85)</span><br><span class="line"></span><br><span class="line">scala&gt; for((key,value) &lt;- scores) println(key + &quot;: &quot; + value)</span><br><span class="line">Tom: 75</span><br><span class="line">Bob: 92</span><br><span class="line">Alice: 85</span><br></pre></td></tr></table></figure></p><p>遍历Map：使用for或者foreach<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; for(s &lt;- scores) println(s)</span><br><span class="line">(Tom,75)</span><br><span class="line">(Bob,92)</span><br><span class="line">(Alice,85)</span><br><span class="line"></span><br><span class="line">scala&gt; scores.foreach(println)</span><br><span class="line">(Tom,75)</span><br><span class="line">(Bob,92)</span><br><span class="line">(Alice,85)</span><br></pre></td></tr></table></figure></p><p>遍历map的key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; for(key &lt;- scores.keySet) println(key)</span><br><span class="line">Tom</span><br><span class="line">Bob</span><br><span class="line">Alice</span><br></pre></td></tr></table></figure></p><p>遍历map的value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; for(value &lt;- scores.values) println(value)</span><br><span class="line">75</span><br><span class="line">92</span><br><span class="line">85</span><br></pre></td></tr></table></figure></p><p>生成新map，反转key和value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; for((key,value) &lt;- scores) yield (value,key)</span><br><span class="line">res3: scala.collection.immutable.Map[Int,String] = Map(75 -&gt; Tom, 92 -&gt; Bob, 85 -&gt; Alice)</span><br></pre></td></tr></table></figure></p><p><br><br><strong>SortedMap和LinkedHashMap：</strong><br>SortedMap可以自动对Map的key排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val scores1 = Map(&quot;Tom&quot; -&gt; 75,&quot;Bob&quot; -&gt; 92,&quot;Alice&quot; -&gt; 85)</span><br><span class="line">scores1: scala.collection.immutable.Map[String,Int] = Map(Tom -&gt; 75, Bob -&gt; 92, Alice -&gt; 85)</span><br><span class="line"></span><br><span class="line">scala&gt; val scores2 = scala.collection.immutable.SortedMap(&quot;Tom&quot; -&gt; 75,&quot;Bob&quot; -&gt; 92,&quot;Alice&quot; -&gt; 85)</span><br><span class="line">scores2: scala.collection.immutable.SortedMap[String,Int] = Map(Alice -&gt; 85, Bob -&gt; 92, Tom -&gt; 75)</span><br></pre></td></tr></table></figure></p><p>LinkedHashMap可以记住插入的顺序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val scores = new scala.collection.mutable.LinkedHashMap[String,Int]</span><br><span class="line">scores: scala.collection.mutable.LinkedHashMap[String,Int] = Map()</span><br><span class="line"></span><br><span class="line">scala&gt; scores(&quot;Alice&quot;) = 85</span><br><span class="line"></span><br><span class="line">scala&gt; scores(&quot;Tom&quot;) = 75</span><br><span class="line"></span><br><span class="line">scala&gt; scores(&quot;Bob&quot;) = 92</span><br><span class="line"></span><br><span class="line">scala&gt; scores</span><br><span class="line">res3: scala.collection.mutable.LinkedHashMap[String,Int] = Map(Alice -&gt; 85, Tom -&gt; 75, Bob -&gt; 92)</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Map(映射)是一种可迭代的键值对（key/value）结构，使用操作符”-&amp;gt;”来创建。&lt;br&gt;Map中的键都是唯一的，所有的值都可以通过键来获取。&lt;br&gt;Map有两种类型，可变与不可变，区别在于可变集合的元素可以修改，不可变集合不可以修改。&lt;br&gt;默认情况下 Scala 使用不可变 Map。&lt;br&gt;如果需要使用可变集合，要显式的引入 import scala.collection.mutable.Map 类&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala中的数组</title>
    <link href="https://www.ggstu.com/2018/08/16/Scala%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/"/>
    <id>https://www.ggstu.com/2018/08/16/Scala中的数组/</id>
    <published>2018-08-16T13:57:02.000Z</published>
    <updated>2018-08-18T09:20:22.021Z</updated>
    
    <content type="html"><![CDATA[<p><strong>定长数组：使用关键字Array</strong><br>在Scala中，Array代表的含义与Java中类似，也是长度不可改变的数组。<br>此外，由于Scala和Java都是运行在JVM上，双方可以互相调用，因此Scala数组的底层实际上是Java数组。<br>例如字符串数组在底层就是Java的String[]，整数数组在底层就是Java的Int[]<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a = new Array[Int](5)</span><br><span class="line">a: Array[Int] = Array(0, 0, 0, 0, 0)</span><br><span class="line"></span><br><span class="line">scala&gt; val b = new Array[String](5)</span><br><span class="line">b: Array[String] = Array(null, null, null, null, null)</span><br><span class="line"></span><br><span class="line">scala&gt; val c = Array(&quot;Tom&quot;,&quot;Bob&quot;,&quot;Alice&quot;)</span><br><span class="line">c: Array[String] = Array(Tom, Bob, Alice)</span><br><span class="line"></span><br><span class="line">scala&gt; c(0)</span><br><span class="line">res0: String = Tom</span><br></pre></td></tr></table></figure></p><p><br><br><strong>变长数组：使用关键字ArrayBuffer</strong><br>在Scala中，如果需要类似于Java中的ArrayList这种长度可变的集合类，可以使用ArrayBuffer定义变长数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.collection.mutable.ArrayBuffer</span><br><span class="line">import scala.collection.mutable.ArrayBuffer</span><br><span class="line"></span><br><span class="line">scala&gt; var b = ArrayBuffer[Int]()</span><br><span class="line">b: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer()</span><br></pre></td></tr></table></figure></p><p>使用+=操作符，可以添加一个元素，或者多个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; b += 1</span><br><span class="line">res0: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(1)</span><br><span class="line"></span><br><span class="line">scala&gt; b += (2,3,4,5)</span><br><span class="line">res1: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4, 5)</span><br></pre></td></tr></table></figure></p><p>使用++=操作符，可以添加其他集合中的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; b ++= Array(6,7,8,9,10)</span><br><span class="line">res2: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</span><br></pre></td></tr></table></figure></p><p>使用trimEnd()函数，可以从尾部截断指定个数的元素<br>比如去掉最后五个值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; b.trimEnd(5)</span><br><span class="line"></span><br><span class="line">scala&gt; b</span><br><span class="line">res4: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4, 5)</span><br></pre></td></tr></table></figure></p><p>使用insert()函数可以在指定位置插入元素<br>如在第2个位置插入6<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; b.insert(2,6)</span><br><span class="line"></span><br><span class="line">scala&gt; b</span><br><span class="line">res6: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(1, 2, 6, 3, 4, 5)</span><br></pre></td></tr></table></figure></p><p>在第4个位置插入7,8,9,10<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; b.insert(4,7,8,9,10)</span><br><span class="line"></span><br><span class="line">scala&gt; b</span><br><span class="line">res8: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(1, 2, 6, 3, 7, 8, 9, 10, 4, 5)</span><br></pre></td></tr></table></figure></p><p>使用remove()函数可以移除指定位置的元素<br>如移除第0个位置的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; b.remove(0)</span><br><span class="line">res9: Int = 1</span><br><span class="line"></span><br><span class="line">scala&gt; b</span><br><span class="line">res10: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(2, 6, 3, 7, 8, 9, 10, 4, 5)</span><br></pre></td></tr></table></figure></p><p>移除第2个位置开始后的5个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; b.remove(2,5)</span><br><span class="line"></span><br><span class="line">scala&gt; b</span><br><span class="line">res12: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(2, 6, 4, 5)</span><br></pre></td></tr></table></figure></p><p><br><br><strong>转换数组</strong><br>Array与ArrayBuffer可以互相进行转换：<br>将Array转换成ArrayBuffer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a = new Array[Int](5)</span><br><span class="line">a: Array[Int] = Array(0, 0, 0, 0, 0)</span><br><span class="line"></span><br><span class="line">scala&gt; a.toBuffer</span><br><span class="line">res0: scala.collection.mutable.Buffer[Int] = ArrayBuffer(0, 0, 0, 0, 0)</span><br></pre></td></tr></table></figure></p><p>将ArrayBuffer转换成Array<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.collection.mutable.ArrayBuffer</span><br><span class="line">import scala.collection.mutable.ArrayBuffer</span><br><span class="line"></span><br><span class="line">scala&gt; val b = new ArrayBuffer[Int]()</span><br><span class="line">b: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer()</span><br><span class="line"></span><br><span class="line">scala&gt; b.toArray</span><br><span class="line">res1: Array[Int] = Array()</span><br></pre></td></tr></table></figure></p><p>使用yield转换数组：<br>对Array进行转换，获取的还是Array<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a = Array(1,2,3,4,5)</span><br><span class="line">a: Array[Int] = Array(1, 2, 3, 4, 5)</span><br><span class="line"></span><br><span class="line">scala&gt; for(ele &lt;- a) yield ele*ele</span><br><span class="line">res0: Array[Int] = Array(1, 4, 9, 16, 25)</span><br></pre></td></tr></table></figure></p><p>对ArrayBuffer进行转换，获取的还是ArrayBuffer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.collection.mutable.ArrayBuffer</span><br><span class="line">import scala.collection.mutable.ArrayBuffer</span><br><span class="line"></span><br><span class="line">scala&gt; val b = ArrayBuffer[Int]()</span><br><span class="line">b: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer()</span><br><span class="line"></span><br><span class="line">scala&gt; b += (1,2,3,4,5)</span><br><span class="line">res1: b.type = ArrayBuffer(1, 2, 3, 4, 5)</span><br><span class="line"></span><br><span class="line">scala&gt; for(ele &lt;- b) yield ele*ele</span><br><span class="line">res2: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(1, 4, 9, 16, 25)</span><br></pre></td></tr></table></figure></p><p>结合if守卫，仅转换需要的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a = Array(1,2,3,4,5,6,7,8,9)</span><br><span class="line">a: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9)</span><br><span class="line"></span><br><span class="line">scala&gt; for(ele &lt;- a if ele%2 == 0) yield ele*ele</span><br><span class="line">res0: Array[Int] = Array(4, 16, 36, 64)</span><br></pre></td></tr></table></figure></p><p>使用函数式编程转换数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a = Array(1,2,3,4,5,6,7,8,9)</span><br><span class="line">a: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9)</span><br><span class="line"></span><br><span class="line">scala&gt; a.filter(_%2 == 0).map(_*2)</span><br><span class="line">res0: Array[Int] = Array(4, 8, 12, 16)</span><br><span class="line"></span><br><span class="line">scala&gt; a.filter&#123;_%2 == 0&#125; map &#123;_*2&#125;</span><br><span class="line">res1: Array[Int] = Array(4, 8, 12, 16)</span><br></pre></td></tr></table></figure></p><p><br><br><strong>遍历数组</strong><br>遍历Array和ArrayBuffer<br>使用for循环和until遍历Array/ArrayBuffer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var a = Array(1,2,3,4,5,6,7,8,9)</span><br><span class="line">a: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9)</span><br><span class="line"></span><br><span class="line">scala&gt; for(i &lt;- 0 until a.length)</span><br><span class="line">     |     print(a(i) + &quot; &quot;)</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure></p><p>跳跃遍历Array/ArrayBuffer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; for(i &lt;- 0 until (a.length,2))</span><br><span class="line">     |     print(a(i) + &quot; &quot;)</span><br><span class="line">1 3 5 7 9</span><br></pre></td></tr></table></figure></p><p>从尾部遍历Array/ArrayBuffer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; for(i &lt;- (0 until a.length).reverse)</span><br><span class="line">     |     print(a(i) + &quot; &quot;)</span><br><span class="line">9 8 7 6 5 4 3 2 1</span><br></pre></td></tr></table></figure></p><p>使用”增强for循环”遍历Array/ArrayBuffer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; for(b &lt;- a)</span><br><span class="line">     |     print(b + &quot; &quot;)</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure></p><p><br><br><strong>Scala数组的常用操作</strong><br>数组元素求和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a = Array(1,20,8,4,12)</span><br><span class="line">a: Array[Int] = Array(1, 20, 8, 4, 12)</span><br><span class="line"></span><br><span class="line">scala&gt; a.sum</span><br><span class="line">res0: Int = 45</span><br></pre></td></tr></table></figure></p><p>获取数组最大值和最小值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; a.max</span><br><span class="line">res1: Int = 20</span><br><span class="line"></span><br><span class="line">scala&gt; a.min</span><br><span class="line">res2: Int = 1</span><br></pre></td></tr></table></figure></p><p>对数组进行排序：<br>使用快速排序方法，其会修改数组a的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; a</span><br><span class="line">res3: Array[Int] = Array(1, 20, 8, 4, 12)</span><br><span class="line"></span><br><span class="line">scala&gt; scala.util.Sorting.quickSort(a)</span><br><span class="line"></span><br><span class="line">scala&gt; a</span><br><span class="line">res5: Array[Int] = Array(1, 4, 8, 12, 20)</span><br></pre></td></tr></table></figure></p><p>使用如下方法分别由小到大排序和由大到小排序，不会修改数组a的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a = Array(1,20,8,4,12)</span><br><span class="line">a: Array[Int] = Array(1, 20, 8, 4, 12)</span><br><span class="line"></span><br><span class="line">scala&gt; a.sortWith(_ &lt; _)</span><br><span class="line">res6: Array[Int] = Array(1, 4, 8, 12, 20)</span><br><span class="line"></span><br><span class="line">scala&gt; a.sortWith(_ &gt; _)</span><br><span class="line">res7: Array[Int] = Array(20, 12, 8, 4, 1)</span><br><span class="line"></span><br><span class="line">scala&gt; a</span><br><span class="line">res8: Array[Int] = Array(1, 20, 8, 4, 12)</span><br></pre></td></tr></table></figure></p><p>获取数组中所有元素内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; a</span><br><span class="line">res9: Array[Int] = Array(1, 20, 8, 4, 12)</span><br><span class="line"></span><br><span class="line">scala&gt; a.mkString</span><br><span class="line">res10: String = 1208412</span><br><span class="line"></span><br><span class="line">scala&gt; a.mkString(&quot;,&quot;)</span><br><span class="line">res11: String = 1,20,8,4,12</span><br><span class="line"></span><br><span class="line">scala&gt; a.mkString(&quot;(&quot;, &quot;,&quot;, &quot;)&quot;)</span><br><span class="line">res12: String = (1,20,8,4,12)</span><br></pre></td></tr></table></figure></p><p><br><br><strong>Scala的多维数组</strong><br>Scala的多维数组与Java相同，是通过数组的数组实现的。<br>也可以创建不规则的数组，每一行的长度各不相同。<br>定义一个固定长度的二维数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val matrix = Array.ofDim[Int](4,3)</span><br><span class="line">matrix: Array[Array[Int]] = Array(Array(0, 0, 0), Array(0, 0, 0), Array(0, 0, 0), Array(0, 0, 0))</span><br><span class="line"></span><br><span class="line">scala&gt; matrix(1)(1) = 6</span><br><span class="line"></span><br><span class="line">scala&gt; matrix</span><br><span class="line">res1: Array[Array[Int]] = Array(Array(0, 0, 0), Array(0, 6, 0), Array(0, 0, 0), Array(0, 0, 0))</span><br></pre></td></tr></table></figure></p><p>定义一个二维数组，其中每个元素是一个一维数组，其长度不固定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val triangle = new Array[Array[Int]](10)</span><br><span class="line">triangle: Array[Array[Int]] = Array(null, null, null, null, null, null, null, null, null, null)</span><br><span class="line"></span><br><span class="line">scala&gt; for(i &lt;- 0 until triangle.length)</span><br><span class="line">     |     triangle(i) = new Array[Int](i+1)</span><br><span class="line"></span><br><span class="line">scala&gt; triangle</span><br><span class="line">res3: Array[Array[Int]] = Array(Array(0), Array(0, 0), Array(0, 0, 0), Array(0, 0, 0, 0), Array(0, 0, 0, 0, 0), Array(0, 0, 0, 0, 0, 0), Array(0, 0, 0, 0, 0, 0, 0), Array(0, 0, 0, 0, 0, 0, 0, 0), Array(0, 0, 0, 0, 0, 0, 0, 0, 0), Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0))</span><br></pre></td></tr></table></figure></p><p><br><br><strong>zip操作</strong><br>合并两个有序集合成为一个键值对集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val names = Array(&quot;Tom&quot;,&quot;Bob&quot;,&quot;Alice&quot;)</span><br><span class="line">names: Array[String] = Array(Tom, Bob, Alice)</span><br><span class="line"></span><br><span class="line">scala&gt; val ages = Array(21,18,26)</span><br><span class="line">ages: Array[Int] = Array(21, 18, 26)</span><br><span class="line"></span><br><span class="line">scala&gt; val nameAges = names.zip(ages)</span><br><span class="line">nameAges: Array[(String, Int)] = Array((Tom,21), (Bob,18), (Alice,26))</span><br><span class="line"></span><br><span class="line">scala&gt; for((name,age) &lt;- nameAges) println(name + &quot;: &quot; + age)</span><br><span class="line">Tom: 21</span><br><span class="line">Bob: 18</span><br><span class="line">Alice: 26</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;定长数组：使用关键字Array&lt;/strong&gt;&lt;br&gt;在Scala中，Array代表的含义与Java中类似，也是长度不可改变的数组。&lt;br&gt;此外，由于Scala和Java都是运行在JVM上，双方可以互相调用，因此Scala数组的底层实际上是Java数组。&lt;br&gt;例如字符串数组在底层就是Java的String[]，整数数组在底层就是Java的Int[]&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala的异常处理</title>
    <link href="https://www.ggstu.com/2018/08/16/Scala%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://www.ggstu.com/2018/08/16/Scala的异常处理/</id>
    <published>2018-08-16T13:36:00.000Z</published>
    <updated>2018-08-16T13:54:55.841Z</updated>
    
    <content type="html"><![CDATA[<p>Scala的异常处理类似许多其他语言，如Java。</p><p><strong>抛出异常</strong><br>抛出异常，创建一个异常对象，然后使用throw关键字将其抛出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; throw new Exception(&quot;Some Error Happened!&quot;)</span><br><span class="line">java.lang.Exception: Some Error Happened!</span><br><span class="line">  ... 32 elided</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>如果一个函数的返回类型是Nothing，表示在函数执行的过程中产生异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def func() = throw new IllegalArgumentException(&quot;Some Error Happened!&quot;)</span><br><span class="line">func: ()Nothing</span><br></pre></td></tr></table></figure></p><p><br><br><strong>捕获异常</strong><br>使用try…catch…finally来捕获和处理异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; try&#123;</span><br><span class="line">     |    val s = scala.io.Source.fromFile(&quot;C://Users//asus//Desktop/a.txt&quot;).mkString</span><br><span class="line">     | &#125;catch&#123;</span><br><span class="line">     |     case ex:java.io.FileNotFoundException =&gt; &#123;</span><br><span class="line">     |         println(&quot;File Not Found&quot;)</span><br><span class="line">     |     &#125;</span><br><span class="line">     |     case ex:IllegalArgumentException =&gt; &#123;</span><br><span class="line">     |         println(&quot;Illegal ArgumentException&quot;)</span><br><span class="line">     |     &#125;</span><br><span class="line">     |     case _:Exception =&gt; &#123;</span><br><span class="line">     |         println(&quot;Other Exception&quot;)</span><br><span class="line">     |     &#125;</span><br><span class="line">     | &#125;finally&#123;</span><br><span class="line">     |     println(&quot;*****final*****&quot;)</span><br><span class="line">     | &#125;</span><br><span class="line">File Not Found</span><br><span class="line">*****final*****</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scala的异常处理类似许多其他语言，如Java。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抛出异常&lt;/strong&gt;&lt;br&gt;抛出异常，创建一个异常对象，然后使用throw关键字将其抛出&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scala&amp;gt; throw new Exception(&amp;quot;Some Error Happened!&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;java.lang.Exception: Some Error Happened!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ... 32 elided&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala的输入输出</title>
    <link href="https://www.ggstu.com/2018/08/16/Scala%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>https://www.ggstu.com/2018/08/16/Scala的输入输出/</id>
    <published>2018-08-16T13:02:07.000Z</published>
    <updated>2018-08-16T13:33:55.308Z</updated>
    
    <content type="html"><![CDATA[<p><strong>输入</strong><br>readLine函数：从控制台读取用户输入的一行数据，可以带一个参数作为提示字符串<br>读取数字：readInt,readDouble,readByte,readShort,readLong,readFloat<br>读取Boolean类型的数据：readBoolean<br>读取字符：readChar<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.io.StdIn._</span><br><span class="line">import scala.io.StdIn._</span><br><span class="line"></span><br><span class="line">scala&gt; var name = readLine(&quot;Please input your name:&quot;)</span><br><span class="line">Please input your name:name: String = Tom</span><br><span class="line"></span><br><span class="line">scala&gt; name</span><br><span class="line">res0: String = Tom</span><br><span class="line"></span><br><span class="line">scala&gt; var age = readInt()</span><br><span class="line">age: Int = 21</span><br><span class="line"></span><br><span class="line">scala&gt; age</span><br><span class="line">res1: Int = 21</span><br></pre></td></tr></table></figure></p><p><br><br><strong>输出</strong><br>print函数：输出时不会加换行符<br>println函数：输出时会加一个换行符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; print(&quot;Hello World&quot;)</span><br><span class="line">Hello World</span><br><span class="line">scala&gt; println(&quot;Hello World&quot;)</span><br><span class="line">Hello World</span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure></p><p>printf函数：可以进行格式化输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; printf(&quot;Hello,my name is %s.I&apos;m %d years old.\n&quot;,&quot;Tom&quot;,21)</span><br><span class="line">Hello,my name is Tom.I&apos;m 21 years old.</span><br></pre></td></tr></table></figure></p><p><br><br><strong>输入输出例子</strong><br>判断成绩是否及格<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.io.StdIn._</span><br><span class="line">import scala.io.StdIn._</span><br><span class="line"></span><br><span class="line">scala&gt; val name = readLine(&quot;Please input your name:&quot;)</span><br><span class="line">Please input your name:name: String = Tom</span><br><span class="line"></span><br><span class="line">scala&gt; print(&quot;Thanks.Then please input you score:&quot;)</span><br><span class="line">Thanks.Then please input you score:</span><br><span class="line">scala&gt; val score = readDouble()</span><br><span class="line">score: Double = 85.5</span><br><span class="line"></span><br><span class="line">scala&gt; if(score &gt;= 60)&#123;</span><br><span class="line">     |     printf(&quot;Hello,%s,your score is %f,you passed.&quot;,name,score)</span><br><span class="line">     | &#125;else&#123;</span><br><span class="line">     |     printf(&quot;Sorry,%s,your score is %f,you failed.&quot;,name,score)</span><br><span class="line">     | &#125;</span><br><span class="line">Hello,Tom,your score is 85.500000,you passed.</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;输入&lt;/strong&gt;&lt;br&gt;readLine函数：从控制台读取用户输入的一行数据，可以带一个参数作为提示字符串&lt;br&gt;读取数字：readInt,readDouble,readByte,readShort,readLong,readFloat&lt;br&gt;读取Boolean类型的数据：readBoolean&lt;br&gt;读取字符：readChar&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala的Lazy值</title>
    <link href="https://www.ggstu.com/2018/08/16/Scala%E7%9A%84Lazy%E5%80%BC/"/>
    <id>https://www.ggstu.com/2018/08/16/Scala的Lazy值/</id>
    <published>2018-08-16T09:06:58.000Z</published>
    <updated>2018-08-16T02:55:33.430Z</updated>
    
    <content type="html"><![CDATA[<p>在Scala中，使用关键字<strong>lazy</strong>来定义懒惰变量，实现延迟加载(懒加载)。<br>惰性变量只能是不可变变量，即，使用val声明变量，并且只有在调用惰性变量时，才会去实例化这个变量。<br>这种特性对于特别耗时的的计算操作特别有用，比如打开文件进行IO，进行网络IO等。<br>如下所示：当val被声明为lazy时，它的初始化将被推迟，直到首次对它取值。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val x:Int = 5</span><br><span class="line">x: Int = 5</span><br><span class="line"></span><br><span class="line">scala&gt; lazy val y:Int = 6</span><br><span class="line">y: Int = &lt;lazy&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; y</span><br><span class="line">res0: Int = 6</span><br></pre></td></tr></table></figure></p><p><br><br><strong>使用懒加载读取文件</strong><br><strong>读取一个存在的文件</strong><br>我在桌面创建了一个文件a.txt，文件内容为Hello World<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.io.Source._</span><br><span class="line">import scala.io.Source._</span><br><span class="line"></span><br><span class="line">scala&gt; val a = fromFile(&quot;C://Users//asus//Desktop//a.txt&quot;).mkString</span><br><span class="line">a: String = Hello World</span><br><span class="line"></span><br><span class="line">scala&gt; lazy val b = fromFile(&quot;C://Users//asus/Desktop//a.txt&quot;).mkString</span><br><span class="line">b: String = &lt;lazy&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; b</span><br><span class="line">res0: String = Hello World</span><br></pre></td></tr></table></figure></p><p><strong>读取一个不存在的文件</strong><br>不使用懒加载，文件不存在，报异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.io.Source._</span><br><span class="line">import scala.io.Source._</span><br><span class="line"></span><br><span class="line">scala&gt; val c = fromFile(&quot;C://Users//asus//Desktop//aaaaa.txt&quot;).mkString</span><br><span class="line">java.io.FileNotFoundException: C:\Users\asus\Desktop\aaaaa.txt (系统找不到指定的文件。)</span><br><span class="line">  at java.io.FileInputStream.open0(Native Method)</span><br><span class="line">  at java.io.FileInputStream.open(FileInputStream.java:195)</span><br><span class="line">  at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:138)</span><br><span class="line">  at scala.io.Source$.fromFile(Source.scala:91)</span><br><span class="line">  at scala.io.Source$.fromFile(Source.scala:76)</span><br><span class="line">  at scala.io.Source$.fromFile(Source.scala:54)</span><br><span class="line">  ... 32 elided</span><br></pre></td></tr></table></figure></p><p>使用懒加载，即使文件不存在，也不会报错<br>只有第一次调用的时候，才会对其运算，才会出现Exception<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.io.Source._</span><br><span class="line">import scala.io.Source._</span><br><span class="line"></span><br><span class="line">scala&gt; lazy val d = fromFile(&quot;C://Users//asus//Desktop//aaaaa.txt&quot;).mkString</span><br><span class="line">d: String = &lt;lazy&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; d</span><br><span class="line">java.io.FileNotFoundException: C:\Users\asus\Desktop\aaaaa.txt (系统找不到指定的文件。)</span><br><span class="line">  at java.io.FileInputStream.open0(Native Method)</span><br><span class="line">  at java.io.FileInputStream.open(FileInputStream.java:195)</span><br><span class="line">  at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:138)</span><br><span class="line">  at scala.io.Source$.fromFile(Source.scala:91)</span><br><span class="line">  at scala.io.Source$.fromFile(Source.scala:76)</span><br><span class="line">  at scala.io.Source$.fromFile(Source.scala:54)</span><br><span class="line">  at .d$lzycompute(&lt;console&gt;:14)</span><br><span class="line">  at .d(&lt;console&gt;:14)</span><br><span class="line">  ... 32 elided</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Scala中，使用关键字&lt;strong&gt;lazy&lt;/strong&gt;来定义懒惰变量，实现延迟加载(懒加载)。&lt;br&gt;惰性变量只能是不可变变量，即，使用val声明变量，并且只有在调用惰性变量时，才会去实例化这个变量。&lt;br&gt;这种特性对于特别耗时的的计算操作特别有用，比如打开文件进行IO，进行网络IO等。&lt;br&gt;如下所示：当val被声明为lazy时，它的初始化将被推迟，直到首次对它取值。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala中的函数</title>
    <link href="https://www.ggstu.com/2018/08/16/Scala%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"/>
    <id>https://www.ggstu.com/2018/08/16/Scala中的函数/</id>
    <published>2018-08-16T08:23:09.000Z</published>
    <updated>2018-08-15T09:43:56.656Z</updated>
    
    <content type="html"><![CDATA[<p>在Scala中定义函数时，需要定义函数的函数名、参数、函数体。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sayHello(name:String,age:Int) = &#123;</span><br><span class="line">     |     printf(&quot;Hello,my name is %s.I&apos;m %d years old.\n&quot;,name,age)</span><br><span class="line">     | &#125;</span><br><span class="line">sayHello: (name: String, age: Int)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; sayHello(&quot;Tom&quot;,21)</span><br><span class="line">Hello,my name is Tom.I&apos;m 21 years old.</span><br></pre></td></tr></table></figure></p><a id="more"></a><p><br><br>如果调用的函数不需要传递参数，则可以省略括号<br>例如：”Hello World”.distinct<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; &quot;Hello World&quot;.distinct</span><br><span class="line">res0: String = Helo Wrd</span><br></pre></td></tr></table></figure></p><p><br><br>如果函数体中有多行代码，则可以使用代码块的方式包裹多行代码。<br>代码块最后一行的返回值就是整个函数的返回值。<br>Scala定义函数时必须给出所有参数的类型，但是不一定给出函数返回值的类型。<br>只要右侧的函数体中不包含递归的语句，Scala就可以根据右侧的表达式推断出返回类型。<br>例如：下面函数，实现累加功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sum(n:Int) = &#123;</span><br><span class="line">     |     var res = 0</span><br><span class="line">     |     for(i &lt;- 1 to n) res += i</span><br><span class="line">     |     res</span><br><span class="line">     | &#125;</span><br><span class="line">sum: (n: Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; sum(10)</span><br><span class="line">res1: Int = 55</span><br></pre></td></tr></table></figure></p><p><br><br><strong>递归函数</strong><br>如果在函数体内递归调用函数自身，则必须手动给出函数的返回类型<br>例如：实现斐波那契数列：1,1,2,3,5,8,13,21,34,55,……<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def fab(n:Int):Int = &#123;</span><br><span class="line">     |     if(n &lt;= 2) 1</span><br><span class="line">     |     else fab(n-1) + fab(n-2)</span><br><span class="line">     | &#125;</span><br><span class="line">fab: (n: Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; fab(8)</span><br><span class="line">res0: Int = 21</span><br></pre></td></tr></table></figure></p><p><br><br><strong>Scala函数的参数</strong><br>Scala中有两种函数参数的求值策略：<br>1、Call By Value:对函数实参求值，且仅求一次<br>2、Call By Name:函数实参每次在函数体内被用到时都会求值<br>例如：call by value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def test1(x:Int,y:Int):Int = x + x</span><br><span class="line">test1: (x: Int, y: Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; test1(1+2,8)</span><br><span class="line">res0: Int = 6</span><br></pre></td></tr></table></figure></p><p>调用过程为：<br>test1(1+2,8)<br>1、test1(3,8)<br>2、3+3<br>3、6<br><br><br>例如：call by name<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def test2(x: =&gt; Int,y: =&gt; Int):Int = x + x</span><br><span class="line">test2: (x: =&gt; Int, y: =&gt; Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; test2(1+2,8)</span><br><span class="line">res1: Int = 6</span><br></pre></td></tr></table></figure></p><p>调用过程为：<br>1、(1+2)+(1+2)<br>2、3 + (1+2)<br>3、3 + 3<br>4、6<br><br><br><strong>默认参数</strong><br>Scala中，调用某些函数时，若不希望给出参数的具体值，而使用参数自身默认的值，就可以在定义函数时使用默认参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sayHello(name:String = &quot;Tom&quot;) = &#123;</span><br><span class="line">     |     printf(&quot;Hello,my name is %s.&quot;,name)</span><br><span class="line">     | &#125;</span><br><span class="line">sayHello: (name: String)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; sayHello()</span><br><span class="line">Hello,my name is Tom.</span><br><span class="line">scala&gt; sayHello(&quot;Bob&quot;)</span><br><span class="line">Hello,my name is Bob.</span><br></pre></td></tr></table></figure></p><p><strong>带名参数</strong><br>在调用函数时，也可以不按照函数定义的参数顺序来传递参数，而是使用带名参数的方式来传递。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sayHello(name:String,age:Int) = &#123;</span><br><span class="line">     |     printf(&quot;Hello,my name is %s.I&apos;m %d years old.&quot;,name,age)</span><br><span class="line">     | &#125;</span><br><span class="line">sayHello: (name: String, age: Int)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; sayHello(age=21,name=&quot;Tom&quot;)</span><br><span class="line">Hello,my name is Tom.I&apos;m 21 years old.</span><br></pre></td></tr></table></figure></p><p><strong>变长参数</strong><br>Scala中，若需要将函数定义为参数个数可变的形式，可以使用变长参数定义函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sum(nums:Int*) = &#123;</span><br><span class="line">     |     var res = 0</span><br><span class="line">     |     for(num &lt;- nums) res += num</span><br><span class="line">     |     res</span><br><span class="line">     | &#125;</span><br><span class="line">sum: (nums: Int*)Int</span><br><span class="line"></span><br><span class="line">scala&gt; sum(1,2,3)</span><br><span class="line">res0: Int = 6</span><br><span class="line"></span><br><span class="line">scala&gt; sum(1,2,3,4,5)</span><br><span class="line">res1: Int = 15</span><br></pre></td></tr></table></figure></p><p><strong>使用序列调用变长参数</strong><br>不能将一个已有的序列直接调用变长参数函数，比如val s = sum(1 to 5)<br>需要使用Scala特殊的语法将参数定义为序列，让Scala解释器能够识别。<br>如：val s = sum(1 to 5: _*)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; sum(1 to 5)</span><br><span class="line">&lt;console&gt;:13: error: type mismatch;</span><br><span class="line"> found   : scala.collection.immutable.Range.Inclusive</span><br><span class="line"> required: Int</span><br><span class="line">       sum(1 to 5)</span><br><span class="line">             ^</span><br><span class="line"></span><br><span class="line">scala&gt; sum(1 to 5: _*)</span><br><span class="line">res3: Int = 15</span><br></pre></td></tr></table></figure></p><p>变长参数例子：使用递归函数实现累加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sum(nums:Int*):Int = &#123;</span><br><span class="line">     |     if(nums.length == 0) 0</span><br><span class="line">     |     else nums.head + sum(nums.tail: _*)</span><br><span class="line">     | &#125;</span><br><span class="line">sum: (nums: Int*)Int</span><br><span class="line"></span><br><span class="line">scala&gt; sum(1,2,3)</span><br><span class="line">res0: Int = 6</span><br><span class="line"></span><br><span class="line">scala&gt; sum(1,2,3,4,5)</span><br><span class="line">res1: Int = 15</span><br></pre></td></tr></table></figure></p><p><br><br><strong>Scala的过程</strong><br>在Scala中，定义函数时，如果函数体直接包裹在了花括号里面，并且没有使用=连接，则函数的返回值类型就是Unit。<br>这样的函数就被称之为过程。过程通常用于不需要返回值的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sayHello(name:String)&#123;print(&quot;Hello,my name is &quot;) + name&#125;</span><br><span class="line">sayHello: (name: String)Unit</span><br></pre></td></tr></table></figure></p><p>过程还有一种写法，就是将函数的返回值类型定义为Unit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sayHello(name:String):Unit = &quot;Hello,my name is&quot; + name</span><br><span class="line">sayHello: (name: String)Unit</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Scala中定义函数时，需要定义函数的函数名、参数、函数体。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scala&amp;gt; def sayHello(name:String,age:Int) = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     |     printf(&amp;quot;Hello,my name is %s.I&amp;apos;m %d years old.\n&amp;quot;,name,age)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     | &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayHello: (name: String, age: Int)Unit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scala&amp;gt; sayHello(&amp;quot;Tom&amp;quot;,21)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Hello,my name is Tom.I&amp;apos;m 21 years old.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
</feed>
