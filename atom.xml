<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GGSTU</title>
  
  <subtitle>Good Good Study</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.ggstu.com/"/>
  <updated>2018-08-31T10:39:02.714Z</updated>
  <id>https://www.ggstu.com/</id>
  
  <author>
    <name>Wu Zhenyong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hadoop2.X的安装与配置（三）伪分布模式</title>
    <link href="https://www.ggstu.com/2018/08/31/Hadoop2-X%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%89%EF%BC%89%E4%BC%AA%E5%88%86%E5%B8%83%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.ggstu.com/2018/08/31/Hadoop2-X的安装与配置（三）伪分布模式/</id>
    <published>2018-08-31T07:51:52.000Z</published>
    <updated>2018-08-31T10:39:02.714Z</updated>
    
    <content type="html"><![CDATA[<p>在完成了准备阶段的配置后，接着就可以配置伪分布模式了。<br>伪分布模式的配置需要在如下的配置文件中添加配置参数。<br><img src="http://pd8lpasbc.bkt.clouddn.com/38-1.png" width="100%" height="100%"><br><a id="more"></a></p><p><font size="4"><b>在配置之前，首先对这些配置参数做一下介绍：</b></font><br><b>hadoop-env.sh</b>：配置环境变量<br>&emsp;&emsp;JAVA_HOME：设置Java环境变量。</p><p><b>hdfs-site.xml</b>：配置hdfs的属性<br>&emsp;&emsp;dfs.replication：数据块的冗余度，如果不配置，默认值是3。这里配置伪分布模式，只有一个数据节点，因此设置为1。<br>&emsp;&emsp;dfs.permissions：权限检查，默认值是true。设置为false，不进行权限检查。</p><p><b>core-site.xml</b>：配置hdfs的属性<br>&emsp;&emsp;fs.defaultFS：配置主节点的地址。<br>&emsp;&emsp;hadoop.tmp.dir：配置hdfs数据保存的目录，默认值是Linux的/tmp目录。若Linux重启，tmp目录下的所有数据会被删除，因此需要修改保存数据的目录，并且此目录要事先存在。</p><p><b>mapred-site.xml</b>：配置yarn的属性，yarn是一个执行MapReduce程序的容器<br>&emsp;&emsp;mapreduce.framework.name：设置MapReduce程序运行的容器为yarn。</p><p><b>yarn-site.xml</b>：配置yarn的属性<br>&emsp;&emsp;yarn.resourcemanager.hostname：配置主节点地址。<br>&emsp;&emsp;yarn.nodemanager.aux-services：配置从节点运行MapReduce的方式。<br><br></p><p><font size="4"><b>接下来开始进行配置：</b></font><br><b>1、修改hadoop-env.sh配置文件</b><br>使用vi编辑器修改hadoop-env.sh配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu ~]# cd software/hadoop-2.7.7/etc/hadoop/</span><br><span class="line">[root@ggstu hadoop]# vi hadoop-env.sh</span><br></pre></td></tr></table></figure></p><p>:set number打开行号，在hadoop-env.sh配置文件中添加JAVA_HOME路径<br><img src="http://pd8lpasbc.bkt.clouddn.com/38-2.png" width="70%" height="70%"><br>添加完成后，保存退出。</p><p><b>2、修改hdfs-site.xml配置文件</b><br>使用vi编辑器修改hdfs-site.xml配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu ~]# cd ~/software/hadoop-2.7.7/etc/hadoop/</span><br><span class="line">[root@ggstu hadoop]# vi hdfs-site.xml</span><br></pre></td></tr></table></figure></p><p>在configuration代码块中添加如下的两个property代码块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Put site-specific property overrides in this file. --&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;dfs.permissions&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p><p>添加完成后，保存退出。</p><p><b>3、修改core-site.xml配置文件</b><br>创建hdfs数据保存的目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu hadoop]# mkdir /root/software/hadoop-2.7.7/tmp</span><br></pre></td></tr></table></figure></p><p>使用vi编辑器修改core-site.xml配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu hadoop]# vi core-site.xml</span><br></pre></td></tr></table></figure></p><p>在configuration代码块中添加如下的两个property代码块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Put site-specific property overrides in this file. --&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;hdfs://ggstu:9000&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;/root/software/hadoop-2.7.7/tmp&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p><p>添加完成后，保存退出。</p><p><b>4、修改mapred-site.xml配置文件</b><br>使用vi编辑器修改mapred-site.xml配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu hadoop]# cp mapred-site.xml.template mapred-site.xml</span><br><span class="line">[root@ggstu hadoop]# vi mapred-site.xml</span><br></pre></td></tr></table></figure></p><p>在configuration代码块中添加如下这个property代码块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Put site-specific property overrides in this file. --&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p><p>添加完成后，保存退出。</p><p><b>5、修改yarn-site.xml配置文件</b><br>使用vi编辑器修改yarn-site.xml配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu hadoop]# vi yarn-site.xml</span><br></pre></td></tr></table></figure></p><p>在configuration代码块中添加如下的两个property代码块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;ggstu&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p><p>添加完成后，保存退出。</p><p><b>6、对主节点NameNode格式化</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu hadoop]# hdfs namenode -format</span><br></pre></td></tr></table></figure></p><p>在打印的日志中，若看到如下这一条，说明格式化成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18/08/31 16:58:49 INFO common.Storage: Storage directory /root/software/hadoop-2.7.7/tmp/dfs/name has been successfully formatted.</span><br></pre></td></tr></table></figure></p><p>到这里Hadoop的伪分布模式的配置就完成了。<br><br></p><p><font size="4"><b>启动Hadoop伪分布集群：</b></font><br>启动命令：<br>start-all.sh：启动hdfs和yarn<br>start-dfs.sh：启动hdfs<br>start-yarn.sh：启动yarn<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu hadoop]# start-all.sh</span><br></pre></td></tr></table></figure></p><p>在启动的过程中要输入四次登录密码，这是因为没有配置SSH免密码登录。关于如何配置SSH免密码登录后面会介绍。<br>使用jps命令查看后台进程，可以看到hdfs的NameNode、DataNode、SecondaryNameNode以及Yarn的ResourceManager、NodeManager都启动了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu hadoop]# jps</span><br><span class="line">4016 SecondaryNameNode</span><br><span class="line">4170 ResourceManager</span><br><span class="line">4491 Jps</span><br><span class="line">4459 NodeManager</span><br><span class="line">3853 DataNode</span><br><span class="line">3725 NameNode</span><br></pre></td></tr></table></figure></p><p><font color="#f00">注意：</font>如果你使用的是购买的服务器搭建集群，/etc/hosts下配置的IP要为内网IP，否则NameNode和ResourceManager无法启动。</p><p>关闭命令<br>stop-al.sh：关闭hdfs和yarn<br>stop-dfs.sh：关闭hdfs<br>stop-yarn.sh：关闭yarn<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu hadoop]# stop-all.sh</span><br></pre></td></tr></table></figure></p><p>关闭hdfs集群同样要输入四次登录密码。</p><p>到这里Hadoop的伪分布模式的配置，以及启动关闭就介绍完了。美中不足的地方就是集群的启动和关闭需要输入多次密码，很不方便。所以就需要配置SSH免密码登录，关于免密码登录，在后面的文章中会做介绍。<br><br><br>如果在安装过程中遇到什么问题，欢迎评论。<br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在完成了准备阶段的配置后，接着就可以配置伪分布模式了。&lt;br&gt;伪分布模式的配置需要在如下的配置文件中添加配置参数。&lt;br&gt;&lt;img src=&quot;http://pd8lpasbc.bkt.clouddn.com/38-1.png&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Hadoop" scheme="https://www.ggstu.com/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop2.X的安装与配置（二）本地模式</title>
    <link href="https://www.ggstu.com/2018/08/31/Hadoop2-X%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%EF%BC%89%E6%9C%AC%E5%9C%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.ggstu.com/2018/08/31/Hadoop2-X的安装与配置（二）本地模式/</id>
    <published>2018-08-31T06:31:32.000Z</published>
    <updated>2018-08-31T07:29:22.621Z</updated>
    
    <content type="html"><![CDATA[<p>在完成了准备阶段的配置后，接着就可以配置本地模式了。<br>本地模式的配置需要在如下的配置文件中添加JAVA_HOME的路径。<br><img src="http://pd8lpasbc.bkt.clouddn.com/37-1.png" width="100%" height="100%"><br><a id="more"></a><br>使用vi编辑器修改hadoop-env.sh配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu ~]# cd software/hadoop-2.7.7/etc/hadoop/</span><br><span class="line">[root@ggstu hadoop]# vi hadoop-env.sh</span><br></pre></td></tr></table></figure></p><p>:set number打开行号，在hadoop-env.sh配置文件中添加JAVA_HOME路径<br><img src="http://pd8lpasbc.bkt.clouddn.com/37-2.png" width="70%" height="70%"><br>添加完成后，保存退出。到这里本地模式就配置完成了。<br><br></p><p><font size="4"><b>下面在本地模式测试一下MapReduce程序</b></font><br><b>1、找到执行程序的jar包</b><br>hadoop-mapreduce-examples-2.7.7.jar就是执行程序的jar包，其下有很多例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu ~]# cd software/hadoop-2.7.7/share/hadoop/mapreduce/</span><br><span class="line">[root@ggstu mapreduce]# ls</span><br><span class="line">hadoop-mapreduce-client-app-2.7.7.jar         hadoop-mapreduce-client-jobclient-2.7.7-tests.jar</span><br><span class="line">hadoop-mapreduce-client-common-2.7.7.jar      hadoop-mapreduce-client-shuffle-2.7.7.jar</span><br><span class="line">hadoop-mapreduce-client-core-2.7.7.jar        hadoop-mapreduce-examples-2.7.7.jar</span><br><span class="line">hadoop-mapreduce-client-hs-2.7.7.jar          lib</span><br><span class="line">hadoop-mapreduce-client-hs-plugins-2.7.7.jar  lib-examples</span><br><span class="line">hadoop-mapreduce-client-jobclient-2.7.7.jar   sources</span><br></pre></td></tr></table></figure></p><p><b>2、查看示例jar包下的例子</b><br>这里使用经典的wordcount作为例子执行MapReduce程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu mapreduce]# hadoop jar hadoop-mapreduce-examples-2.7.7.jar </span><br><span class="line">An example program must be given as the first argument.</span><br><span class="line">Valid program names are:</span><br><span class="line">  aggregatewordcount: An Aggregate based map/reduce program that counts the words in the input files.</span><br><span class="line">  aggregatewordhist: An Aggregate based map/reduce program that computes the histogram of the words in the input files.</span><br><span class="line">  bbp: A map/reduce program that uses Bailey-Borwein-Plouffe to compute exact digits of Pi.</span><br><span class="line">  dbcount: An example job that count the pageview counts from a database.</span><br><span class="line">  distbbp: A map/reduce program that uses a BBP-type formula to compute exact bits of Pi.</span><br><span class="line">  grep: A map/reduce program that counts the matches of a regex in the input.</span><br><span class="line">  join: A job that effects a join over sorted, equally partitioned datasets</span><br><span class="line">  multifilewc: A job that counts words from several files.</span><br><span class="line">  pentomino: A map/reduce tile laying program to find solutions to pentomino problems.</span><br><span class="line">  pi: A map/reduce program that estimates Pi using a quasi-Monte Carlo method.</span><br><span class="line">  randomtextwriter: A map/reduce program that writes 10GB of random textual data per node.</span><br><span class="line">  randomwriter: A map/reduce program that writes 10GB of random data per node.</span><br><span class="line">  secondarysort: An example defining a secondary sort to the reduce.</span><br><span class="line">  sort: A map/reduce program that sorts the data written by the random writer.</span><br><span class="line">  sudoku: A sudoku solver.</span><br><span class="line">  teragen: Generate data for the terasort</span><br><span class="line">  terasort: Run the terasort</span><br><span class="line">  teravalidate: Checking results of terasort</span><br><span class="line">  wordcount: A map/reduce program that counts the words in the input files.</span><br><span class="line">  wordmean: A map/reduce program that counts the average length of the words in the input files.</span><br><span class="line">  wordmedian: A map/reduce program that counts the median length of the words in the input files.</span><br><span class="line">  wordstandarddeviation: A map/reduce program that counts the standard deviation of the length of the words in the input files.</span><br></pre></td></tr></table></figure></p><p><b>3、准备数据源</b><br>使用vi编辑器创建一个文件，在此文件中输入一些以空格间隔的单词作为数据输入源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu mapreduce]# mkdir ~/input</span><br><span class="line">[root@ggstu mapreduce]# vi ~/input/data.txt</span><br></pre></td></tr></table></figure></p><p>在data.txt文件中输入一些单词，我输入的单词如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">good good study</span><br><span class="line">day day up</span><br></pre></td></tr></table></figure></p><p><b>4、执行wordcount程序</b><br>使用命令： hadoop jar hadoop-mapreduce-examples-2.7.7.jar wordcount ~/input/data.txt ~/output/wordcount<br>参数：wordcount    表示执行jar包中的wordcount程序<br>参数：~/input/data.txt    表示输入数据<br>参数：~/output/wordcount    表示输出数据保存路径，这个路径事先不存在<br>这里打印的日志比较多，我就截取其中的一部分，看到日志中打印出map 100% reduce 100%，说明MapReduce程序执行完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu mapreduce]# hadoop jar hadoop-mapreduce-examples-2.7.7.jar wordcount ~/input/data.txt ~/output/wordcount</span><br><span class="line">18/08/31 15:19:08 INFO mapred.LocalJobRunner: Finishing task: attempt_local1075408480_0001_r_000000_0</span><br><span class="line">18/08/31 15:19:08 INFO mapred.LocalJobRunner: reduce task executor complete.</span><br><span class="line">18/08/31 15:19:08 INFO mapreduce.Job: Job job_local1075408480_0001 running in uber mode : false</span><br><span class="line">18/08/31 15:19:08 INFO mapreduce.Job:  map 100% reduce 100%</span><br><span class="line">18/08/31 15:19:08 INFO mapreduce.Job: Job job_local1075408480_0001 completed successfully</span><br><span class="line">18/08/31 15:19:08 INFO mapreduce.Job: Counters: 30</span><br></pre></td></tr></table></figure></p><p><b>5、查看输出结果</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu mapreduce]# cd ~/output/wordcount/</span><br><span class="line">[root@ggstu wordcount]# ll</span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 1 root root 26 Aug 31 15:19 part-r-00000</span><br><span class="line">-rw-r--r-- 1 root root  0 Aug 31 15:19 _SUCCESS</span><br><span class="line">[root@ggstu wordcount]# cat part-r-00000 </span><br><span class="line">day     2</span><br><span class="line">good    2</span><br><span class="line">study   1</span><br><span class="line">up      1</span><br></pre></td></tr></table></figure></p><p>wordcount程序的执行结果，统计出每个单词出现的频率。<br><br><br>如果在安装过程中遇到什么问题，欢迎评论。<br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在完成了准备阶段的配置后，接着就可以配置本地模式了。&lt;br&gt;本地模式的配置需要在如下的配置文件中添加JAVA_HOME的路径。&lt;br&gt;&lt;img src=&quot;http://pd8lpasbc.bkt.clouddn.com/37-1.png&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Hadoop" scheme="https://www.ggstu.com/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop2.X的安装与配置（一）准备阶段</title>
    <link href="https://www.ggstu.com/2018/08/31/Hadoop2-X%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5/"/>
    <id>https://www.ggstu.com/2018/08/31/Hadoop2-X的安装与配置（一）准备阶段/</id>
    <published>2018-08-31T01:51:17.000Z</published>
    <updated>2018-08-31T10:42:55.967Z</updated>
    
    <content type="html"><![CDATA[<p>Hadoop是一个由Apache基金会所开发的分布式系统基础架构。用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。<br>Hadoop实现了一个分布式文件系统（Hadoop Distributed File System），简称HDFS。HDFS有高容错性的特点，并且设计用来部署在低廉的（low-cost）硬件上；而且它提供高吞吐量（high throughput）来访问应用程序的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS放宽了（relax）POSIX的要求，可以以流的形式访问（streaming access）文件系统中的数据。<br><a id="more"></a><br>Hadoop的框架最核心的设计就是：HDFS和MapReduce。HDFS为海量的数据提供了存储，则MapReduce为海量的数据提供了计算。</p><p><font size="5"><b>Hadoop有三种安装模式：</b></font><br><b>1、本地模式：</b>一台Linux<br>特点：没有HDFS(Hadoop Distributed File System)，即没有数据的存储。<br>只能测试MapReduce程序，处理的数据是本地数据（Linux文件）</p><p><b>2、伪分布模式：</b> 一台Linux<br>特点：在单机上，模拟一个分布式的环境，具备Hadoop的所有功能</p><p><b>3、全分布模式：</b> 多台Linux（以3台为例）<br>特点：真正的分布式环境，用于生产环境</p><p>这里首先介绍安装配置这几种模式前的准备阶段</p><p><font size="5"><b>准备阶段：</b></font></p><p><font size="4"><b>一、准备Linux机器：</b></font><br>如果是搭建本地模式或者伪分布模式，使用一台Linux机器即可。<br>若是搭建全分布模式，至少需要三台机器。<br>可以购买三台Linux的服务器，也可以在虚拟机上搭建三台Linux机器。<br>如果不懂如何在虚拟机上搭建Linux，点击如下链接进行查看：<br><a href="https://www.ggstu.com/2018/08/13/%E5%A6%82%E4%BD%95%E5%9C%A8VMware-Workstation%E5%AE%89%E8%A3%85RedHat-Linux-7-4/">如何在VMware Workstation安装RedHat Linux 7.4</a></p><p><font size="4"><b>二、在Linux上安装JDK：</b></font><br>如果不懂如何安装JDK，点击如下链接进行安装：<br><a href="https://www.ggstu.com/2018/08/30/Linux%E4%B8%8B%EF%BC%88CentOS7%EF%BC%89%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AEJDK1-8%EF%BC%88wget%E5%91%BD%E4%BB%A4%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F%EF%BC%89/">Linux下（CentOS7）安装与配置JDK1.8</a></p><p><font size="4"><b>三、关闭防火墙：</b></font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu ~]# systemctl stop firewalld.service</span><br><span class="line">[root@ggstu ~]# systemctl status firewalld.service</span><br></pre></td></tr></table></figure></p><p><font size="4"><b>四、配置主机名：</b></font><br>使用vi编辑器修改/etc下的hosts配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu ~]# vi /etc/hosts</span><br></pre></td></tr></table></figure></p><p>添加这台Linux机器的IP地址和对应的主机名到此文件中，比如我这台Linux的IP和主机名如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">172.24.101.191 ggstu</span><br></pre></td></tr></table></figure></p><p><font color="#f00">注意：</font>如果使用的是购买的Linux服务器，这里的IP是内网IP。<br>添加完成后，保存退出</p><p><font size="4"><b>五、在Windows上下载Hadoop2.X的安装包：</b></font><br>点击如下链接进行下载，下载binary中的*.tar.gz压缩包<br><a href="http://hadoop.apache.org/releases.html#Download" target="_blank" rel="noopener">http://hadoop.apache.org/releases.html#Download</a></p><p><font size="4"><b>六、将安装包上传到Linux上，并解压缩：</b></font><br>使用WinSCP将压缩包上传到事先创建好的tools目录下<br><img src="http://pd8lpasbc.bkt.clouddn.com/36-1.png" width="100%" height="100%"><br>使用SecureCRT远程连接上Linux，将压缩包解压到事先创建好的software目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu ~]# cd tools/</span><br><span class="line">[root@ggstu tools]# ls</span><br><span class="line">hadoop-2.7.7.tar.gz  jdk-8u131-linux-x64.tar.gz</span><br><span class="line">[root@ggstu tools]# tar -zxvf hadoop-2.7.7.tar.gz -C ~/software/</span><br></pre></td></tr></table></figure></p><p><font size="4"><b>七、设置环境变量：</b></font><br>查看HADOOP_HOME所在位置，如下所示，/root/software/hadoop-2.7.7就是HADOOP_HOME的位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu tools]# cd ~/software/hadoop-2.7.7/</span><br><span class="line">[root@ggstu hadoop-2.7.7]# pwd</span><br><span class="line">/root/software/hadoop-2.7.7</span><br></pre></td></tr></table></figure></p><p>使用vi编辑器修改bash_profile配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu hadoop-2.7.7]# vi ~/.bash_profile</span><br></pre></td></tr></table></figure></p><p>在bash_profile文件末尾添加如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HADOOP_HOME=/root/software/hadoop-2.7.7</span><br><span class="line">export HADOOP_HOME</span><br><span class="line">PATH=$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure></p><p>添加完成后，保存退出</p><p><font color="#f00">注意：</font>这里设置的HADOOP_HOME即为上面查看到的HADOOP_HOME位置</p><p><font size="4"><b>八、生效环境变量：</b></font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu hadoop-2.7.7]# source ~/.bash_profile</span><br></pre></td></tr></table></figure></p><p><font size="4"><b>九、查看是否配置成功：</b></font><br>输入start-，再双击Tab键，出现的就是Hadoop的启动命令<br>输入stop-，再双击Tab键，出现的就是Hadoop的关闭命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu hadoop-2.7.7]# start-</span><br><span class="line">start-all.cmd        start-dfs.cmd        start-yarn.cmd</span><br><span class="line">start-all.sh         start-dfs.sh         start-yarn.sh</span><br><span class="line">start-balancer.sh    start-secure-dns.sh  </span><br><span class="line">[root@ggstu hadoop-2.7.7]# stop-</span><br><span class="line">stop-all.cmd        stop-dfs.cmd        stop-yarn.cmd</span><br><span class="line">stop-all.sh         stop-dfs.sh         stop-yarn.sh</span><br><span class="line">stop-balancer.sh    stop-secure-dns.sh</span><br></pre></td></tr></table></figure></p><p><br><br>到此，Hadoop2.X安装配置的准备阶段就完成了。就下来就可以根据需要安装本地模式、伪分布模式或全分布模式。<br><br><br>如果在安装过程中遇到什么问题，欢迎评论。<br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hadoop是一个由Apache基金会所开发的分布式系统基础架构。用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。&lt;br&gt;Hadoop实现了一个分布式文件系统（Hadoop Distributed File System），简称HDFS。HDFS有高容错性的特点，并且设计用来部署在低廉的（low-cost）硬件上；而且它提供高吞吐量（high throughput）来访问应用程序的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS放宽了（relax）POSIX的要求，可以以流的形式访问（streaming access）文件系统中的数据。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Hadoop" scheme="https://www.ggstu.com/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Linux下（CentOS7）安装与配置JDK1.8（上传安装方式）</title>
    <link href="https://www.ggstu.com/2018/08/30/Linux%E4%B8%8B%EF%BC%88CentOS7%EF%BC%89%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AEJDK1-8%EF%BC%88%E4%B8%8A%E4%BC%A0%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F%EF%BC%89/"/>
    <id>https://www.ggstu.com/2018/08/30/Linux下（CentOS7）安装与配置JDK1-8（上传安装方式）/</id>
    <published>2018-08-30T03:31:05.000Z</published>
    <updated>2018-08-31T06:25:21.572Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中已经介绍了如果使用wget命令安装配置JDK环境，之所以再写这篇使用上传的方式安装配置JDK环境，是因为在Linux上下载JDK可能网速会比较慢，下载时间可能较长，所以可以在Windows本地下载后上传到Linux上。<br>个人认为使用wget命令下载配置JDK还是比较方便的，如果wget命令下载速度太慢或者失败可以使用这种方法。<br><a id="more"></a><br><br></p><p><font size="4"><b>一、本地下载JDK1.8安装包：</b></font><br>点击下方链接到官网下载JDK1.8<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a><br>接受许可证协议，然后点击jdk-8u181-linux-x64.tar.gz进行下载<br><img src="http://pd8lpasbc.bkt.clouddn.com/35-1.png" width="100%" height="100%"></p><p><font size="4"><b>二、Linux上创建安装目录：</b></font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Master ~]# mkdir tools</span><br></pre></td></tr></table></figure></p><p><font size="4"><b>三、使用WinSCP将下载好的JDK上传到上一步创建的目录中：</b></font><br>选择压缩包，按下F5快捷键进行上传<br><img src="http://pd8lpasbc.bkt.clouddn.com/35-2.png" width="100%" height="100%"><br>上传完成后，可以查看到tools目录下有了JDK的压缩包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@Master ~]# cd tools/</span><br><span class="line">[root@Master tools]# ls</span><br><span class="line">jdk-8u181-linux-x64.tar.gz</span><br></pre></td></tr></table></figure></p><p><font size="4"><b>四、创建解压后目录并解压压缩包：</b></font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@Master tools]# mkdir ~/software</span><br><span class="line">[root@Master tools]# tar -zxvf jdk-8u181-linux-x64.tar.gz -C ~/software</span><br><span class="line">[root@Master tools]# cd ~/software/</span><br><span class="line">[root@Master software]# ls</span><br><span class="line">jdk1.8.0_181</span><br></pre></td></tr></table></figure></p><p>解压完成后查看JAVA_HOME所在位置，/root/software/jdk1.8.0_181就是JAVA_HOME所在位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@Master software]# cd jdk1.8.0_181/</span><br><span class="line">[root@Master jdk1.8.0_181]# pwd</span><br><span class="line">/root/software/jdk1.8.0_181</span><br></pre></td></tr></table></figure></p><p><font size="4"><b>五、设置环境变量：</b></font><br>修改bash_profile配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Master jdk1.8.0_181]# vi ~/.bash_profile</span><br></pre></td></tr></table></figure></p><p>在bash_profile文件末尾添加如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/root/software/jdk1.8.0_181</span><br><span class="line">export JAVA_HOME</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure></p><p>添加完成后，保存退出</p><p><font color="#f00">注意：</font>这里设置的JAVA_HOME即为上一步中查看到的JAVA_HOME</p><p><font size="4"><b>六、生效环境变量：</b></font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Master jdk1.8.0_181]# source ~/.bash_profile</span><br></pre></td></tr></table></figure></p><p><font size="4"><b>七、查看JDK版本：</b></font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@Master jdk1.8.0_181]# java -version</span><br><span class="line">java version &quot;1.8.0_181&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_181-b13)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)</span><br></pre></td></tr></table></figure></p><p><br><br>如果在安装过程中遇到什么问题，欢迎评论。<br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中已经介绍了如果使用wget命令安装配置JDK环境，之所以再写这篇使用上传的方式安装配置JDK环境，是因为在Linux上下载JDK可能网速会比较慢，下载时间可能较长，所以可以在Windows本地下载后上传到Linux上。&lt;br&gt;个人认为使用wget命令下载配置JDK还是比较方便的，如果wget命令下载速度太慢或者失败可以使用这种方法。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Java" scheme="https://www.ggstu.com/tags/Java/"/>
    
      <category term="Linux" scheme="https://www.ggstu.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下（CentOS7）安装与配置JDK1.8（wget命令安装方式）</title>
    <link href="https://www.ggstu.com/2018/08/30/Linux%E4%B8%8B%EF%BC%88CentOS7%EF%BC%89%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AEJDK1-8%EF%BC%88wget%E5%91%BD%E4%BB%A4%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F%EF%BC%89/"/>
    <id>https://www.ggstu.com/2018/08/30/Linux下（CentOS7）安装与配置JDK1-8（wget命令安装方式）/</id>
    <published>2018-08-30T02:13:31.000Z</published>
    <updated>2018-08-31T03:20:34.462Z</updated>
    
    <content type="html"><![CDATA[<p>下面我来介绍一下如何使用wget命令在linux中安装与配置JDK1.8。<br>写这篇博客的原因是因为我发现在网上许多使用wget命令下载jdk都会报错，所以我在下面提供了正确的wget命令下载jdk的语法。<br><a id="more"></a><br><br></p><p><font size="4"><b>一、创建目录并下载JDK：</b></font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu ~]# mkdir tools</span><br><span class="line">[root@ggstu ~]# cd tools</span><br><span class="line">[root@ggstu tools]# wget -c --header &quot;Cookie:oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz</span><br><span class="line">[root@ggstu tools]# ls</span><br><span class="line">jdk-8u131-linux-x64.tar.gz</span><br></pre></td></tr></table></figure></p><p><font size="4"><b>二、创建解压后目录并解压压缩包：</b></font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu tools]# mkdir ~/software</span><br><span class="line">[root@ggstu tools]# tar -zxvf jdk-8u131-linux-x64.tar.gz -C ~/software</span><br><span class="line">[root@ggstu tools]# cd ~/software/</span><br><span class="line">[root@ggstu software]# ls</span><br><span class="line">jdk1.8.0_131</span><br></pre></td></tr></table></figure></p><p>解压完成后查看JAVA_HOME所在位置，/root/software/jdk1.8.0_131就是JAVA_HOME所在位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu software]# cd jdk1.8.0_131/</span><br><span class="line">[root@ggstu jdk1.8.0_131]# pwd</span><br><span class="line">/root/software/jdk1.8.0_131</span><br></pre></td></tr></table></figure></p><p><font size="4"><b>三、设置环境变量：</b></font><br>修改bash_profile配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu jdk1.8.0_131]# vi ~/.bash_profile</span><br></pre></td></tr></table></figure></p><p>在bash_profile文件末尾添加如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/root/software/jdk1.8.0_131</span><br><span class="line">export JAVA_HOME</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure></p><p>添加完成后，保存退出</p><p><font color="#f00">注意：</font>这里设置的JAVA_HOME即为第二步中查看到的JAVA_HOME</p><p><font size="4"><b>四、生效环境变量：</b></font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu jdk1.8.0_131]# source ~/.bash_profile</span><br></pre></td></tr></table></figure></p><p><font size="4"><b>五、查看JDK版本：</b></font><br>输入命令java -version查看JDK版本，打印出如下内容说明环境安装配置完成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@ggstu jdk1.8.0_131]# java -version</span><br><span class="line">java version &quot;1.8.0_131&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_131-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)</span><br></pre></td></tr></table></figure></p><p><br><br>如果在安装过程中遇到什么问题，欢迎评论。<br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面我来介绍一下如何使用wget命令在linux中安装与配置JDK1.8。&lt;br&gt;写这篇博客的原因是因为我发现在网上许多使用wget命令下载jdk都会报错，所以我在下面提供了正确的wget命令下载jdk的语法。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Java" scheme="https://www.ggstu.com/tags/Java/"/>
    
      <category term="Linux" scheme="https://www.ggstu.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Scala中的Actor</title>
    <link href="https://www.ggstu.com/2018/08/26/Scala%E4%B8%AD%E7%9A%84Actor/"/>
    <id>https://www.ggstu.com/2018/08/26/Scala中的Actor/</id>
    <published>2018-08-26T01:41:44.000Z</published>
    <updated>2018-08-26T02:31:22.671Z</updated>
    
    <content type="html"><![CDATA[<p>Scala的Actor类似于Java中的多线程编程。但是Scala的Actor尽可能地避免锁和共享状态，从而避免多线程并发时出现资源争用的情况，进而提升多线程编程的性能。<br>Scala的Actor模型与Java的多线程模型之间很大的一个区别就是，Scala Actor支持线程之间的精准通信，即一个actor可以给其它actor直接发送消息。<br><a id="more"></a><br><strong>Actor的创建、启动和消息收发</strong><br>Scala提供了Actor trait来方便地进行actor多线程编程，Actor trait类似于Java中的Thread和Runnable，是基础的多线程基类和接口。只要重写Actor trait的act方法，即可实现自己的线程执行体，与Java中重写run方法类似。<br>使用start方法启动actor。使用!符号，向actor发送消息。actor内部使用receive和模式匹配接收消息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.actors.Actor</span><br><span class="line"></span><br><span class="line">scala&gt; class HelloActor extends Actor&#123;</span><br><span class="line">     |     def act()&#123;</span><br><span class="line">     |         while(true)&#123;</span><br><span class="line">     |             receive&#123;</span><br><span class="line">     |                 case name:String =&gt; println(&quot;Hello,&quot; +name)</span><br><span class="line">     |             &#125;</span><br><span class="line">     |         &#125;</span><br><span class="line">     |     &#125;</span><br><span class="line">     | &#125;</span><br><span class="line"></span><br><span class="line">scala&gt; val p = new HelloActor</span><br><span class="line"></span><br><span class="line">scala&gt; p.start()</span><br><span class="line">res0: scala.actors.Actor = HelloActor@53dad875</span><br><span class="line"></span><br><span class="line">scala&gt; p ! &quot;Tom&quot;</span><br><span class="line">Hello,Tom</span><br></pre></td></tr></table></figure></p><p><br><br><strong>收发case class类型的消息</strong><br>在scala中，通常建议使用case class，即样本类作为消息进行发送。然后在actor接收消息之后，可以使用scala模式匹配功能来进行不同消息的处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.actors.Actor</span><br><span class="line"></span><br><span class="line">scala&gt; case class Person(name:String)</span><br><span class="line"></span><br><span class="line">scala&gt; case class Fruit(name:String)</span><br><span class="line"></span><br><span class="line">scala&gt; class HelloActor extends Actor&#123;</span><br><span class="line">     |     def act()&#123;</span><br><span class="line">     |         while(true)&#123;</span><br><span class="line">     |             receive&#123;</span><br><span class="line">     |                 case Person(name) =&gt; println(&quot;Hello,&quot; + name)</span><br><span class="line">     |                 case Fruit(name) =&gt; println(&quot;Hello,&quot; + name + &quot;.I want to eat you.&quot;)</span><br><span class="line">     |             &#125;</span><br><span class="line">     |         &#125;</span><br><span class="line">     |     &#125;</span><br><span class="line">     | &#125;</span><br><span class="line"></span><br><span class="line">scala&gt; val p = new HelloActor</span><br><span class="line"></span><br><span class="line">scala&gt; p.start()</span><br><span class="line">res0: scala.actors.Actor = HelloActor@59dc36d4</span><br><span class="line"></span><br><span class="line">scala&gt; p ! Person(&quot;Tom&quot;)</span><br><span class="line">Hello,Tom</span><br><span class="line"></span><br><span class="line">scala&gt; p ! Fruit(&quot;Apple&quot;)</span><br><span class="line">Hello,Apple.I want to eat you.</span><br></pre></td></tr></table></figure></p><p><br><br><strong>Actor之间互相收发消息</strong><br>如果两个Actor之间要互相收发消息，一个actor向另外一个actor发送消息，要带上自己的引用，其它actor收到消息时，直接通过发送消息的actor的引用，即可以给它回复消息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.actors.Actor</span><br><span class="line"></span><br><span class="line">scala&gt; case class SendMessage(content:String,sender:Actor)</span><br><span class="line"></span><br><span class="line">scala&gt; class TomActor extends Actor&#123;</span><br><span class="line">     |     def act()&#123;</span><br><span class="line">     |         while(true)&#123;</span><br><span class="line">     |             receive&#123;</span><br><span class="line">     |                 case SendMessage(content,sender) =&gt; &#123;</span><br><span class="line">     |                     println(&quot;Send:Hello,I&apos;m Tom: &quot; + content)</span><br><span class="line">     |                     sender ! &quot;Receive:I&apos;m Tom,I&apos;m busy now.&quot;</span><br><span class="line">     |                 &#125;</span><br><span class="line">     |             &#125;</span><br><span class="line">     |         &#125;</span><br><span class="line">     |     &#125;</span><br><span class="line">     | &#125;</span><br><span class="line"></span><br><span class="line">scala&gt; class BobActor(val tomActor:Actor) extends Actor&#123;</span><br><span class="line">     |     def act()&#123;</span><br><span class="line">     |         tomActor ! SendMessage(&quot;Receive:Hello,Tom.I&apos;m Bob.&quot;,this)</span><br><span class="line">     |         while(true)&#123;</span><br><span class="line">     |             receive&#123;</span><br><span class="line">     |                 case response:String =&gt; println(&quot;Send:Hello,I&apos;m Bob: &quot; + response)</span><br><span class="line">     |             &#125;</span><br><span class="line">     |         &#125;</span><br><span class="line">     |     &#125;</span><br><span class="line">     | &#125;</span><br><span class="line"></span><br><span class="line">scala&gt; val tom = new TomActor</span><br><span class="line"></span><br><span class="line">scala&gt; val bob = new BobActor(tom)</span><br><span class="line"></span><br><span class="line">scala&gt; tom.start()</span><br><span class="line"></span><br><span class="line">scala&gt; bob.start()</span><br><span class="line"></span><br><span class="line">scala&gt; Send:Hello,I&apos;m Tom: Receive:Hello,Tom.I&apos;m Bob.</span><br><span class="line">Send:Hello,I&apos;m Bob: Receive:I&apos;m Tom,I&apos;m busy now.</span><br></pre></td></tr></table></figure></p><p><br><br><strong>同步消息和Future</strong><br>默认情况下，消息都是异步的，但是如果希望发送的消息是同步的，即对方接收后，一定要给自己返回结果，那么可以使用!?的方式发送消息。<br>val reply = actor !? message<br>如果要异步发送一个消息，但是在后续要获得消息的返回值，那么可以使用Future。即!!语法。<br>val future = actor !! message<br>val reply = future()<br><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scala的Actor类似于Java中的多线程编程。但是Scala的Actor尽可能地避免锁和共享状态，从而避免多线程并发时出现资源争用的情况，进而提升多线程编程的性能。&lt;br&gt;Scala的Actor模型与Java的多线程模型之间很大的一个区别就是，Scala Actor支持线程之间的精准通信，即一个actor可以给其它actor直接发送消息。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala的隐式转换函数、隐式参数和隐式类</title>
    <link href="https://www.ggstu.com/2018/08/25/Scala%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%E3%80%81%E9%9A%90%E5%BC%8F%E5%8F%82%E6%95%B0%E5%92%8C%E9%9A%90%E5%BC%8F%E7%B1%BB/"/>
    <id>https://www.ggstu.com/2018/08/25/Scala的隐式转换函数、隐式参数和隐式类/</id>
    <published>2018-08-25T12:30:37.000Z</published>
    <updated>2018-08-25T13:44:52.223Z</updated>
    
    <content type="html"><![CDATA[<p><strong>隐式转换函数</strong><br>Scala的隐式转换函数是以implicit关键字声明的带有单个参数的函数。<br>Scala会根据隐式转换函数的签名，在程序中使用到隐式转换函数接收的参数类型定义的对象时，会自动将其传入隐式转换函数，转换为另外一种类型的对象并返回。这就是“隐式转换”。<br>通常建议将隐式转换函数的名称命名为“源类型2目标类型”的形式。<br><a id="more"></a><br>隐式转换的发生时机：<br>1、调用某个函数，但是给函数传入的参数的类型，与函数定义的接收参数类型不匹配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student(val name:String)</span><br><span class="line"></span><br><span class="line">scala&gt; class Teacher(val name:String)</span><br><span class="line"></span><br><span class="line">scala&gt; class Person(val name:String)</span><br><span class="line"></span><br><span class="line">scala&gt; class Fruit(val name:String)</span><br><span class="line"></span><br><span class="line">scala&gt; implicit def object2person(obj:Object):Person = &#123;</span><br><span class="line">     |     if(obj.getClass == classOf[Student])&#123;</span><br><span class="line">     |         val stu = obj.asInstanceOf[Student]</span><br><span class="line">     |         new Person(stu.name)</span><br><span class="line">     |     &#125;else if(obj.getClass == classOf[Teacher])&#123;</span><br><span class="line">     |         val t = obj.asInstanceOf[Teacher]</span><br><span class="line">     |         new Person(t.name)</span><br><span class="line">     |     &#125;else Nil</span><br><span class="line">     | &#125;</span><br><span class="line">                                                      ^</span><br><span class="line">scala&gt; def sayHello(p:Person) = println(&quot;Hello,I&apos;m &quot; + p.name)</span><br><span class="line">sayHello: (p: Person)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student(&quot;Tom&quot;)</span><br><span class="line"></span><br><span class="line">scala&gt; sayHello(s)</span><br><span class="line">Hello,I&apos;m Tom</span><br><span class="line"></span><br><span class="line">scala&gt; val v = new Fruit(&quot;Apple&quot;)</span><br><span class="line"></span><br><span class="line">scala&gt; sayHello(v)</span><br></pre></td></tr></table></figure></p><p>2、使用某个类型的对象，调用某个方法，而这个方法并不存在于该类型时。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Man(val name:String)</span><br><span class="line"></span><br><span class="line">scala&gt; class Superman(val name:String)&#123;</span><br><span class="line">     |    def fly = println(&quot;Ha,ha,ha,I can fly.&quot;)</span><br><span class="line">     | &#125;</span><br><span class="line"></span><br><span class="line">scala&gt; implicit def man2superman(man:Man):Superman = new Superman(man.name)</span><br><span class="line">man2superman: (man: Man)Superman</span><br><span class="line"></span><br><span class="line">scala&gt; val m = new Man(&quot;Tom&quot;)</span><br><span class="line"></span><br><span class="line">scala&gt; m.fly</span><br><span class="line">Ha,ha,ha,I can fly.</span><br></pre></td></tr></table></figure></p><p>3、使用某个类型的对象，调用某个方法，虽然该类型有这个方法，但是给方法传入的参数类型，与方法定义的接收参数的类型不匹配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student(val name:String)</span><br><span class="line"></span><br><span class="line">scala&gt; class Teacher(val name:String)</span><br><span class="line"></span><br><span class="line">scala&gt; class Person(val name:String)</span><br><span class="line"></span><br><span class="line">scala&gt; implicit def object2person(obj:Object):Person = &#123;</span><br><span class="line">     |     if(obj.getClass == classOf[Student])&#123;</span><br><span class="line">     |         val stu = obj.asInstanceOf[Student]</span><br><span class="line">     |         new Person(stu.name)</span><br><span class="line">     |     &#125;else if(obj.getClass == classOf[Teacher])&#123;</span><br><span class="line">     |         val t = obj.asInstanceOf[Teacher]</span><br><span class="line">     |         new Person(t.name)</span><br><span class="line">     |     &#125;else Nil</span><br><span class="line">     | &#125;</span><br><span class="line">object2person: (obj: Object)Person</span><br><span class="line"></span><br><span class="line">scala&gt; class Hello&#123;</span><br><span class="line">     |     def sayHello(p:Person) = println(&quot;Hello,I&apos;m &quot; + p.name)</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Hello</span><br><span class="line"></span><br><span class="line">scala&gt; val h = new Hello</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student(&quot;Tom&quot;)</span><br><span class="line"></span><br><span class="line">scala&gt; h.sayHello(s)</span><br><span class="line">Hello,I&apos;m Tom</span><br></pre></td></tr></table></figure></p><p><br><br><strong>隐式参数</strong><br>使用implicit声明的函数参数叫做隐式参数。<br>Scala会在两个位置查找隐式参数：一种是当前作用域内可见的val或var定义的隐式变量；一种是隐式参数类型的伴生对象内的隐式值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sayHello(implicit name:String) = println(&quot;Hello,I&apos;m &quot; + name)</span><br><span class="line">sayHello: (implicit name: String)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; implicit val name:String = &quot;Tom&quot;</span><br><span class="line">name: String = Tom</span><br><span class="line"></span><br><span class="line">scala&gt; sayHello</span><br><span class="line">Hello,I&apos;m Tom</span><br></pre></td></tr></table></figure></p><p><br><br><strong>隐式类</strong><br>隐式类就是对类增加implicit限定的类，其主要作用就是增强类的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; 1.add(2)</span><br><span class="line">&lt;console&gt;:12: error: value add is not a member of Int</span><br><span class="line">       1.add(2)</span><br><span class="line">         ^</span><br><span class="line"></span><br><span class="line">scala&gt; implicit class Calc(x:Int)&#123;</span><br><span class="line">     |     def add(a:Int):Int = a + x</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Calc</span><br><span class="line"></span><br><span class="line">scala&gt; 1.add(2)</span><br><span class="line">res0: Int = 3</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;隐式转换函数&lt;/strong&gt;&lt;br&gt;Scala的隐式转换函数是以implicit关键字声明的带有单个参数的函数。&lt;br&gt;Scala会根据隐式转换函数的签名，在程序中使用到隐式转换函数接收的参数类型定义的对象时，会自动将其传入隐式转换函数，转换为另外一种类型的对象并返回。这就是“隐式转换”。&lt;br&gt;通常建议将隐式转换函数的名称命名为“源类型2目标类型”的形式。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala的协变和逆变</title>
    <link href="https://www.ggstu.com/2018/08/25/Scala%E7%9A%84%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/"/>
    <id>https://www.ggstu.com/2018/08/25/Scala的协变和逆变/</id>
    <published>2018-08-25T11:33:06.000Z</published>
    <updated>2018-08-25T12:24:11.558Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中，如果定义父类A，子类B，那么根据多态性，A a = new B是可以编译通过的。<br>但是如果泛型B的集合直接赋给父类A的集合，即List&lt;A> aList = new ArrayList&lt;B>();会报错。<br>Scala的协变和逆变就是解决这一问题的存在。</p><p><strong>Scala的协变</strong><br><a id="more"></a><br>泛型变量的值可以是本身类型或者其子类的类型。<br>Scala的class或trait的泛型定义中，如果在类型参数前面加上+符号，就可以使类或特质变为协变。<br>例如：有了协变就可以把一个子类Bird的EatSomething[Bird]赋值给父类Animal的EatSomething[Animal]。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Animal</span><br><span class="line">defined class Animal</span><br><span class="line"></span><br><span class="line">scala&gt; class Bird extends Animal</span><br><span class="line">defined class Bird</span><br><span class="line"></span><br><span class="line">scala&gt; class EatSomething[+T](t:T)</span><br><span class="line">defined class EatSomething</span><br><span class="line"></span><br><span class="line">scala&gt; val s1:EatSomething[Bird] = new EatSomething[Bird](new Bird)</span><br><span class="line">s1: EatSomething[Bird] = EatSomething@59e505b2</span><br><span class="line"></span><br><span class="line">scala&gt; val s2:EatSomething[Animal] = s1</span><br><span class="line">s2: EatSomething[Animal] = EatSomething@59e505b2</span><br></pre></td></tr></table></figure></p><p><br><br><strong>Scala的逆变</strong><br><br><br>泛型变量的值可以是本身类型或者其父类的类型。<br>Scala的class或trait的泛型定义中，如果在类型参数前面加上-符号，就可以使类或特质变为逆变。<br>例如：有了逆变就可以把一个父类Animal的EatSomething[Animal]赋值给子类Bird的EatSomething[Bird]。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Animal</span><br><span class="line">defined class Animal</span><br><span class="line"></span><br><span class="line">scala&gt; class Bird extends Animal</span><br><span class="line">defined class Bird</span><br><span class="line"></span><br><span class="line">scala&gt; class EatSomething[-T](t:T)</span><br><span class="line">defined class EatSomething</span><br><span class="line"></span><br><span class="line">scala&gt; val s1:EatSomething[Animal] = new EatSomething[Animal](new Animal)</span><br><span class="line">s1: EatSomething[Animal] = EatSomething@82ea68c</span><br><span class="line"></span><br><span class="line">scala&gt; val s2:EatSomething[Bird] = s1</span><br><span class="line">s2: EatSomething[Bird] = EatSomething@82ea68c</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java中，如果定义父类A，子类B，那么根据多态性，A a = new B是可以编译通过的。&lt;br&gt;但是如果泛型B的集合直接赋给父类A的集合，即List&amp;lt;A&gt; aList = new ArrayList&amp;lt;B&gt;();会报错。&lt;br&gt;Scala的协变和逆变就是解决这一问题的存在。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scala的协变&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala泛型类型的视图界定和上下文界定</title>
    <link href="https://www.ggstu.com/2018/08/25/Scala%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A7%86%E5%9B%BE%E7%95%8C%E5%AE%9A%E5%92%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%95%8C%E5%AE%9A/"/>
    <id>https://www.ggstu.com/2018/08/25/Scala泛型类型的视图界定和上下文界定/</id>
    <published>2018-08-25T08:34:29.000Z</published>
    <updated>2018-08-25T11:18:37.947Z</updated>
    
    <content type="html"><![CDATA[<p><strong>视图界定View Bounds</strong><br>视图界定比上界&nbsp;&lt;:&nbsp;适用的范围更广，除了所有的子类型，还允许隐式转换过去的类型。用&nbsp;&lt;%&nbsp;表示。<br>例如：拼接字符串。这里由于T的上界是String，当参数传入整数100和200时，就会出现类型不匹配。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def addString[T&lt;:String](x:T,y:T) = println(x+&quot; &quot;+y)</span><br><span class="line">addString: [T &lt;: String](x: T, y: T)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; addString(&quot;Hello&quot;,&quot;World&quot;)</span><br><span class="line">Hello World</span><br><span class="line"></span><br><span class="line">scala&gt; addString(100,200)</span><br><span class="line">&lt;console&gt;:13: error: inferred type arguments [Int] do not conform to method addString&apos;s type parameter bounds [T &lt;: String]</span><br><span class="line">       addString(100,200)</span><br><span class="line">       ^</span><br><span class="line">&lt;console&gt;:13: error: type mismatch;</span><br><span class="line"> found   : Int(100)</span><br><span class="line"> required: T</span><br><span class="line">       addString(100,200)</span><br><span class="line">                 ^</span><br><span class="line">&lt;console&gt;:13: error: type mismatch;</span><br><span class="line"> found   : Int(200)</span><br><span class="line"> required: T</span><br><span class="line">       addString(100,200)</span><br><span class="line">                     ^</span><br></pre></td></tr></table></figure></p><p>但是整型数字是可以转换成字符串的，所以可以使用视图界定让addString方法接收更广泛的数据类型。<br>即：1、字符串及其子类；2、可以转换成字符串的类型。</p><p><font color="#f00">注意：</font>使用的是&nbsp;<font color="#f00">&lt;%</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def addString[T&lt;%String](x:T,y:T) = println(x+&quot; &quot;+y)</span><br><span class="line">addString: [T](x: T, y: T)(implicit evidence$1: T =&gt; String)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; addString(&quot;Hello&quot;,&quot;World&quot;)</span><br><span class="line">Hello World</span><br><span class="line"></span><br><span class="line">scala&gt; addString(100,200)</span><br><span class="line">&lt;console&gt;:13: error: No implicit view available from Int =&gt; String.</span><br><span class="line">       addString(100,200)</span><br><span class="line">                ^</span><br></pre></td></tr></table></figure></p><p>实际运行时发生了错误：<font color="#f00">No implicit view available from Int =&gt; String.</font><br>这是因为Scala并没有定义如何将Int转换成String的规则，所以要使用视图界定，就必须手动创建转换规则。<br>如下所示，创建了转换规则后，运行成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; implicit def int2String(n:Int):String = n.toString</span><br><span class="line">warning: there was one feature warning; re-run with -feature for details</span><br><span class="line">int2String: (n: Int)String</span><br><span class="line"></span><br><span class="line">scala&gt; addString(100,200)</span><br><span class="line">100 200</span><br></pre></td></tr></table></figure></p><p><br><br><strong>上下文界定Context Bounds</strong><br>上下文界定的类型参数形式为T:M的形式，其中M是一个泛型，这种形式要求存在一个M[T]类型的隐式值。<br>例如：使用Scala内置的比较器比较大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Calculator[T:Ordering](val number1:T,val number2:T)&#123;</span><br><span class="line">     |     def max(implicit order:Ordering[T]) = if(order.compare(number1,number2) &gt; 0) number1 else number2</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Calculator</span><br><span class="line"></span><br><span class="line">scala&gt; val cal = new Calculator(3,6)</span><br><span class="line">cal: Calculator[Int] = Calculator@3700ec9c</span><br><span class="line"></span><br><span class="line">scala&gt; cal.max</span><br><span class="line">res0: Int = 6</span><br></pre></td></tr></table></figure></p><p><br><br><strong>Manifest Context Bounds</strong><br>在Scala中，数组必须是有类型的，如果直接是泛型的话会报错，这时就必须使用Manifest上下文界定。<br>也就是说，如果数组元素类型为T的话，要实例化Array[T]这种泛型数组，需要为类或者函数定义[T:Manifest]泛型类型。<br>案例：将大人分成一组，将小孩分成一组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Child(val name:String)</span><br><span class="line"></span><br><span class="line">scala&gt; class Adult(val name:String)</span><br><span class="line"></span><br><span class="line">scala&gt; def toGroup[T:Manifest](p:T*) = &#123;</span><br><span class="line">     |     val group = new Array[T](p.length)</span><br><span class="line">     |     for(i &lt;- 0 until p.length) group(i) = p(i)</span><br><span class="line">     |     group</span><br><span class="line">     | &#125;</span><br><span class="line">toGroup: [T](p: T*)(implicit evidence$1: Manifest[T])Array[T]</span><br><span class="line"></span><br><span class="line">scala&gt; val child1 = new Child(&quot;Tom&quot;)</span><br><span class="line"></span><br><span class="line">scala&gt; val child2 = new Child(&quot;Bob&quot;)</span><br><span class="line"></span><br><span class="line">scala&gt; val child3 = new Child(&quot;Alice&quot;)</span><br><span class="line"></span><br><span class="line">scala&gt; val childGroup = toGroup(child1,child2,child3)</span><br><span class="line">childGroup: Array[Child] = Array(Child@7b22ec89, Child@4a1e3ac1, Child@4f449e8f)</span><br><span class="line"></span><br><span class="line">scala&gt; val adult1 = new Adult(&quot;Jack&quot;)</span><br><span class="line"></span><br><span class="line">scala&gt; val adult2 = new Adult(&quot;Jerry&quot;)</span><br><span class="line"></span><br><span class="line">scala&gt; val adult3 = new Adult(&quot;Peter&quot;)</span><br><span class="line"></span><br><span class="line">scala&gt; val adultGroup = toGroup(adult1,adult2,adult3)</span><br><span class="line">adultGroup: Array[Adult] = Array(Adult@1816e24a, Adult@4fad6218, Adult@112d1c8e)</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;视图界定View Bounds&lt;/strong&gt;&lt;br&gt;视图界定比上界&amp;nbsp;&amp;lt;:&amp;nbsp;适用的范围更广，除了所有的子类型，还允许隐式转换过去的类型。用&amp;nbsp;&amp;lt;%&amp;nbsp;表示。&lt;br&gt;例如：拼接字符串。这里由于T的上界是String，当参数传入整数100和200时，就会出现类型不匹配。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala泛型类型的上界(Upper Bounds)和下界(Lower Bounds)</title>
    <link href="https://www.ggstu.com/2018/08/25/Scala%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%8A%E7%95%8C-Upper-Bounds-%E5%92%8C%E4%B8%8B%E7%95%8C-Lower-Bounds/"/>
    <id>https://www.ggstu.com/2018/08/25/Scala泛型类型的上界-Upper-Bounds-和下界-Lower-Bounds/</id>
    <published>2018-08-25T07:18:08.000Z</published>
    <updated>2018-08-25T08:21:53.868Z</updated>
    
    <content type="html"><![CDATA[<p>在指定泛型类型的时候，有时需要对泛型类型的范围进行界定，而不是可以是任意的类型。<br>比如，要求某个泛型类型，它必须是某个类的子类，这样在程序中就可以放心的调用满足泛型条件的方法，程序才能正常的使用和运行。<br>Scala的上下边界特性允许泛型类型必须是某个类的子类，或者必须是某个类的父类。<br><a id="more"></a><br><strong>上界Upper Bounds</strong><br>定义：S&lt;:T，也就是类型S必须是类型T的子类（或本身，自己也可以是自己的子类。）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Vehicle&#123;</span><br><span class="line">    def drive() = println(&quot;Driving&quot;)</span><br><span class="line">&#125;</span><br><span class="line">class Car extends Vehicle&#123;</span><br><span class="line">    override def drive() = println(&quot;Car driving&quot;)</span><br><span class="line">&#125;</span><br><span class="line">class Person&#123;</span><br><span class="line">    def drive() = println(&quot;I&apos;m driving the car.&quot;)</span><br><span class="line">&#125;</span><br><span class="line">def takeVehicle[T &lt;: Vehicle](v:T) = v.drive()</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">scala&gt; val v:Vehicle = new Vehicle</span><br><span class="line">scala&gt; takeVehicle(v)</span><br><span class="line">Driving</span><br><span class="line"></span><br><span class="line">scala&gt; val c:Car = new Car</span><br><span class="line">scala&gt; takeVehicle(c)</span><br><span class="line">Car driving</span><br><span class="line"></span><br><span class="line">scala&gt; val p = new Person</span><br><span class="line">scala&gt; takeVehicle(p)</span><br><span class="line">&lt;console&gt;:16: error: inferred type arguments [Person] do not conform to method takeVehicle&apos;s type parameter bounds [T &lt;: Vehicle]</span><br><span class="line">       takeVehicle(p)</span><br><span class="line">       ^</span><br><span class="line">&lt;console&gt;:16: error: type mismatch;</span><br><span class="line"> found   : Person</span><br><span class="line"> required: T</span><br><span class="line">       takeVehicle(p)</span><br><span class="line">                   ^</span><br></pre></td></tr></table></figure></p><p><br><br><strong>下界Lower Bounds</strong><br>定义：U&gt;:T，也就是类型U必须是类型T的父类（或本身，自己也可以是自己的父类。）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Father</span><br><span class="line">defined class Father</span><br><span class="line"></span><br><span class="line">scala&gt; class Child extends Father</span><br><span class="line">defined class Child</span><br><span class="line"></span><br><span class="line">scala&gt; class Teacher</span><br><span class="line">defined class Teacher</span><br><span class="line"></span><br><span class="line">scala&gt; def getName[T &gt;: Child](person:T)&#123;</span><br><span class="line">     |     if(person.getClass == classOf[Child]) println(&quot;I&apos;m child.&quot;)</span><br><span class="line">     |     else if(person.getClass == classOf[Father]) println(&quot;I&apos;m father.&quot;)</span><br><span class="line">     |     else println(&quot;Sorry,don&apos;t know who you are.&quot;)</span><br><span class="line">     | &#125;</span><br><span class="line">getName: [T &gt;: Child](person: T)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; val p1 = new Father</span><br><span class="line">p1: Father = Father@3688eb5b</span><br><span class="line"></span><br><span class="line">scala&gt; getName(p1)</span><br><span class="line">I&apos;m father.</span><br><span class="line"></span><br><span class="line">scala&gt; val p2 = new Child</span><br><span class="line">p2: Child = Child@7f0d96f2</span><br><span class="line"></span><br><span class="line">scala&gt; getName(p2)</span><br><span class="line">I&apos;m child.</span><br><span class="line"></span><br><span class="line">scala&gt; val p3 = new Teacher</span><br><span class="line">p3: Teacher = Teacher@5143c662</span><br><span class="line"></span><br><span class="line">scala&gt; getName(p3)</span><br><span class="line">Sorry,don&apos;t know who you are.</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在指定泛型类型的时候，有时需要对泛型类型的范围进行界定，而不是可以是任意的类型。&lt;br&gt;比如，要求某个泛型类型，它必须是某个类的子类，这样在程序中就可以放心的调用满足泛型条件的方法，程序才能正常的使用和运行。&lt;br&gt;Scala的上下边界特性允许泛型类型必须是某个类的子类，或者必须是某个类的父类。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala的泛型类和泛型函数</title>
    <link href="https://www.ggstu.com/2018/08/25/Scala%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%92%8C%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0/"/>
    <id>https://www.ggstu.com/2018/08/25/Scala的泛型类和泛型函数/</id>
    <published>2018-08-25T06:25:35.000Z</published>
    <updated>2018-08-25T07:06:36.829Z</updated>
    
    <content type="html"><![CDATA[<p>在Scala中可以使用类型参数来实现类和函数，这样的类和函数可以用于多种类型。比如Array[T]可以存放任意指定类型T的数据。</p><p><strong>泛型类</strong>就是在类的声明中，定义一些泛型类型，然后在类内部，就可以使用这些泛型类型。直接给使用了泛型类型的字段赋值时，Scala会自动进行类型推断。使用泛型类，通常是需要对类中的某些成员，比如某些字段和方法中的参数或变量进行统一的类型限制，这样可以保证程序的健壮性和稳定性。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student[T](val name:T)&#123;</span><br><span class="line">     |     def getAge(age:T) = name + &quot;:&quot; + age + &quot; years old&quot;</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student(&quot;Tom&quot;)</span><br><span class="line">s: Student[String] = Student@366ac49b</span><br><span class="line"></span><br><span class="line">scala&gt; s.getAge(&quot;21&quot;)</span><br><span class="line">res0: String = Tom:21 years old</span><br><span class="line"></span><br><span class="line">scala&gt; s.getAge(21)</span><br><span class="line">&lt;console&gt;:14: error: type mismatch;</span><br><span class="line"> found   : Int(21)</span><br><span class="line"> required: String</span><br><span class="line">       s.getAge(21)</span><br><span class="line">                ^</span><br></pre></td></tr></table></figure><p><br><br><strong>泛型函数</strong>，与泛型类类似，可以给某个函数在声明时指定泛型类型。<br>与泛型类一样，可以通过给使用了泛型类型的变量传递值来让Scala自动推断泛型的实际类型，也可以在调用函数时，手动指定泛型类型。<br>例如：创建一个函数，既能创建Int类型的数据，也能创建String类型的数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.reflect.ClassTag</span><br><span class="line">import scala.reflect.ClassTag</span><br><span class="line"></span><br><span class="line">scala&gt; def mkArray[T:ClassTag](elems:T*) = Array[T](elems:_*)</span><br><span class="line">mkArray: [T](elems: T*)(implicit evidence$1: scala.reflect.ClassTag[T])Array[T]</span><br><span class="line"></span><br><span class="line">scala&gt; mkArray(1,2,3,4,5)</span><br><span class="line">res0: Array[Int] = Array(1, 2, 3, 4, 5)</span><br><span class="line"></span><br><span class="line">scala&gt; mkArray(&quot;Tom&quot;,&quot;Bob&quot;,&quot;Alice&quot;)</span><br><span class="line">res1: Array[String] = Array(Tom, Bob, Alice)</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Scala中可以使用类型参数来实现类和函数，这样的类和函数可以用于多种类型。比如Array[T]可以存放任意指定类型T的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;泛型类&lt;/strong&gt;就是在类的声明中，定义一些泛型类型，然后在类内部，就可以使用这些泛型类型。直接给使用了泛型类型的字段赋值时，Scala会自动进行类型推断。使用泛型类，通常是需要对类中的某些成员，比如某些字段和方法中的参数或变量进行统一的类型限制，这样可以保证程序的健壮性和稳定性。&lt;/p&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala的模式匹配</title>
    <link href="https://www.ggstu.com/2018/08/25/Scala%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <id>https://www.ggstu.com/2018/08/25/Scala的模式匹配/</id>
    <published>2018-08-24T23:41:08.000Z</published>
    <updated>2018-08-25T01:42:59.352Z</updated>
    
    <content type="html"><![CDATA[<p>Scala的模式匹配，即match case语法，类似于Java中的switch case语法，即对一个值进行条件判断，然后针对不同的条件，进行不同的处理。<br>Java的switch case语法只能对值进行匹配。但是Scala的模式匹配除了可以对值进行匹配之外，还可以对类型进行匹配、对Array和List的元素情况进行匹配、对case class进行匹配、甚至对有值或没值(Option)进行匹配。<br><a id="more"></a><br>match case中，只要一个case分支满足条件，就不会继续判断下一个case分支了。与Java不同，java的switch case需要用break停止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">def judgeGrade(grade:String)&#123;</span><br><span class="line">    grade match&#123;</span><br><span class="line">        case &quot;A&quot; =&gt; println(&quot;Excellent&quot;)</span><br><span class="line">        case &quot;B&quot; =&gt; println(&quot;Good&quot;)</span><br><span class="line">        case &quot;C&quot; =&gt; println(&quot;Not bad&quot;)</span><br><span class="line">        case _ =&gt; println(&quot;Work harder&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">judgeGrade: (grade: String)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; judgeGrade(&quot;A&quot;)</span><br><span class="line">Excellent</span><br><span class="line"></span><br><span class="line">scala&gt; judgeGrade(&quot;D&quot;)</span><br><span class="line">Work harder</span><br></pre></td></tr></table></figure></p><p><br><br><strong>在模式匹配中使用if守卫</strong><br>Scala的模式匹配case后的条件判断中，不仅仅可以只提供一个值，而是可以在值后面再加一个if守卫，进行双重过滤。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">def judgeGrade(name:String,grade:String)&#123;</span><br><span class="line">    grade match&#123;</span><br><span class="line">        case &quot;A&quot; =&gt; println(name + &quot;,excellent.&quot;)</span><br><span class="line">        case &quot;B&quot; =&gt; println(name + &quot;,good.&quot;)</span><br><span class="line">        case &quot;C&quot; =&gt; println(name + &quot;,not bad.&quot;)</span><br><span class="line">        case _ if name==&quot;Tom&quot; =&gt; println(&quot;Come on Tom,you need to work harder.&quot;)</span><br><span class="line">        case _ =&gt; println(name + &quot;,work harder.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">judgeGrade: (name: String, grade: String)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; judgeGrade(&quot;Tom&quot;,&quot;B&quot;)</span><br><span class="line">Tom,good.</span><br><span class="line"></span><br><span class="line">scala&gt; judgeGrade(&quot;Tom&quot;,&quot;E&quot;)</span><br><span class="line">Come on Tom,you need to work harder.</span><br><span class="line"></span><br><span class="line">scala&gt; judgeGrade(&quot;Bob&quot;,&quot;E&quot;)</span><br><span class="line">Bob,work harder.</span><br></pre></td></tr></table></figure></p><p><br><br><strong>模式匹配中的变量</strong><br>Scala的模式匹配可以将模式匹配的默认情况，下划线，替换为一个变量名，此时模式匹配语法就会将要匹配的值赋值给这个变量，从而可以在后面的处理语句中使用这个变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">def judgeGrade(grade:String)&#123;</span><br><span class="line">    grade match&#123;</span><br><span class="line">        case &quot;A&quot; =&gt; println(&quot;Excellent&quot;)</span><br><span class="line">        case &quot;B&quot; =&gt; println(&quot;Good&quot;)</span><br><span class="line">        case &quot;C&quot; =&gt; println(&quot;Not bad&quot;)</span><br><span class="line">        case lowGrade =&gt; println(&quot;Your grade is &quot; + lowGrade + &quot;,work harder.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">judgeGrade: (grade: String)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; judgeGrade(&quot;D&quot;)</span><br><span class="line">Your grade is D,work harder.</span><br></pre></td></tr></table></figure></p><p><br><br><strong>对类型进行模式匹配</strong><br>Scala的模式匹配可以直接匹配类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val v:Any = 100</span><br><span class="line">v: Any = 100</span><br><span class="line"></span><br><span class="line">scala&gt; v match&#123;</span><br><span class="line">     |     case x:Int =&gt; println(&quot;Integer: &quot; + x)</span><br><span class="line">     |     case s:String =&gt; println(&quot;String: &quot; + s)</span><br><span class="line">     |     case _ =&gt; println(&quot;Other type.&quot;)</span><br><span class="line">     | &#125;</span><br><span class="line">Integer: 100</span><br></pre></td></tr></table></figure></p><p><br><br><strong>对Array和List进行模式匹配</strong><br>对Array进行模式匹配，可以匹配带有指定元素的数组、带有指定个数元素的数组、以某元素打头的数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a = Array(1,2,3)</span><br><span class="line">a: Array[Int] = Array(1, 2, 3)</span><br><span class="line"></span><br><span class="line">scala&gt; a match&#123;</span><br><span class="line">     |     case Array(0) =&gt; println(&quot;0&quot;)</span><br><span class="line">     |     case Array(x,y) =&gt; println(&quot;This array contains two elements,the sum is &quot; + (x+y))</span><br><span class="line">     |     case Array(x,y,z) =&gt; println(&quot;This array contains three elements,the product is &quot; + (x*y*z))</span><br><span class="line">     |     case Array(x,_*) =&gt; println(&quot;This is an array.&quot;)</span><br><span class="line">     | &#125;</span><br><span class="line">This array contains three elements,the product is 6</span><br></pre></td></tr></table></figure></p><p>对List进行模式匹配，与Array类似，但是需要使用List特有的::操作符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val list = List(1,2,3)</span><br><span class="line">list: List[Int] = List(1, 2, 3)</span><br><span class="line"></span><br><span class="line">scala&gt; list match&#123;</span><br><span class="line">     |     case 1::Nil =&gt; println(&quot;This is List(1)&quot;)</span><br><span class="line">     |     case 1::2::Nil =&gt; println(&quot;This is List(1,2)&quot;)</span><br><span class="line">     |     case 1::tail =&gt; println(&quot;This is List:&quot; + list)</span><br><span class="line">     |     case _ =&gt; println(&quot;Other list.&quot;)</span><br><span class="line">     | &#125;</span><br><span class="line">This is List:List(1, 2, 3)</span><br></pre></td></tr></table></figure></p><p><br><br><strong>样本类case class与模式匹配</strong><br>Scala中提供了样本类，用case class进行声明。<br>case class的主构造函数接收的参数通常不需要使用var或val修饰，Scala自动就会使用val修饰。<br>Scala自动为case class定义了伴生对象，也就是object，并且定义了apply()方法，该方法接收主构造函数中相同的参数，并返回case class对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Vehicle</span><br><span class="line">case class Car(name:String) extends Vehicle</span><br><span class="line">case class Bicycle(name:String) extends Vehicle</span><br><span class="line"></span><br><span class="line">def judgeVehicle(v:Vehicle)&#123;</span><br><span class="line">    v match&#123;</span><br><span class="line">        case Car(name) =&gt; println(&quot;I&apos;m a car.I&apos;m &quot; + name)</span><br><span class="line">        case Bicycle(name) =&gt; println(&quot;I&apos;m a bicycle.I&apos;m &quot; + name)</span><br><span class="line">        case _ =&gt; println(&quot;Other vehicle.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Vehicle</span><br><span class="line">defined class Car</span><br><span class="line">defined class Bicycle</span><br><span class="line">judgeVehicle: (v: Vehicle)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; val aCar:Vehicle = new Car(&quot;Rolls-Royce&quot;)</span><br><span class="line">aCar: Vehicle = Car(Rolls-Royce)</span><br><span class="line"></span><br><span class="line">scala&gt; judgeVehicle(aCar)</span><br><span class="line">I&apos;m a car.I&apos;m Rolls-Royce</span><br></pre></td></tr></table></figure></p><p><br><br><strong>Option与模式匹配</strong><br>Scala有一种特殊的类型，叫做Option。Option有两种值，一种是Some，表示有值，一种是None，表示没有值。<br>Option通常会用于模式匹配中，用于判断某个变量是有值还是没有值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val grades = Map(&quot;Tom&quot;-&gt;&quot;A&quot;,&quot;Bob&quot;-&gt;&quot;B&quot;,&quot;Alice&quot;-&gt;&quot;C&quot;)</span><br><span class="line">grades: scala.collection.immutable.Map[String,String] = Map(Tom -&gt; A, Bob -&gt; B, Alice -&gt; C)</span><br><span class="line"></span><br><span class="line">scala&gt; def getGrade(name:String)&#123;</span><br><span class="line">     |     val grade = grades.get(name)</span><br><span class="line">     |     grade match&#123;</span><br><span class="line">     |         case Some(grade) =&gt; println(&quot;Your grade is &quot; + grade)</span><br><span class="line">     |         case None =&gt; println(&quot;Sorry,your grade information is not in the system.&quot;)</span><br><span class="line">     |     &#125;</span><br><span class="line">     | &#125;</span><br><span class="line">getGrade: (name: String)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; getGrade(&quot;Tom&quot;)</span><br><span class="line">Your grade is A</span><br><span class="line"></span><br><span class="line">scala&gt; getGrade(&quot;Jerry&quot;)</span><br><span class="line">Sorry,your grade information is not in the system.</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scala的模式匹配，即match case语法，类似于Java中的switch case语法，即对一个值进行条件判断，然后针对不同的条件，进行不同的处理。&lt;br&gt;Java的switch case语法只能对值进行匹配。但是Scala的模式匹配除了可以对值进行匹配之外，还可以对类型进行匹配、对Array和List的元素情况进行匹配、对case class进行匹配、甚至对有值或没值(Option)进行匹配。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala集合中的List和Set</title>
    <link href="https://www.ggstu.com/2018/08/24/Scala%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84List%E5%92%8CSet/"/>
    <id>https://www.ggstu.com/2018/08/24/Scala集合中的List和Set/</id>
    <published>2018-08-24T09:25:44.000Z</published>
    <updated>2018-08-24T13:02:27.026Z</updated>
    
    <content type="html"><![CDATA[<p>Scala的集合体系主要包括：Iterable、Seq、Set、Map。其中Iterable是所有集合trait的根trait。<br>Scala的集合分成可变和不可变两类集合，可变集合指集合的元素可以动态修改，不可变集合指集合的元素在初始化之后不能修改。分别对应scala.collection.mutable和scala.collection.immutable两个包。<br>Seq下包含了Range、ArrayBuffer、List等子trait。其中Range就代表了一个序列，通常可以使用”1 to 10”这种语法来产生一个Range。ArrayBuffer就类似于Java中的ArrayList。<br><a id="more"></a><br>下面这张图就是Scala的集合结构<br><img src="http://pd8lpasbc.bkt.clouddn.com/26-1.jpg" alt="Scala的集合结构"><br><br><br>下面就来介绍一下常用的List集合和Set集合<br><br><br><strong>不可变列表List</strong><br>List代表一个不可变的列表。<br>List的创建：<br>字符串列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val nameList = List(&quot;Tom&quot;,&quot;Bob&quot;,&quot;Alice&quot;)</span><br><span class="line">nameList: List[String] = List(Tom, Bob, Alice)</span><br></pre></td></tr></table></figure></p><p>整数列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val intList = List(1,2,3,4,5)</span><br><span class="line">intList: List[Int] = List(1, 2, 3, 4, 5)</span><br></pre></td></tr></table></figure></p><p>空列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val nullList = List()</span><br><span class="line">nullList: List[Nothing] = List()</span><br></pre></td></tr></table></figure></p><p>二维列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val dim:List[List[Int]] = List(List(1,2,3),List(4,5,6))</span><br><span class="line">dim: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6))</span><br></pre></td></tr></table></figure></p><p>不可变列表中的元素不可改变，如果修改其中的元素，会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val list = List(1,2,3,4)</span><br><span class="line">list: List[Int] = List(1, 2, 3, 4)</span><br><span class="line"></span><br><span class="line">scala&gt; list += 5</span><br><span class="line">&lt;console&gt;:13: error: value += is not a member of List[Int]</span><br><span class="line">       list += 5</span><br><span class="line">            ^</span><br></pre></td></tr></table></figure></p><p>List有head和tail，head表示List的第一个元素，tail表示除了第一个元素之后的所有元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val intList = List(1,2,3,4,5)</span><br><span class="line">intList: List[Int] = List(1, 2, 3, 4, 5)</span><br><span class="line"></span><br><span class="line">scala&gt; intList.head</span><br><span class="line">res0: Int = 1</span><br><span class="line"></span><br><span class="line">scala&gt; intList.tail</span><br><span class="line">res1: List[Int] = List(2, 3, 4, 5)</span><br></pre></td></tr></table></figure></p><p>List有特殊的::操作符，可以用于将head和tail合并成一个List。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val list1 = List(2,3,4,5)</span><br><span class="line">list1: List[Int] = List(2, 3, 4, 5)</span><br><span class="line"></span><br><span class="line">scala&gt; val list2 = 1::list1</span><br><span class="line">list2: List[Int] = List(1, 2, 3, 4, 5)</span><br></pre></td></tr></table></figure></p><p>使用List的例子：用递归函数给List中每个元素都加上指定前缀<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">def addPrefix(t:List[Int],prefix:String)&#123;</span><br><span class="line">    if(t != Nil)&#123;</span><br><span class="line">        println(prefix + t.head)</span><br><span class="line">        addPrefix(t.tail,prefix)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">addPrefix: (t: List[Int], prefix: String)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; addPrefix(List(1,2,3,4,5),&quot;*&quot;)</span><br><span class="line">*1</span><br><span class="line">*2</span><br><span class="line">*3</span><br><span class="line">*4</span><br><span class="line">*5</span><br></pre></td></tr></table></figure></p><p><br><br><strong>可变列表LinkedList(MutableList)</strong><br>LinkedList代表一个可变的列表，需要导入scala.collection.mutable._<br>elem表示LinkedList的第一个元素，next表示除了第一个元素之后的所有元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val t = scala.collection.mutable.LinkedList(1,2,3,4,5)</span><br><span class="line">warning: there was one deprecation warning; re-run with -deprecation for details</span><br><span class="line">t: scala.collection.mutable.LinkedList[Int] = LinkedList(1, 2, 3, 4, 5)</span><br><span class="line"></span><br><span class="line">scala&gt; t.elem</span><br><span class="line">res0: Int = 1</span><br><span class="line"></span><br><span class="line">scala&gt; t.next</span><br><span class="line">res1: scala.collection.mutable.LinkedList[Int] = LinkedList(2, 3, 4, 5)</span><br></pre></td></tr></table></figure></p><p>这里看到一条警告：<font color="#f00">warning: there was one deprecation warning;</font>因为LinkedList在Scala 2.11已被弃用。<br>官方文档给出的做法是使用MutableList代替LinkedList。<br>head表示MutableList的第一个元素，tail表示除了第一个元素之后的所有元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val t = scala.collection.mutable.MutableList(1,2,3,4,5)</span><br><span class="line">t: scala.collection.mutable.MutableList[Int] = MutableList(1, 2, 3, 4, 5)</span><br><span class="line"></span><br><span class="line">scala&gt; t.head</span><br><span class="line">res0: Int = 1</span><br><span class="line"></span><br><span class="line">scala&gt; t.tail</span><br><span class="line">res1: scala.collection.mutable.MutableList[Int] = MutableList(2, 3, 4, 5)</span><br></pre></td></tr></table></figure></p><p>例如：向MutableList列表中添加元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.collection.mutable._</span><br><span class="line">import scala.collection.mutable._</span><br><span class="line"></span><br><span class="line">scala&gt; val t = MutableList(1,2,3,4)</span><br><span class="line">t: scala.collection.mutable.MutableList[Int] = MutableList(1, 2, 3, 4)</span><br><span class="line"></span><br><span class="line">scala&gt; t += 5</span><br><span class="line">res0: t.type = MutableList(1, 2, 3, 4, 5)</span><br></pre></td></tr></table></figure></p><p><br><br><strong>Set集合</strong><br>Set是一个没有重复元素的集合，将重复元素加入Set是没有用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val s = Set(1,2,3)</span><br><span class="line">s: scala.collection.immutable.Set[Int] = Set(1, 2, 3)</span><br><span class="line"></span><br><span class="line">scala&gt; s + 1</span><br><span class="line">res0: scala.collection.immutable.Set[Int] = Set(1, 2, 3)</span><br><span class="line"></span><br><span class="line">scala&gt; s + 4</span><br><span class="line">res1: scala.collection.immutable.Set[Int] = Set(1, 2, 3, 4)</span><br></pre></td></tr></table></figure></p><p>与列表不同，Set不保证元素插入的顺序，即Set中的元素是乱序的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val s = new scala.collection.mutable.HashSet[Int]()</span><br><span class="line">s: scala.collection.mutable.HashSet[Int] = Set()</span><br><span class="line"></span><br><span class="line">scala&gt; s += 1</span><br><span class="line">res0: s.type = Set(1)</span><br><span class="line"></span><br><span class="line">scala&gt; s += 2</span><br><span class="line">res1: s.type = Set(1, 2)</span><br><span class="line"></span><br><span class="line">scala&gt; s += 5</span><br><span class="line">res2: s.type = Set(1, 5, 2)</span><br></pre></td></tr></table></figure></p><p><br><br><strong>LinkedHashSet</strong><br>LinkedHashSet会用一个链表维护插入顺序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val s = new scala.collection.mutable.LinkedHashSet[Int]()</span><br><span class="line">s: scala.collection.mutable.LinkedHashSet[Int] = Set()</span><br><span class="line"></span><br><span class="line">scala&gt; s += 1</span><br><span class="line">res0: s.type = Set(1)</span><br><span class="line"></span><br><span class="line">scala&gt; s += 2</span><br><span class="line">res1: s.type = Set(1, 2)</span><br><span class="line"></span><br><span class="line">scala&gt; s += 5</span><br><span class="line">res2: s.type = Set(1, 2, 5)</span><br></pre></td></tr></table></figure></p><p><br><br><strong>SortedSet</strong><br>SortedSet会对元素进行排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val s = scala.collection.mutable.SortedSet(1,5,3,6,2)</span><br><span class="line">s: scala.collection.mutable.SortedSet[Int] = TreeSet(1, 2, 3, 5, 6)</span><br></pre></td></tr></table></figure></p><p><br><br><strong>Set的操作</strong><br>1、添加元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val s = scala.collection.mutable.HashSet(1,2,3,4)</span><br><span class="line">s: scala.collection.mutable.HashSet[Int] = Set(1, 2, 3, 4)</span><br><span class="line"></span><br><span class="line">scala&gt; s += 5</span><br><span class="line">res0: s.type = Set(1, 5, 2, 3, 4)</span><br></pre></td></tr></table></figure></p><p>2、判断元素是否存在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; s contains(5)</span><br><span class="line">res1: Boolean = true</span><br><span class="line"></span><br><span class="line">scala&gt; s contains(6)</span><br><span class="line">res2: Boolean = false</span><br></pre></td></tr></table></figure></p><p>3、判断一个Set是否是另外一个Set的子集<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; Set(1,2,3) subsetOf(s)</span><br><span class="line">res3: Boolean = true</span><br><span class="line"></span><br><span class="line">scala&gt; Set(5,6,7) subsetOf(s)</span><br><span class="line">res4: Boolean = false</span><br></pre></td></tr></table></figure></p><p>4、并集运算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var set1 = Set(1,2,3,4,5)</span><br><span class="line">set1: scala.collection.immutable.Set[Int] = Set(5, 1, 2, 3, 4)</span><br><span class="line"></span><br><span class="line">scala&gt; var set2 = Set(3,4,5,6,7)</span><br><span class="line">set2: scala.collection.immutable.Set[Int] = Set(5, 6, 7, 3, 4)</span><br><span class="line"></span><br><span class="line">scala&gt; set1 union set2</span><br><span class="line">res5: scala.collection.immutable.Set[Int] = Set(5, 1, 6, 2, 7, 3, 4)</span><br></pre></td></tr></table></figure></p><p>5、交集运算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; set1 intersect set2</span><br><span class="line">res6: scala.collection.immutable.Set[Int] = Set(5, 3, 4)</span><br></pre></td></tr></table></figure></p><p>6、差集运算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; set1 diff set2</span><br><span class="line">res7: scala.collection.immutable.Set[Int] = Set(1, 2)</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scala的集合体系主要包括：Iterable、Seq、Set、Map。其中Iterable是所有集合trait的根trait。&lt;br&gt;Scala的集合分成可变和不可变两类集合，可变集合指集合的元素可以动态修改，不可变集合指集合的元素在初始化之后不能修改。分别对应scala.collection.mutable和scala.collection.immutable两个包。&lt;br&gt;Seq下包含了Range、ArrayBuffer、List等子trait。其中Range就代表了一个序列，通常可以使用”1 to 10”这种语法来产生一个Range。ArrayBuffer就类似于Java中的ArrayList。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala语言的函数式编程</title>
    <link href="https://www.ggstu.com/2018/08/23/Scala%E8%AF%AD%E8%A8%80%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.ggstu.com/2018/08/23/Scala语言的函数式编程/</id>
    <published>2018-08-23T06:54:36.000Z</published>
    <updated>2018-08-24T13:45:55.667Z</updated>
    
    <content type="html"><![CDATA[<p>Java是完全面向对象的编程语言，所以类和对象是“一等公民”，Java中的方法不能脱离类和对象独立存在。<br>Scala是一门既面向对象，又面向过程的语言。在Scala中，函数与类、对象等一样，都是“一等公民”。Scala中的函数可以独立存在，不需要依赖任何类和对象。<br>Scala的函数式编程，就是Scala面向过程的体现。正是因为函数式编程，才让Scala具备了Java所不具备的更强大的功能和特性。<br><a id="more"></a><br><strong>将函数赋值给变量</strong><br>Scala中的函数是“一等公民”，可以独立定义，独立存在，而且可以直接将函数作为值赋给变量。<br>Scala的语法规定，将函数赋值给变量时，必须在函数名后加上空格和下划线。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sayHello(name:String)&#123;</span><br><span class="line">     |     println(&quot;Hello,&quot; + name)</span><br><span class="line">     | &#125;</span><br><span class="line">sayHello: (name: String)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; val s = sayHello _</span><br><span class="line">s: String =&gt; Unit = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; s(&quot;Tom&quot;)</span><br><span class="line">Hello,Tom</span><br></pre></td></tr></table></figure></p><p><br><br><strong>匿名函数</strong><br>Scala中，函数也可以不需要命名，此时函数被称为匿名函数。<br>定义函数之后，可以将定义的匿名函数传入其它函数之中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; (x:Int) =&gt; x*3</span><br><span class="line">res0: Int =&gt; Int = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; Array(1,2,3,4,5).map((x:Int) =&gt; x*3)</span><br><span class="line">res1: Array[Int] = Array(3, 6, 9, 12, 15)</span><br></pre></td></tr></table></figure></p><p><br><br><strong>高阶函数</strong><br>高阶函数就是将某个函数作为其它函数的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val sayHello = (name:String) =&gt; println(&quot;Hello,&quot; + name)</span><br><span class="line">sayHello: String =&gt; Unit = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; def person(func:(String) =&gt; Unit,name:String)&#123;</span><br><span class="line">     |     func(name)</span><br><span class="line">     | &#125;</span><br><span class="line">person: (func: String =&gt; Unit, name: String)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; person(sayHello,&quot;Tom&quot;)</span><br><span class="line">Hello,Tom</span><br></pre></td></tr></table></figure></p><p>高阶函数的另外一个功能是将函数作为返回值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sayHello(message:String) = (name:String) =&gt; println(message + &quot;,&quot; + name)</span><br><span class="line">sayHello: (message: String)String =&gt; Unit</span><br><span class="line"></span><br><span class="line">scala&gt; val person = sayHello(&quot;Hello&quot;)</span><br><span class="line">person: String =&gt; Unit = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; person(&quot;Tom&quot;)</span><br><span class="line">Hello,Tom</span><br></pre></td></tr></table></figure></p><p>高阶函数可以自动推断出参数类型，而不需要写明类型。对于只有一个参数的函数，还可以省去其小括号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sayHello(func:(String) =&gt; Unit,name:String)&#123;func(name)&#125;</span><br><span class="line">sayHello: (func: String =&gt; Unit, name: String)Unit</span><br><span class="line"></span><br><span class="line">scala&gt; sayHello((name:String) =&gt; println(&quot;Hello,&quot; + name),&quot;Tom&quot;)</span><br><span class="line">Hello,Tom</span><br><span class="line"></span><br><span class="line">scala&gt; sayHello((name) =&gt; println(&quot;Hello,&quot; + name),&quot;Tom&quot;)</span><br><span class="line">Hello,Tom</span><br><span class="line"></span><br><span class="line">scala&gt; sayHello(name =&gt; println(&quot;Hello,&quot; + name),&quot;Tom&quot;)</span><br><span class="line">Hello,Tom</span><br></pre></td></tr></table></figure></p><p>如果仅有的一个参数在右侧的函数体内只使用一次，还可以将接收参数省略，并且将参数用_来替代。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def triple(func:(Int) =&gt; Int) = &#123;func(3)&#125;</span><br><span class="line">triple: (func: Int =&gt; Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; triple(3*_)</span><br><span class="line">res0: Int = 9</span><br></pre></td></tr></table></figure></p><p><br><br><strong>Scala常用的高阶函数</strong><br>1、map：在列表中的每个元素上计算一个函数，并且返回一个包含相同数目元素的列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val numbers = List(1,2,3,4,5)</span><br><span class="line">numbers: List[Int] = List(1, 2, 3, 4, 5)</span><br><span class="line"></span><br><span class="line">scala&gt; numbers.map((i:Int) =&gt; i*2)</span><br><span class="line">res0: List[Int] = List(2, 4, 6, 8, 10)</span><br></pre></td></tr></table></figure></p><p>2、foreach：对传入的每个元素都进行处理，和map相似，但是没有返回值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; numbers.foreach((i:Int) =&gt; i*2)</span><br><span class="line"></span><br><span class="line">scala&gt; numbers</span><br><span class="line">res2: List[Int] = List(1, 2, 3, 4, 5)</span><br></pre></td></tr></table></figure></p><p>3、filter：对传入的每个元素都进行条件判断，如果对元素返回true，则保留该元素，否则过滤掉该元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; (1 to 10).filter(_%2 == 0)</span><br><span class="line">res3: scala.collection.immutable.IndexedSeq[Int] = Vector(2, 4, 6, 8, 10)</span><br></pre></td></tr></table></figure></p><p>4、zip：把两个列表的元素合成一个由元素对组成的列表里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; List(&quot;Tom&quot;,&quot;Bob&quot;,&quot;Alice&quot;).zip(List(21,18,25))</span><br><span class="line">res4: List[(String, Int)] = List((Tom,21), (Bob,18), (Alice,25))</span><br></pre></td></tr></table></figure></p><p>5、reduceLeft：从左侧元素开始，进行reduce操作，即先对元素1和元素2进行处理，然后将结果与元素3处理，再将结果与元素4处理，依次类推。<br>下面这个操作就相当于1*2*3*4*5*6*7*8*9*10=3628800<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; (1 to 10).reduceLeft(_*_)</span><br><span class="line">res5: Int = 3628800</span><br></pre></td></tr></table></figure></p><p>6、sortWith：对元素进行两两比较，进行排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; Array(3,7,15,9,5).sortWith(_&lt;_)</span><br><span class="line">res6: Array[Int] = Array(3, 5, 7, 9, 15)</span><br><span class="line"></span><br><span class="line">scala&gt; Array(3,7,15,9,5).sortWith(_&gt;_)</span><br><span class="line">res7: Array[Int] = Array(15, 9, 7, 5, 3)</span><br></pre></td></tr></table></figure></p><p>7、partition：对传入的每个元素都进行条件判断，根据返回值的不同进行拆分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val numbers = List(1,2,3,4,5)</span><br><span class="line">numbers: List[Int] = List(1, 2, 3, 4, 5)</span><br><span class="line"></span><br><span class="line">scala&gt; numbers.partition((i:Int) =&gt; i%2 == 0)</span><br><span class="line">res8: (List[Int], List[Int]) = (List(2, 4),List(1, 3, 5))</span><br></pre></td></tr></table></figure></p><p>8、find：返回集合里第一个匹配断言函数的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; numbers.find(_%3 == 0)</span><br><span class="line">res9: Option[Int] = Some(3)</span><br></pre></td></tr></table></figure></p><p>9、flatten：可以把嵌套的结构展开。<br>如：将(1,2,3)和(4,5,6)这两个集合合并成一个集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; List(List(1,2,3),List(4,5,6)).flatten</span><br><span class="line">res10: List[Int] = List(1, 2, 3, 4, 5, 6)</span><br></pre></td></tr></table></figure></p><p>10、flatMap：结合了map和flatten的功能。<br>如：将(1,2,3)和(4,5,6)这两个集合合并成一个集合，再对集合中的每个元素乘以2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val newList = List(List(1,2,3),List(4,5,6))</span><br><span class="line">newList: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6))</span><br><span class="line"></span><br><span class="line">scala&gt; newList.flatMap(x =&gt; x.map(_ * 2))</span><br><span class="line">res11: List[Int] = List(2, 4, 6, 8, 10, 12)</span><br></pre></td></tr></table></figure></p><p>例子：统计多个文本内的单词总数<br>我在桌面创建了两个文件test1.txt和test2.txt。<br>test1.txt中的内容是Hello World!<br>test2.txt中的内容是This is the second file.<br>一共7个单词，最后的输出为7<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val lines1 = scala.io.Source.fromFile(&quot;C://Users//asus//Desktop//test1.txt&quot;).mkString</span><br><span class="line">lines1: String = Hello World!</span><br><span class="line"></span><br><span class="line">scala&gt; val lines2 = scala.io.Source.fromFile(&quot;C://Users//asus//Desktop//test2.txt&quot;).mkString</span><br><span class="line">lines2: String = This is the second file.</span><br><span class="line"></span><br><span class="line">scala&gt; val lines = List(lines1,lines2)</span><br><span class="line">lines: List[String] = List(Hello World!, This is the second file.)</span><br><span class="line"></span><br><span class="line">scala&gt; lines.flatMap(_.split(&quot; &quot;)).map((_,1)).map(_._2).reduceLeft(_+_)</span><br><span class="line">res0: Int = 7</span><br></pre></td></tr></table></figure></p><p><br><br><strong>闭包</strong><br>闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。<br>闭包通常来讲可以简单的认为是可以访问一个函数里面局部变量的另外一个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def person(message:String)=(name:String) =&gt; println(message + &quot;,&quot; + name)</span><br><span class="line">person: (message: String)String =&gt; Unit</span><br><span class="line"></span><br><span class="line">scala&gt; val sayHello = person(&quot;Hello&quot;)</span><br><span class="line">sayHello: String =&gt; Unit = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; val sayHi = person(&quot;Hi&quot;)</span><br><span class="line">sayHi: String =&gt; Unit = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; sayHello(&quot;Tom&quot;)</span><br><span class="line">Hello,Tom</span><br><span class="line"></span><br><span class="line">scala&gt; sayHi(&quot;Tom&quot;)</span><br><span class="line">Hi,Tom</span><br></pre></td></tr></table></figure></p><p><br><br><strong>Scala函数柯里化(Currying)</strong><br>柯里化函数是把具有多个参数的函数转换为一条函数链，每个节点上是单一参数。<br>例如：以下几个函数是等价的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sum1(a:Int,b:Int) = a + b</span><br><span class="line">sum1: (a: Int, b: Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; def sum2(a:Int) = (b:Int) =&gt; a + b</span><br><span class="line">sum2: (a: Int)Int =&gt; Int</span><br><span class="line"></span><br><span class="line">scala&gt; def sum3(a:Int)(b:Int) = a + b</span><br><span class="line">sum3: (a: Int)(b: Int)Int</span><br><span class="line"></span><br><span class="line">scala&gt; sum1(1,1)</span><br><span class="line">res0: Int = 2</span><br><span class="line"></span><br><span class="line">scala&gt; sum2(1)(1)</span><br><span class="line">res1: Int = 2</span><br><span class="line"></span><br><span class="line">scala&gt; sum3(1)(1)</span><br><span class="line">res2: Int = 2</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java是完全面向对象的编程语言，所以类和对象是“一等公民”，Java中的方法不能脱离类和对象独立存在。&lt;br&gt;Scala是一门既面向对象，又面向过程的语言。在Scala中，函数与类、对象等一样，都是“一等公民”。Scala中的函数可以独立存在，不需要依赖任何类和对象。&lt;br&gt;Scala的函数式编程，就是Scala面向过程的体现。正是因为函数式编程，才让Scala具备了Java所不具备的更强大的功能和特性。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala中的trait(特质)</title>
    <link href="https://www.ggstu.com/2018/08/21/Scala%E4%B8%AD%E7%9A%84trait-%E7%89%B9%E8%B4%A8/"/>
    <id>https://www.ggstu.com/2018/08/21/Scala中的trait-特质/</id>
    <published>2018-08-21T02:17:47.000Z</published>
    <updated>2018-08-21T06:12:23.704Z</updated>
    
    <content type="html"><![CDATA[<p><strong>将trait作为接口使用</strong><br>Scala中可以将trait作为接口来使用，此时的trait就与Java中的接口非常类似,但实际上它比接口功能更强大。<br>在trait中可以定义抽象方法，就与抽象类中的抽象方法一样，只要不给出方法的具体实现即可。<br>在Scala中没有implement的概念，无论继承类还是trait，统一都是extends。<br>类继承trait后，必须实现其中的抽象方法，实现时不需要使用override关键字。<br>Scala不支持对类进行多继承，但是支持多重继承trait，使用with关键字即可。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">trait PersonTrait&#123;</span><br><span class="line">    def sayHello(name:String)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait MakeFriendsTrait&#123;</span><br><span class="line">    def makeFriends(s:Student)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student(val name:String) extends PersonTrait with MakeFriendsTrait&#123;</span><br><span class="line">    def sayHello(name:String) = println(&quot;Hello,&quot; + name)</span><br><span class="line">    def makeFriends(s:Student) = println(&quot;Hello,my name is &quot; + name + &quot;,your name is &quot; + s.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined trait PersonTrait</span><br><span class="line">defined trait MakeFriendsTrait</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s1 = new Student(&quot;Tom&quot;)</span><br><span class="line">s1: Student = Student@5b67bb7e</span><br><span class="line"></span><br><span class="line">scala&gt; val s2 = new Student(&quot;Bob&quot;)</span><br><span class="line">s2: Student = Student@35645047</span><br><span class="line"></span><br><span class="line">scala&gt; s1.sayHello(&quot;Alice&quot;)</span><br><span class="line">Hello,Alice</span><br><span class="line"></span><br><span class="line">scala&gt; s1.makeFriends(s2)</span><br><span class="line">Hello,my name is Tom,your name is Bob</span><br></pre></td></tr></table></figure></p><p><br><br><strong>在trait中覆盖抽象方法</strong><br>子trait可以覆盖父trait的抽象方法。但是覆盖时，如果使用了super.方法，则无法通过编译。因为super.方法会去调用父trait的抽象方法，此时子trait的该方法还是会被认为是抽象的。<br>如果要通过编译，就得给子trait的方法加上abstract override修饰。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">trait Logger&#123;</span><br><span class="line">    def log(message:String)</span><br><span class="line">&#125;</span><br><span class="line">trait MyLogger extends Logger&#123;</span><br><span class="line">    abstract override def log(message:String)&#123;super.log(message)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined trait Logger</span><br><span class="line">defined trait MyLogger</span><br></pre></td></tr></table></figure></p><p><br><br><strong>在trait中定义具体方法</strong><br>Scala中的trait不仅仅可以定义抽象方法，还可以定义具体方法。<br>trait中可以包含一些很多类都通用的方法。<br>例如，打印日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">trait Logger&#123;</span><br><span class="line">    def log(message:String) = println(&quot;Log: &quot; + message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person(val name:String) extends Logger&#123;</span><br><span class="line">    def sayHello&#123;</span><br><span class="line">        println(&quot;Hello,I&apos;m &quot; + name)</span><br><span class="line">        log(&quot;sayHello method is invoked&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined trait Logger</span><br><span class="line">defined class Person</span><br><span class="line"></span><br><span class="line">scala&gt; val p = new Person(&quot;Tom&quot;)</span><br><span class="line">p: Person = Person@63611043</span><br><span class="line"></span><br><span class="line">scala&gt; p.sayHello</span><br><span class="line">Hello,I&apos;m Tom</span><br><span class="line">Log: sayHello method is invoked</span><br></pre></td></tr></table></figure></p><p><br><br><strong>混合使用trait的抽象方法和具体方法</strong><br>在trait中，可以混合使用抽象方法和具体方法，让具体方法依赖于抽象方法，而抽象方法则放到继承trait的类中去实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">trait Valid&#123;</span><br><span class="line">    def getName:String</span><br><span class="line">    def isTom:Boolean = &#123;</span><br><span class="line">        getName == &quot;Tom&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person(val name:String) extends Valid&#123;</span><br><span class="line">    println(isTom)</span><br><span class="line">    def getName = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined trait Valid</span><br><span class="line">defined class Person</span><br><span class="line"></span><br><span class="line">scala&gt; val p1 = new Person(&quot;Tom&quot;)</span><br><span class="line">true</span><br><span class="line">p: Person = Person@36060e</span><br><span class="line"></span><br><span class="line">scala&gt; val p2 = new Person(&quot;Bob&quot;)</span><br><span class="line">false</span><br><span class="line">p2: Person = Person@60129b9a</span><br></pre></td></tr></table></figure></p><p><br><br><strong>在trait中定义抽象字段</strong><br>Scala中的trait可以定义抽象字段，并且trait中的具体方法可以使用抽象字段。<br>继承trait的类，必须覆盖抽象字段，提供具体的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">trait SayHello&#123;</span><br><span class="line">    val message:String</span><br><span class="line">    def sayHello(name:String) = println(message + &quot;,&quot; + name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person(val name:String) extends SayHello&#123;</span><br><span class="line">    val message:String = &quot;Hello&quot;</span><br><span class="line">    def makeFriends(p:Person)&#123;</span><br><span class="line">        sayHello(p.name)</span><br><span class="line">        println(&quot;My name is &quot; + name + &quot;,your name is &quot; + p.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined trait SayHello</span><br><span class="line">defined class Person</span><br><span class="line"></span><br><span class="line">scala&gt; val p1 = new Person(&quot;Tom&quot;)</span><br><span class="line">p1: Person = Person@7daa0fbd</span><br><span class="line"></span><br><span class="line">scala&gt; val p2 = new Person(&quot;Bob&quot;)</span><br><span class="line">p2: Person = Person@51fadaff</span><br><span class="line"></span><br><span class="line">scala&gt; p1.makeFriends(p2)</span><br><span class="line">Hello,Bob</span><br><span class="line">My name is Tom,your name is Bob</span><br></pre></td></tr></table></figure></p><p><br><br><strong>在trait中定义具体字段</strong><br>Scala中的trait可以定义具体字段，此时继承trait的类会获得trait中定义的字段.<br>这种获取字段的方式与继承类是不同的，继承类获取的字段是定义在父类中的，而继承trait获取的字段会被添加到类中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">trait Person&#123;</span><br><span class="line">    val handNum:Int = 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student(val name:String) extends Person&#123;</span><br><span class="line">    def sayHello = println(&quot;Hello,I&apos;m &quot; + name + &quot;,I have &quot; + handNum + &quot; hands.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined trait Person</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student(&quot;Tom&quot;)</span><br><span class="line">s: Student = Student@babafc2</span><br><span class="line"></span><br><span class="line">scala&gt; s.sayHello</span><br><span class="line">Hello,I&apos;m Tom,I have 2 hands.</span><br></pre></td></tr></table></figure></p><p><br><br><strong>为实例对象混入trait</strong><br>在创建类的对象时，可以指定该对象混入某个trait，使用关键字with。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">trait Logger&#123;</span><br><span class="line">    def log(message:String)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait MyLogger extends Logger&#123;</span><br><span class="line">    override def log(message:String)&#123;</span><br><span class="line">        println(&quot;Log: &quot; + message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person(val name:String) extends Logger&#123;</span><br><span class="line">    def sayHello&#123;</span><br><span class="line">        println(&quot;Hello,I&apos;m &quot; + name)</span><br><span class="line">        log(&quot;sayHello method is invoked&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined trait Logger</span><br><span class="line">defined trait MyLogger</span><br><span class="line">defined class Person</span><br><span class="line"></span><br><span class="line">scala&gt; val p1 = new Person(&quot;Tom&quot;)</span><br><span class="line">p1: Person = Person@51549490</span><br><span class="line"></span><br><span class="line">scala&gt; p1.sayHello</span><br><span class="line">Hello,I&apos;m Tom</span><br><span class="line"></span><br><span class="line">scala&gt; val p2 = new Person(&quot;Bob&quot;) with MyLogger</span><br><span class="line">p2: Person with MyLogger = $anon$1@22f31dec</span><br><span class="line"></span><br><span class="line">scala&gt; p2.sayHello</span><br><span class="line">Hello,I&apos;m Bob</span><br><span class="line">Log: sayHello method is invoked</span><br></pre></td></tr></table></figure></p><p><br><br><strong>trait调用链</strong><br>Scala中支持让类继承多个trait后，依次调用多个trait中的同一个方法，只要在多个trait的同一个方法最后都执行super方法即可。<br>类中调用多个trait中都有的这个方法时，会从最右边的trait的方法开始执行，然后依次往左执行，形成一个调用链。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">trait A&#123;</span><br><span class="line">    def showData(data:String)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">trait B extends A&#123;</span><br><span class="line">    override def showData(data:String)&#123;</span><br><span class="line">        println(&quot;B: &quot; + data)</span><br><span class="line">        super.showData(data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">trait C extends A&#123;</span><br><span class="line">    override def showData(data:String)&#123;</span><br><span class="line">        println(&quot;C: &quot; + data)</span><br><span class="line">        super.showData(data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person(val name:String) extends C with B&#123;</span><br><span class="line">    def sayHello = &#123;</span><br><span class="line">        println(&quot;Hello,&quot; + name)</span><br><span class="line">        showData(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined trait A</span><br><span class="line">defined trait B</span><br><span class="line">defined trait C</span><br><span class="line">defined class Person</span><br><span class="line"></span><br><span class="line">scala&gt; val p = new Person(&quot;Tom&quot;)</span><br><span class="line">p: Person = Person@2c78d320</span><br><span class="line"></span><br><span class="line">scala&gt; p.sayHello</span><br><span class="line">Hello,Tom</span><br><span class="line">B: Tom</span><br><span class="line">C: Tom</span><br></pre></td></tr></table></figure></p><p><br><br><strong>trait的构造机制</strong><br>在Scala中，trait也是有构造代码的。<br>继承了trait的类的构造机制如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;1、父类的构造函数执行；<br>&nbsp;&nbsp;&nbsp;&nbsp;2、trait的构造代码执行，多个trait从左到右依次执行；<br>&nbsp;&nbsp;&nbsp;&nbsp;3、构造trait时会先构造父trait，如果多个trait继承同一个父trait，则父trait只会构造一个；<br>&nbsp;&nbsp;&nbsp;&nbsp;4、所有trait构造完毕之后，子类的构造函数执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Person&#123;println(&quot;Person&apos;s constructor.&quot;)&#125;</span><br><span class="line">trait A&#123;println(&quot;A&apos;s constructor.&quot;)&#125;</span><br><span class="line">trait B extends A&#123;println(&quot;B&apos;s constructor.&quot;)&#125;</span><br><span class="line">trait C extends A&#123;println(&quot;C&apos;s constructor.&quot;)&#125;</span><br><span class="line">class Student extends Person with B with C&#123;</span><br><span class="line">    println(&quot;Student&apos;s constructor.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined trait A</span><br><span class="line">defined trait B</span><br><span class="line">defined trait C</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student</span><br><span class="line">Person&apos;s constructor.</span><br><span class="line">A&apos;s constructor.</span><br><span class="line">B&apos;s constructor.</span><br><span class="line">C&apos;s constructor.</span><br><span class="line">Student&apos;s constructor.</span><br><span class="line">s: Student = Student@37e4d7bb</span><br></pre></td></tr></table></figure></p><p><br><br><strong>trait字段的初始化</strong><br>Scala中，trait没有接收参数的构造函数，这也是trait与class的区别。<br>如果要让trait能够对字段进行初始化，只能使用提前定义的方式。<br>方式一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">trait SayHello&#123;</span><br><span class="line">    val message:String</span><br><span class="line">    println(message.toString)</span><br><span class="line">&#125;</span><br><span class="line">class Person</span><br><span class="line">val p = new&#123;</span><br><span class="line">    val message:String = &quot;hello&quot;</span><br><span class="line">&#125;with Person with SayHello</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">hello</span><br><span class="line">defined trait SayHello</span><br><span class="line">defined class Person</span><br><span class="line">p: Person with SayHello = $anon$1@2d6c53fc</span><br></pre></td></tr></table></figure></p><p>方式二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">trait SayHello&#123;</span><br><span class="line">    val message:String</span><br><span class="line">    println(message.toString)</span><br><span class="line">&#125;</span><br><span class="line">class Person extends&#123;</span><br><span class="line">    val message:String = &quot;hello&quot;</span><br><span class="line">&#125;with SayHello&#123;&#125;</span><br><span class="line">val p = new Person</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">hello</span><br><span class="line">defined trait SayHello</span><br><span class="line">defined class Person</span><br><span class="line">p: Person = Person@5b6ec132</span><br></pre></td></tr></table></figure></p><p>方式三：使用lazy value(懒加载)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">trait SayHello&#123;</span><br><span class="line">    lazy val message:String = null</span><br><span class="line">    println(message.toString)</span><br><span class="line">&#125;</span><br><span class="line">class Person extends SayHello&#123;</span><br><span class="line">    override lazy val message:String = &quot;hello&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined trait SayHello</span><br><span class="line">defined class Person</span><br><span class="line"></span><br><span class="line">scala&gt; val p = new Person</span><br><span class="line">hello</span><br><span class="line">p: Person = Person@3c7c886c</span><br></pre></td></tr></table></figure></p><p><br><br><strong>trait继承类</strong><br>trait也可以继承类，此时这个类就会成为所有继承该trait的类的父类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    def printMessage(message:String) = println(message)</span><br><span class="line">&#125;</span><br><span class="line">trait Logger extends Person&#123;</span><br><span class="line">    def log(message:String) = printMessage(&quot;Log: &quot; + message)</span><br><span class="line">&#125;</span><br><span class="line">class Student(val name:String) extends Logger&#123;</span><br><span class="line">    def sayHello&#123;</span><br><span class="line">        log(&quot;Hello,I&apos;m &quot; + name)</span><br><span class="line">        printMessage(&quot;Hello,I&apos;m &quot; + name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined trait Logger</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student(&quot;Tom&quot;)</span><br><span class="line">s: Student = Student@36a5cabc</span><br><span class="line"></span><br><span class="line">scala&gt; s.sayHello</span><br><span class="line">Log: Hello,I&apos;m Tom</span><br><span class="line">Hello,I&apos;m Tom</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;将trait作为接口使用&lt;/strong&gt;&lt;br&gt;Scala中可以将trait作为接口来使用，此时的trait就与Java中的接口非常类似,但实际上它比接口功能更强大。&lt;br&gt;在trait中可以定义抽象方法，就与抽象类中的抽象方法一样，只要不给出方法的具体实现即可。&lt;br&gt;在Scala中没有implement的概念，无论继承类还是trait，统一都是extends。&lt;br&gt;类继承trait后，必须实现其中的抽象方法，实现时不需要使用override关键字。&lt;br&gt;Scala不支持对类进行多继承，但是支持多重继承trait，使用with关键字即可。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala中的继承</title>
    <link href="https://www.ggstu.com/2018/08/19/Scala%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <id>https://www.ggstu.com/2018/08/19/Scala中的继承/</id>
    <published>2018-08-19T11:36:56.000Z</published>
    <updated>2018-08-19T14:25:31.917Z</updated>
    
    <content type="html"><![CDATA[<p><strong>extends关键字实现继承</strong><br>Scala中，与Java一样，也是使用extends关键字让子类继承父类，使用继承可以有效地复用代码。<br>继承表示子类可以继承父类的属性和方法，子类可以在自己内部放入父类所没有而子类特有的属性和方法。<br>子类可以覆盖父类的属性和方法，但是如果父类用final修饰，属性和方法用final修饰，则该类是无法被继承的，即属性和方法是无法被覆盖。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    private var name = &quot;Tom&quot;</span><br><span class="line">    def getName = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    private var score = &quot;A&quot;</span><br><span class="line">    def getScore = score</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student</span><br><span class="line">s: Student = Student@332729ad</span><br><span class="line"></span><br><span class="line">scala&gt; s.getScore</span><br><span class="line">res0: String = A</span><br><span class="line"></span><br><span class="line">scala&gt; s.getName</span><br><span class="line">res1: String = Tom</span><br></pre></td></tr></table></figure></p><p><br><br><strong>在子类中重写父类的方法</strong><br>Scala中，如果子类要覆盖一个父类中的非抽象方法，则必须使用override关键字。<br>在子类覆盖父类方法之后，如果在子类中要调用父类的被覆盖的方法，可以使用super关键字，显式地指定要调用父类的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    private var name = &quot;Tom&quot;</span><br><span class="line">    def getName = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    private var score = &quot;A&quot;</span><br><span class="line">    def getScore = score</span><br><span class="line">    override def getName = &quot;Hello,I&apos;m &quot; + super.getName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student</span><br><span class="line">s: Student = Student@3e74829</span><br><span class="line"></span><br><span class="line">scala&gt; s.getName</span><br><span class="line">res0: String = Hello,I&apos;m Tom</span><br></pre></td></tr></table></figure></p><p>Scala中，子类可以覆盖父类的val属性，而且还可以覆盖父类的val属性的getter方法，只要在子类中使用override关键字即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    val name:String = &quot;Person&quot;</span><br><span class="line">    def age:Int = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    override val name:String = &quot;Tom&quot;</span><br><span class="line">    override val age:Int = 21</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student</span><br><span class="line">s: Student = Student@6853425f</span><br><span class="line"></span><br><span class="line">scala&gt; s.name</span><br><span class="line">res0: String = Tom</span><br><span class="line"></span><br><span class="line">scala&gt; s.age</span><br><span class="line">res1: Int = 21</span><br></pre></td></tr></table></figure></p><p>跟java一样，Scala中同样可以使用protected关键字来修饰属性和方法，这样在子类中就不需要super关键字，直接就可以访问属性和方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    protected var name:String = &quot;Tom&quot;</span><br><span class="line">    protected var age:Int = 21</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    def sayHello = println(&quot;Hello,&quot; + name)</span><br><span class="line">    def ageCompare(s:Student)&#123;</span><br><span class="line">        println(&quot;I&apos;m &quot; + age + &quot; years old,you are &quot; + s.age + &quot;years old.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined class Student</span><br></pre></td></tr></table></figure></p><p>还可以使用protected[this]，表示只能在当前子类对象中访问父类的属性和方法，无法通过其他子类对象访问父类的属性和方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    protected var name:String = &quot;Tom&quot;</span><br><span class="line">    protected[this] var age:Int = 21</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    def sayHello = println(&quot;Hello,&quot; + name)</span><br><span class="line">    def ageCompare(s:Student)&#123;</span><br><span class="line">        println(&quot;I&apos;m &quot; + age + &quot; years old,you are &quot; + s.age + &quot;years old.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">&lt;console&gt;:21: error: value age is not a member of Student</span><br><span class="line">               println(&quot;I&apos;m &quot; + age + &quot; years old,you are &quot; + s.age + &quot;years old.&quot;)</span><br><span class="line">                                                                ^</span><br></pre></td></tr></table></figure></p><p><br><br><strong>匿名子类</strong><br>可以通过包含带有定义或重写的代码块的方式创建一个匿名子类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student(val name:String,val age:Int)&#123;</span><br><span class="line">     |     def sayHello() = &quot;Hello,my name is &quot; + name + &quot;,I&apos;m &quot; + age + &quot; years old.&quot;</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; var s:Student = new Student(&quot;Tom&quot;,21)&#123;</span><br><span class="line">     |     override def sayHello() = &quot;匿名子类中的sayHello方法&quot;</span><br><span class="line">     | &#125;</span><br><span class="line">s: Student = $anon$1@1115ec15</span><br><span class="line"></span><br><span class="line">scala&gt; println(s.sayHello())</span><br><span class="line">匿名子类中的sayHello方法</span><br></pre></td></tr></table></figure></p><p><br><br><strong>抽象类</strong><br>抽象类使用abstract关键字来标记，抽象类是不可以实例化的，只能用来继承。<br>在子类中覆盖抽象类的抽象方法时，不需要使用override关键字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">abstract class Person(val name:String)&#123;</span><br><span class="line">    def sayHello:Unit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student(name:String) extends Person(name)&#123;</span><br><span class="line">    def sayHello:Unit = println(&quot;Hello,my name is &quot; + name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student(&quot;Tom&quot;)</span><br><span class="line">s: Student = Student@571c5681</span><br><span class="line"></span><br><span class="line">scala&gt; s.sayHello</span><br><span class="line">Hello,my name is Tom</span><br></pre></td></tr></table></figure></p><p>object也可以继承抽象类，并覆盖抽象类中的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">abstract class Person(val name:String)&#123;</span><br><span class="line">    def sayHello(name:String):Unit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object Student extends Person(&quot;Tom&quot;)&#123;</span><br><span class="line">    override def sayHello(name:String)=&#123;</span><br><span class="line">        println(&quot;Hello,my name is &quot; + name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined object Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = Student</span><br><span class="line">s: Student.type = Student$@41294f8</span><br></pre></td></tr></table></figure></p><p><br><br><strong>抽象字段</strong><br>如果在父类中，定义了字段，但是没有给出初始值，则此字段为抽象字段。<br>抽象字段意味着，Scala会根据自己的规则，为var或val类型的字段生成对应的getter和setter方法，但是父类中是没有该字段的。<br>子类覆盖抽象字段，不需要使用override关键字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">abstract class Person&#123;</span><br><span class="line">    val name:String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    val name:String = &quot;Tom&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student</span><br><span class="line">s: Student = Student@53251a66</span><br><span class="line"></span><br><span class="line">scala&gt; s.name</span><br><span class="line">res0: String = Tom</span><br></pre></td></tr></table></figure></p><p><br><br><strong>类型判断</strong><br><strong>isInstanceOf和asInstanceOf</strong><br>如果创建了子类的对象，但是又将其赋予了父类类型的变量。则在后续的程序中，要将父类类型的变量转换为子类类型的变量，首先需要使用isInstanceOf判断对象是否是指定类的对象，如果是的话，则可以使用asInstanceOf将对象转换为指定类型。<br>如果对象是null，则isInstanceOf一定返回false，asInstanceOf一定返回null。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">class Student extends Person</span><br><span class="line">val p:Person = new Student</span><br><span class="line">var s:Student = null</span><br><span class="line">if(p.isInstanceOf[Student])  s = p.asInstanceOf[Student]</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Person</span><br><span class="line">defined class Student</span><br><span class="line">p: Person = Student@3eb81efb</span><br><span class="line">s: Student = Student@3eb81efb</span><br></pre></td></tr></table></figure></p><p><strong>getClass和classOf</strong><br>isInstanceOf只能判断出对象是否是指定类以及子类的对象，而不能精确判断出对象就是指定类的对象<br>如果要求精确地判断对象就是指定类的对象，就只能使用getClass和classOf<br>对象.getClass可以精确获取对象的类，classOf[类]可以精确获取类，然后使用==操作符即可判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Person</span><br><span class="line">defined class Person</span><br><span class="line"></span><br><span class="line">scala&gt; class Student extends Person</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val p:Person = new Student</span><br><span class="line">p: Person = Student@3c01cfa1</span><br><span class="line"></span><br><span class="line">scala&gt; p.isInstanceOf[Person]</span><br><span class="line">res0: Boolean = true</span><br><span class="line"></span><br><span class="line">scala&gt; p.getClass == classOf[Person]</span><br><span class="line">res1: Boolean = false</span><br><span class="line"></span><br><span class="line">scala&gt; p.getClass == classOf[Student]</span><br><span class="line">res2: Boolean = true</span><br></pre></td></tr></table></figure></p><p><strong>使用模式匹配进行类型判断</strong><br>使用模式匹配，功能性上来说，与instanceOf一样，也是判断对象是否该类以及该类的子类的对象，不是精准判断的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">class Student extends Person</span><br><span class="line">val p:Person = new Student</span><br><span class="line">p match&#123;</span><br><span class="line">    case per:Person =&gt; println(&quot;It is Person&apos;s object.&quot;)</span><br><span class="line">    case _ =&gt; println(&quot;Unknown type.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">It is Person&apos;s object.</span><br><span class="line">defined class Person</span><br><span class="line">defined class Student</span><br><span class="line">p: Person = Student@2f40e5db</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;extends关键字实现继承&lt;/strong&gt;&lt;br&gt;Scala中，与Java一样，也是使用extends关键字让子类继承父类，使用继承可以有效地复用代码。&lt;br&gt;继承表示子类可以继承父类的属性和方法，子类可以在自己内部放入父类所没有而子类特有的属性和方法。&lt;br&gt;子类可以覆盖父类的属性和方法，但是如果父类用final修饰，属性和方法用final修饰，则该类是无法被继承的，即属性和方法是无法被覆盖。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala的apply方法</title>
    <link href="https://www.ggstu.com/2018/08/19/Scala%E7%9A%84apply%E6%96%B9%E6%B3%95/"/>
    <id>https://www.ggstu.com/2018/08/19/Scala的apply方法/</id>
    <published>2018-08-19T06:43:19.000Z</published>
    <updated>2018-08-19T14:19:53.025Z</updated>
    
    <content type="html"><![CDATA[<p>在Scala的object中，可以声明apply方法。<br>而使用”类名()”的形式，其实就是”类名.apply()”的一种缩写。通常使用这种方式来构造类的对象，而不是使用”new 类名()”的方式。<br>例如：”Hello World”(6)实际上就是”Hello World”.apply(6)的缩写。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; &quot;Hello World&quot;(6)</span><br><span class="line">res0: Char = W</span><br><span class="line"></span><br><span class="line">scala&gt; &quot;Hello World&quot;.apply(6)</span><br><span class="line">res1: Char = W</span><br></pre></td></tr></table></figure></p><p>例如：Array(1,2,3,4)，实际上是用Array object的apply()函数来创建Array类的实例，也就是一个数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; Array(1,2,3,4)</span><br><span class="line">res2: Array[Int] = Array(1, 2, 3, 4)</span><br><span class="line"></span><br><span class="line">scala&gt; Array.apply(1,2,3,4)</span><br><span class="line">res3: Array[Int] = Array(1, 2, 3, 4)</span><br></pre></td></tr></table></figure></p><p><br><br>通常在伴生对象中实现apply方法，在其中实现构造伴生类的对象的功能，此时创建对象可以省略new关键字<br>例如：定义自己的伴生类和伴生对象<br>此时创建对象由于省略了new关键字，就会在object中找对应的apply方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Student(val name:String)</span><br><span class="line"></span><br><span class="line">object Student&#123;</span><br><span class="line">    def apply(name:String) = new Student(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Student</span><br><span class="line">defined object Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = Student(&quot;Tom&quot;)</span><br><span class="line">s: Student = Student@7d286fb6</span><br></pre></td></tr></table></figure></p><p>如果没有apply方法，创建对象省略new关键字就会报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student(val name:String)</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student(&quot;Tom&quot;)</span><br><span class="line">s: Student = Student@4032d386</span><br><span class="line"></span><br><span class="line">scala&gt; val s1 = Student(&quot;Bob&quot;)</span><br><span class="line">&lt;console&gt;:11: error: not found: value Student</span><br><span class="line">       val s1 = Student(&quot;Bob&quot;)</span><br><span class="line">                ^</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Scala的object中，可以声明apply方法。&lt;br&gt;而使用”类名()”的形式，其实就是”类名.apply()”的一种缩写。通常使用这种方式来构造类的对象，而不是使用”new 类名()”的方式。&lt;br&gt;例如：”Hello World”(6)实际上就是”Hello World”.apply(6)的缩写。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala的object对象</title>
    <link href="https://www.ggstu.com/2018/08/19/Scala%E7%9A%84object%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.ggstu.com/2018/08/19/Scala的object对象/</id>
    <published>2018-08-19T05:59:59.000Z</published>
    <updated>2018-08-19T14:18:12.522Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Scala中的object对象</strong><br>在Scala中，没有提供静态的修饰符static，但是object对象下的成员都是静态的。<br>第一次调用object的方法时，就会执行object的构造函数，但是object不能定义接收参数的构造函数。<br>object的构造函数只会在其第一次被调用时执行一次，以后再次调用不会再执行构造函数。<br>object通常用于作为单例模式的实现，或者放class的静态成员。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; object Person&#123;</span><br><span class="line">     |     private var handNum = 2</span><br><span class="line">     |     def getHandNum = handNum</span><br><span class="line">     | &#125;</span><br><span class="line">defined object Person</span><br></pre></td></tr></table></figure></p><p><br><br><strong>伴生类和伴生对象</strong><br>如果有一个class，还有一个与class同名的object，那么就称这个object是class的伴生对象，class是object的伴生类。<br>伴生类和伴生对象必须存放在一个.scala文件中。<br>伴生类和伴生对象可以互相访问其私有成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">object Person&#123;</span><br><span class="line">    private val handNum = 2</span><br><span class="line">    def getHandNum = handNum</span><br><span class="line">&#125;</span><br><span class="line">class Person(val name:String,val age:Int)&#123;</span><br><span class="line">    def sayHello = println(&quot;Hello,my name is &quot; + name + &quot;.I&apos;m &quot; + age + &quot; years old and I have &quot; + Person.handNum + &quot; hands.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined object Person</span><br><span class="line">defined class Person</span><br><span class="line"></span><br><span class="line">scala&gt; val p = new Person(&quot;Tom&quot;,21)</span><br><span class="line">p: Person = Person@2df6226d</span><br><span class="line"></span><br><span class="line">scala&gt; p.sayHello</span><br><span class="line">Hello,my name is Tom.I&apos;m 21 years old and I have 2 hands.</span><br></pre></td></tr></table></figure></p><p><br><br><strong>main方法</strong><br>在scala中，如果要运行一个应用程序，那么必须有一个main方法作为入口。<br>scala中的main方法定义为def main(args:Array[String])，而且必须定义在object中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; object HelloWorld&#123;</span><br><span class="line">     |     def main(args:Array[String])&#123;</span><br><span class="line">     |         println(&quot;Hello World!&quot;)</span><br><span class="line">     |     &#125;</span><br><span class="line">     | &#125;</span><br><span class="line">defined object HelloWorld</span><br></pre></td></tr></table></figure></p><p>除了自己实现main方法外，还可以继承App Trait，然后将需要在main方法中运行的代码，直接作为object的构造函数代码，而且可以用args接收传入的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; object HelloWorld extends App&#123;</span><br><span class="line">     |     if(args.length &gt; 0) println(&quot;Hello,&quot; + args(0))</span><br><span class="line">     |     else println(&quot;Hello World!&quot;)</span><br><span class="line">     | &#125;</span><br><span class="line">defined object HelloWorld</span><br></pre></td></tr></table></figure></p><p>App Trait的工作原理：App Trait继承自DelayedInit Trait，scalac命令进行编译时，会把继承App Trait的object的构造函数代码都放到DelayedInit Trait的DelayedInit方法中执行。<br><br><br><strong>用object来实现枚举功能</strong><br>Scala没有类似于Java中的Enum这样的枚举特性，如果要实现枚举，需要使用object继承Enumeration类，并且调用Value方法来初始化枚举值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; object Season extends Enumeration&#123;</span><br><span class="line">     |     val SPRING,SUMMER,AUTUMN,WINTER = Value</span><br><span class="line">     | &#125;</span><br><span class="line">defined object Season</span><br></pre></td></tr></table></figure></p><p>还可以通过Value传入枚举值的id和name，通过id和toString可以获取值，还可以通过id和name来查找枚举值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; object Season extends Enumeration&#123;</span><br><span class="line">     |     val SPRING = Value(0,&quot;spring&quot;)</span><br><span class="line">     |     val SUMMER = Value(1,&quot;summer&quot;)</span><br><span class="line">     |     val AUTUMN = Value(2,&quot;autumn&quot;)</span><br><span class="line">     |     val WINTER = Value(3,&quot;winter&quot;)</span><br><span class="line">     | &#125;</span><br><span class="line">defined object Season</span><br><span class="line"></span><br><span class="line">scala&gt; Season.SPRING.id</span><br><span class="line">res0: Int = 0</span><br><span class="line"></span><br><span class="line">scala&gt; Season.SPRING.toString</span><br><span class="line">res1: String = spring</span><br><span class="line"></span><br><span class="line">scala&gt; Season(0)</span><br><span class="line">res2: Season.Value = spring</span><br><span class="line"></span><br><span class="line">scala&gt; Season.withName(&quot;spring&quot;)</span><br><span class="line">res3: Season.Value = spring</span><br></pre></td></tr></table></figure></p><p>使用枚举object.values可以遍历枚举值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; for(ele &lt;- Season.values) println(ele)</span><br><span class="line">spring</span><br><span class="line">summer</span><br><span class="line">autumn</span><br><span class="line">winter</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Scala中的object对象&lt;/strong&gt;&lt;br&gt;在Scala中，没有提供静态的修饰符static，但是object对象下的成员都是静态的。&lt;br&gt;第一次调用object的方法时，就会执行object的构造函数，但是object不能定义接收参数的构造函数。&lt;br&gt;object的构造函数只会在其第一次被调用时执行一次，以后再次调用不会再执行构造函数。&lt;br&gt;object通常用于作为单例模式的实现，或者放class的静态成员。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>老街</title>
    <link href="https://www.ggstu.com/2018/08/18/%E8%80%81%E8%A1%97/"/>
    <id>https://www.ggstu.com/2018/08/18/老街/</id>
    <published>2018-08-18T14:09:27.000Z</published>
    <updated>2018-08-19T07:20:46.724Z</updated>
    
    <content type="html"><![CDATA[<p><em>一张褪色的照片</em><br><em>好像带给我一点点怀念</em><br><em>巷尾老爷爷卖的热汤面</em><br><em>味道弥漫过旧旧的后院</em><br><em>流浪猫睡熟在摇晃秋千</em><br><a id="more"></a><br><em>夕阳照了一遍他眯着眼</em><br><em>那张同桌寄的明信片</em><br><em>安静的躺在课桌的里面</em><br><em>快要过完的春天</em><br><em>还有雕刻着图案的门帘</em><br><em>窄窄的长长的过道两边</em><br><em>老房子依然升起了炊烟</em><br><em>刚刚下完了小雨的季节</em><br><em>爸妈又一起走过的老街</em><br><em>记不得哪年的哪一天</em><br><em>很漫长又很短暂的岁月</em><br><em>现在已经回不去</em><br><em>早已流逝的光阴</em><br><em>手里的那一张渐渐模糊不清的车票</em><br><em>成了回忆的信号</em><br><em>忘不掉的是什么我也不知道</em><br><em>想不起当年模样</em><br><em>看也看不到</em> <em>去也去不了的地方</em><br><em>也许那老街的腔调是属于我的忧伤</em><br><em>嘴角那点微笑越来越勉强</em></p><p><em>忘不掉的是什么我也不知道</em><br><em>放不下熟悉片段</em><br><em>回头望一眼</em> <em>已经很多年的时间</em><br><em>透过手指间看着天</em><br><em>我又回到那老街</em><br><em>靠在你们身边渐行渐远</em></p><p><em>快要过完的春天</em><br><em>还有雕刻着图案的门帘</em><br><em>窄窄的长长的过道两边</em><br><em>老房子依然升起了炊烟</em><br><em>刚刚下完了小雨的季节</em><br><em>爸妈又一起走过的老街</em><br><em>记不得哪年的哪一天</em><br><em>很漫长又很短暂的岁月</em><br><em>现在已经回不去</em><br><em>早已流逝的光阴</em><br><em>手里的那一张渐渐模糊不清的车票</em><br><em>成了回忆的信号</em><br><em>忘不掉的是什么我也不知道</em><br><em>想不起当年模样</em><br><em>看也看不到</em> <em>去也去不了的地方</em><br><em>也许那老街的腔调是属于我的忧伤</em><br><em>嘴角那点微笑越来越勉强</em><br><em>忘不掉的是什么我也不知道</em><br><em>放不下熟悉片段</em><br><em>回头望一眼</em> <em>已经很多年的时间</em><br><em>透过手指间看着天</em><br><em>我又回到那老街</em><br><em>靠在你们身边渐行渐远</em></p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=133998&auto=1&height=66"></iframe><br><img src="http://pd8lpasbc.bkt.clouddn.com/%E5%A4%AB%E5%AD%90%E5%BA%991.jpg" width="60%" height="60%">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;一张褪色的照片&lt;/em&gt;&lt;br&gt;&lt;em&gt;好像带给我一点点怀念&lt;/em&gt;&lt;br&gt;&lt;em&gt;巷尾老爷爷卖的热汤面&lt;/em&gt;&lt;br&gt;&lt;em&gt;味道弥漫过旧旧的后院&lt;/em&gt;&lt;br&gt;&lt;em&gt;流浪猫睡熟在摇晃秋千&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="随便说说" scheme="https://www.ggstu.com/categories/%E9%9A%8F%E4%BE%BF%E8%AF%B4%E8%AF%B4/"/>
    
    
      <category term="心情" scheme="https://www.ggstu.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>Scala的类和对象</title>
    <link href="https://www.ggstu.com/2018/08/18/Scala%E7%9A%84%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.ggstu.com/2018/08/18/Scala的类和对象/</id>
    <published>2018-08-18T09:33:16.000Z</published>
    <updated>2018-08-19T14:00:40.823Z</updated>
    
    <content type="html"><![CDATA[<p>类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。<br><strong>创建类和对象</strong><br>例如：定义一个类，包含属性和方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Hello&#123;</span><br><span class="line">     |     private var name = &quot;Tom&quot;</span><br><span class="line">     |     def sayHello()&#123;println(&quot;Hello,my name is &quot; + name)&#125;</span><br><span class="line">     |     def getName = name</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Hello</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>创建类的对象，并调用其方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val s = new Hello</span><br><span class="line">s: Hello = Hello@3eb81efb</span><br><span class="line"></span><br><span class="line">scala&gt; s.sayHello()</span><br><span class="line">Hello,my name is Tom</span><br><span class="line"></span><br><span class="line">scala&gt; print(s.getName)</span><br><span class="line">Tom</span><br></pre></td></tr></table></figure></p><p><br><br><strong>属性的getter和setter方法</strong><br>当定义属性是var的时候，scala会自动为其生成对应的getter和setter方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student&#123;</span><br><span class="line">     |     var name = &quot;Tom&quot;</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br></pre></td></tr></table></figure></p><p>调用getter方法：name<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val t = new Student</span><br><span class="line">t: Student = Student@31920ade</span><br><span class="line"></span><br><span class="line">scala&gt; t.name</span><br><span class="line">res0: String = Tom</span><br></pre></td></tr></table></figure></p><p>调用setter方法：name_=<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; t.name = &quot;Bob&quot;</span><br><span class="line">t.name: String = Bob</span><br><span class="line"></span><br><span class="line">scala&gt; t.name</span><br><span class="line">res2: String = Bob</span><br></pre></td></tr></table></figure></p><p><br><br>当定义属性是val的时候，则只会生成getter方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student&#123;</span><br><span class="line">     |     val name = &quot;Tom&quot;</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br></pre></td></tr></table></figure></p><p>调用getter方法：name<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val t = new Student</span><br><span class="line">t: Student = Student@6cdba6dc</span><br><span class="line"></span><br><span class="line">scala&gt; t.name</span><br><span class="line">res0: String = Tom</span><br></pre></td></tr></table></figure></p><p>调用setter方法时出错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; t.name = &quot;Bob&quot;</span><br><span class="line">&lt;console&gt;:13: error: reassignment to val</span><br><span class="line">       t.name = &quot;Bob&quot;</span><br><span class="line">              ^</span><br></pre></td></tr></table></figure></p><p><br><br>当定义的属性是private的时候，则生成的getter和setter方法也是private的，即无法调用getter和setter方法，其只能在类中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student&#123;</span><br><span class="line">     |     private var name = &quot;Tom&quot;</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val t = new Student</span><br><span class="line">t: Student = Student@31920ade</span><br><span class="line"></span><br><span class="line">scala&gt; t.name</span><br><span class="line">&lt;console&gt;:14: error: variable name in class Student cannot be accessed in Student</span><br><span class="line">       t.name</span><br><span class="line">         ^</span><br><span class="line"></span><br><span class="line">scala&gt; t.name = &quot;Bob&quot;</span><br><span class="line">&lt;console&gt;:15: error: variable name in class Student cannot be accessed in Student</span><br><span class="line">val $ires0 = t.name</span><br><span class="line">               ^</span><br><span class="line">&lt;console&gt;:13: error: variable name in class Student cannot be accessed in Student</span><br><span class="line">       t.name = &quot;Bob&quot;</span><br><span class="line">         ^</span><br></pre></td></tr></table></figure></p><p>如果不希望生成getter和setter方法，则将属性声明为private[this]，表示该属性只属于该对象私有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student&#123;</span><br><span class="line">     |     private[this] var name = &quot;Tom&quot;</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val t = new Student</span><br><span class="line">t: Student = Student@1205bd62</span><br><span class="line"></span><br><span class="line">scala&gt; t.name</span><br><span class="line">&lt;console&gt;:14: error: value name is not a member of Student</span><br><span class="line">       t.name</span><br><span class="line">         ^</span><br><span class="line"></span><br><span class="line">scala&gt; t.name = &quot;Bob&quot;</span><br><span class="line">&lt;console&gt;:15: error: value name is not a member of Student</span><br><span class="line">val $ires0 = t.name</span><br><span class="line">               ^</span><br><span class="line">&lt;console&gt;:13: error: value name is not a member of Student</span><br><span class="line">       t.name = &quot;Bob&quot;</span><br><span class="line">         ^</span><br></pre></td></tr></table></figure></p><p><br><br>自定义getter和setter<br>可以根据需求为属性选择合适的修饰符：var、val、private、private[this]，进而来选择getter和setter方法<br>也可以自定义getter与setter方法对其进行控制<br>自定义setter方法的时候一定要注意scala的语法限制，属性_、=、参数间不能有空格<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student&#123;</span><br><span class="line">     |     private var myName = &quot;Tom&quot;</span><br><span class="line">     |     def name = &quot;My name is &quot; + myName</span><br><span class="line">     |     def name_=(newName:String)&#123;</span><br><span class="line">     |         println(&quot;Cannot change your name.&quot;)</span><br><span class="line">     |     &#125;</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val t = new Student</span><br><span class="line">t: Student = Student@5cdec700</span><br><span class="line"></span><br><span class="line">scala&gt; t.name</span><br><span class="line">res0: String = My name is Tom</span><br><span class="line"></span><br><span class="line">scala&gt; t.name = &quot;Bob&quot;</span><br><span class="line">Cannot change your name.</span><br><span class="line">t.name: String = My name is Tom</span><br></pre></td></tr></table></figure></p><p><br><br>设置属性只有getter方法<br>如果不希望属性有setter方法，可以将其定义为val，但是此时再也不能更改属性的值了<br>但是如果希望属性只有一个getter方法，并且能够更改属性的值，那么需要综合使用private以及自定义getter方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student&#123;</span><br><span class="line">     |     private var myName = &quot;Tom&quot;</span><br><span class="line">     |     def updateName(newName:String)&#123;</span><br><span class="line">     |         if(newName == &quot;Bob&quot;) myName = newName</span><br><span class="line">     |         else print(&quot;Cannot change your name.&quot;)</span><br><span class="line">     |     &#125;</span><br><span class="line">     |     def name = &quot;My name is &quot; + myName</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val t = new Student</span><br><span class="line">t: Student = Student@662706a7</span><br><span class="line"></span><br><span class="line">scala&gt; t.name</span><br><span class="line">res0: String = My name is Tom</span><br><span class="line"></span><br><span class="line">scala&gt; t.name = &quot;Bob&quot;</span><br><span class="line">&lt;console&gt;:13: error: value name_= is not a member of Student</span><br><span class="line">       t.name = &quot;Bob&quot;</span><br><span class="line">         ^</span><br><span class="line"></span><br><span class="line">scala&gt; t.updateName(&quot;Bob&quot;)</span><br><span class="line"></span><br><span class="line">scala&gt; t.name</span><br><span class="line">res2: String = My name is Bob</span><br><span class="line"></span><br><span class="line">scala&gt; t.updateName(&quot;Alice&quot;)</span><br><span class="line">Cannot change your name.</span><br></pre></td></tr></table></figure></p><p><br><br><strong>类的构造器</strong><br>类的构造器分为：主构造器、辅助构造器<br>Scala中，主构造器是与类名放在一起的，与java不同，并且只能有一个主构造器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student(val name:String,val age:Int)&#123;</span><br><span class="line">     |     println(&quot;Hello,my name is &quot; + name + &quot;,I&apos;m &quot; + age + &quot; years old.&quot;)</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student(&quot;Bob&quot;,18)</span><br><span class="line">Hello,my name is Bob,I&apos;m 18 years old.</span><br><span class="line">s: Student = Student@7a67e3c6</span><br></pre></td></tr></table></figure></p><p>主构造器还可以使用默认参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Student(val name:String = &quot;Tom&quot;,val age:Int = 21)&#123;</span><br><span class="line">     |     println(&quot;Hello,my name is &quot; + name + &quot;,I&apos;m &quot; + age + &quot; years old.&quot;)</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Student</span><br><span class="line"></span><br><span class="line">scala&gt; val s = new Student()</span><br><span class="line">Hello,my name is Tom,I&apos;m 21 years old.</span><br><span class="line">s: Student = Student@421bba99</span><br></pre></td></tr></table></figure></p><p>Scala中，可以给类定义多个辅助构造器，通过关键字this来实现<br>辅助构造器之间可以互相调用，而且必须第一行调用主构造器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">// Entering paste mode (ctrl-D to finish)</span><br><span class="line"></span><br><span class="line">class Student&#123;</span><br><span class="line">    private var name = &quot;&quot;</span><br><span class="line">    private var age = 0</span><br><span class="line">    def this(name:String)&#123;</span><br><span class="line">        this()</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    def this(name:String,age:Int)&#123;</span><br><span class="line">        this(name)</span><br><span class="line">        this.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Exiting paste mode, now interpreting.</span><br><span class="line"></span><br><span class="line">defined class Student</span><br></pre></td></tr></table></figure></p><p><br><br><strong>内部类</strong><br>Scala中，同样可以在类中定义内部类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.collection.mutable.ArrayBuffer</span><br><span class="line">import scala.collection.mutable.ArrayBuffer</span><br><span class="line"></span><br><span class="line">scala&gt; class Class&#123;</span><br><span class="line">     |     class Student(val name:String)&#123;&#125;</span><br><span class="line">     |     val students = new ArrayBuffer[Student]</span><br><span class="line">     |     def getStudent(name:String) = &#123;</span><br><span class="line">     |         new Student(name)</span><br><span class="line">     |     &#125;</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Class</span><br><span class="line"></span><br><span class="line">scala&gt; val c = new Class</span><br><span class="line">c: Class = Class@1e287667</span><br><span class="line"></span><br><span class="line">scala&gt; val s = c.getStudent(&quot;Tom&quot;)</span><br><span class="line">s: c.Student = Class$Student@1e34c607</span><br><span class="line"></span><br><span class="line">scala&gt; c.students += s</span><br><span class="line">res0: c.students.type = ArrayBuffer(Class$Student@1e34c607)</span><br></pre></td></tr></table></figure></p><p><br><br>本文均为<font color="#f00">原创</font>，如需转载请注明链接<a href="http://www.ggstu.com">http://www.ggstu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。&lt;br&gt;&lt;strong&gt;创建类和对象&lt;/strong&gt;&lt;br&gt;例如：定义一个类，包含属性和方法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scala&amp;gt; class Hello&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     |     private var name = &amp;quot;Tom&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     |     def sayHello()&amp;#123;println(&amp;quot;Hello,my name is &amp;quot; + name)&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     |     def getName = name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     | &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;defined class Hello&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://www.ggstu.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Scala" scheme="https://www.ggstu.com/tags/Scala/"/>
    
  </entry>
  
</feed>
